/*
	Package main - transpiled by c2go version: v0.24.5 Cadmium 2018-06-17

	If you have found any issues, please raise an issue at:
	https://github.com/elliotchance/c2go/
*/

// Warning (EnumDecl):  /usr/include/ctype.h:46 : Add support of continues counter for type : *ast.ParenExpr
// Warning (RecordDecl):  /usr/include/libio.h:144 : could not lookup type definition for : _IO_FILE
// Warning: using unsafe slice cast to convert from []byte to []byte

package libpcre

import "github.com/elliotchance/c2go/linux"
import "github.com/elliotchance/c2go/noarch"
import "unsafe"

type __u_char uint8
type __u_short uint16
type __u_int uint32
type __u_long uint32
type __int8_t int8
type __uint8_t uint8
type __int16_t int16
type __uint16_t uint16
type __int32_t int32
type __uint32_t uint32
type __int64_t int32
type __uint64_t uint32
type __quad_t int32
type __u_quad_t uint32
type __dev_t uint32
type __uid_t uint32
type __gid_t uint32
type __ino_t uint32
type __ino64_t uint32
type __mode_t uint32
type __nlink_t uint32
type __off_t int32
type __off64_t int32
type __pid_t int32
type __fsid_t struct {
	__val [2]int32
}
type __clock_t int32
type __rlim_t uint32
type __rlim64_t uint32
type __id_t uint32
type __time_t int32
type __useconds_t uint32
type __suseconds_t int32
type __daddr_t int32
type __key_t int32
type __clockid_t int32
type __timer_t unsafe.Pointer
type __blksize_t int32
type __blkcnt_t int32
type __blkcnt64_t int32
type __fsblkcnt_t uint32
type __fsblkcnt64_t uint32
type __fsfilcnt_t uint32
type __fsfilcnt64_t uint32
type __fsword_t int32
type __ssize_t int32
type __syscall_slong_t int32
type __syscall_ulong_t uint32
type __loff_t __off64_t
type __qaddr_t *__quad_t
type __caddr_t *byte
type __intptr_t int32
type __socklen_t uint32

const _ISupper uint16 = ((1 << 0) << 8)
const // Warning (EnumDecl):  /usr/include/ctype.h:46 : Add support of continues counter for type : *ast.ParenExpr
_ISlower uint16 = ((1 << 1) << 8)
const _ISalpha uint16 = ((1 << 2) << 8)
const _ISdigit uint16 = ((1 << 3) << 8)
const _ISxdigit uint16 = ((1 << 4) << 8)
const _ISspace uint16 = ((1 << 5) << 8)
const _ISprint uint16 = ((1 << 6) << 8)
const _ISgraph uint16 = ((1 << 7) << 8)
const _ISblank uint16 = ((1 << 8) >> 8)
const _IScntrl uint16 = ((1 << 9) >> 8)
const _ISpunct uint16 = ((1 << 10) >> 8)
const _ISalnum uint16 = ((1 << 11) >> 8)

type __locale_t int32
type locale_t __locale_t
type ptrdiff_t int32
type size_t uint32
type wchar_t int32
type max_align_t struct {
	__clang_max_align_nonce1 int64
	__clang_max_align_nonce2 float64
}
type FILE _IO_FILE
type __FILE _IO_FILE
type BSunionSatSSusrSincludeSwcharPhD85D3E struct{ memory unsafe.Pointer }

func (unionVar *BSunionSatSSusrSincludeSwcharPhD85D3E) copy() BSunionSatSSusrSincludeSwcharPhD85D3E {
	var buffer [8]byte
	for i := range buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion BSunionSatSSusrSincludeSwcharPhD85D3E
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *BSunionSatSSusrSincludeSwcharPhD85D3E) __wch() *uint32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*uint32)(unionVar.memory)
}
func (unionVar *BSunionSatSSusrSincludeSwcharPhD85D3E) __wchb() *[4]byte {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[4]byte)(unionVar.memory)
}

type __mbstate_t struct {
	__count int32
	__value BSunionSatSSusrSincludeSwcharPhD85D3E
}
type _G_fpos_t struct {
	__pos   __off_t
	__state int64
}
type _G_fpos64_t struct {
	__pos   __off64_t
	__state int64
}
type va_list int64
type __gnuc_va_list int64
type _IO_jump_t struct {
}
type _IO_lock_t interface{}
type _IO_marker struct {
	_next *_IO_marker
	_sbuf *_IO_FILE
	_pos  int32
}
type __codecvt_result int32

const ( // Warning (RecordDecl):  /usr/include/libio.h:144 : could not lookup type definition for : _IO_FILE
	__codecvt_ok      __codecvt_result = 0
	__codecvt_partial                  = 1
	__codecvt_error                    = 2
	__codecvt_noconv                   = 3
)

type _IO_FILE struct {
	_flags          int32
	_IO_read_ptr    *byte
	_IO_read_end    *byte
	_IO_read_base   *byte
	_IO_write_base  *byte
	_IO_write_ptr   *byte
	_IO_write_end   *byte
	_IO_buf_base    *byte
	_IO_buf_end     *byte
	_IO_save_base   *byte
	_IO_backup_base *byte
	_IO_save_end    *byte
	_markers        *_IO_marker
	_chain          *_IO_FILE
	_fileno         int32
	_flags2         int32
	_old_offset     __off_t
	_cur_column     uint16
	_vtable_offset  int8
	_shortbuf       [1]byte
	_lock           *_IO_lock_t
	_offset         __off64_t
	__pad1          unsafe.Pointer
	__pad2          unsafe.Pointer
	__pad3          unsafe.Pointer
	__pad4          unsafe.Pointer
	__pad5          size_t
	_mode           int32
	_unused2        [20]byte
}
type _IO_FILE_plus struct {
}
type __io_read_fn func(unsafe.Pointer, *byte, size_t) __ssize_t
type __io_write_fn func(unsafe.Pointer, *byte, size_t) __ssize_t
type __io_seek_fn func(unsafe.Pointer, *__off64_t, int32) int32
type __io_close_fn func(unsafe.Pointer) int32
type cookie_read_function_t __io_read_fn
type cookie_write_function_t __io_write_fn
type cookie_seek_function_t __io_seek_fn
type cookie_close_function_t __io_close_fn
type _IO_cookie_io_functions_t struct {
	read  __io_read_fn
	write __io_write_fn
	seek  __io_seek_fn
	close __io_close_fn
}
type cookie_io_functions_t _IO_cookie_io_functions_t
type _IO_cookie_file struct {
}
type off_t __off_t
type off64_t __off64_t
type ssize_t __ssize_t
type fpos_t _G_fpos_t
type fpos64_t _G_fpos64_t

var stdin *noarch.File

var stdout *noarch.File

var stderr *noarch.File

type obstack struct {
}

const P_ALL int32 = 0
const P_PID int32 = 1
const P_PGID int32 = 2

type idtype_t int32
type div_t struct {
	quot int32
	rem  int32
}
type ldiv_t struct {
	quot int32
	rem  int32
}
type lldiv_t struct {
	quot int64
	rem  int64
}
type u_char __u_char
type u_short __u_short
type u_int __u_int
type u_long __u_long
type quad_t __quad_t
type u_quad_t __u_quad_t
type fsid_t __fsid_t
type loff_t __loff_t
type ino_t __ino_t
type ino64_t __ino64_t
type dev_t __dev_t
type gid_t __gid_t
type mode_t __mode_t
type nlink_t __nlink_t
type uid_t __uid_t
type pid_t __pid_t
type id_t __id_t
type daddr_t __daddr_t
type caddr_t __caddr_t
type key_t __key_t
type clock_t __clock_t
type time_t __time_t
type clockid_t __clockid_t
type timer_t __timer_t
type useconds_t __useconds_t
type suseconds_t __suseconds_t
type ulong uint32
type ushort uint16
type uint uint32
type int8_t int8
type int16_t int16
type int32_t int32
type int64_t int32
type u_int8_t uint8
type u_int16_t uint16
type u_int32_t uint32
type u_int64_t uint32
type register_t int32
type __sig_atomic_t int32
type __sigset_t struct {
	__val [16]uint32
}
type sigset_t __sigset_t
type timespec struct {
	tv_sec  __time_t
	tv_nsec __syscall_slong_t
}
type timeval struct {
	tv_sec  __time_t
	tv_usec __suseconds_t
}
type __fd_mask int32
type fd_set struct {
	fds_bits [16]__fd_mask
}
type fd_mask __fd_mask
type blksize_t __blksize_t
type blkcnt_t __blkcnt_t
type fsblkcnt_t __fsblkcnt_t
type fsfilcnt_t __fsfilcnt_t
type blkcnt64_t __blkcnt64_t
type fsblkcnt64_t __fsblkcnt64_t
type fsfilcnt64_t __fsfilcnt64_t
type pthread_t uint32
type pthread_attr_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_attr_t) copy() pthread_attr_t {
	var buffer [56]byte
	for i := range buffer {
		buffer[i] = (*((*[56]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_attr_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_attr_t) __size() *[56]byte {
	if unionVar.memory == nil {
		var buffer [56]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[56]byte)(unionVar.memory)
}
func (unionVar *pthread_attr_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [56]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type __pthread_internal_list struct {
	__prev *__pthread_internal_list
	__next *__pthread_internal_list
}
type __pthread_list_t __pthread_internal_list
type __pthread_mutex_s struct {
	__lock    int32
	__count   uint32
	__owner   int32
	__nusers  uint32
	__kind    int32
	__spins   int16
	__elision int16
	__list    __pthread_list_t
}
type pthread_mutex_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_mutex_t) copy() pthread_mutex_t {
	var buffer [40]byte
	for i := range buffer {
		buffer[i] = (*((*[40]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_mutex_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_mutex_t) __data() *__pthread_mutex_s {
	if unionVar.memory == nil {
		var buffer [40]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*__pthread_mutex_s)(unionVar.memory)
}
func (unionVar *pthread_mutex_t) __size() *[40]byte {
	if unionVar.memory == nil {
		var buffer [40]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[40]byte)(unionVar.memory)
}
func (unionVar *pthread_mutex_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [40]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type pthread_mutexattr_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_mutexattr_t) copy() pthread_mutexattr_t {
	var buffer [8]byte
	for i := range buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_mutexattr_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_mutexattr_t) __size() *[4]byte {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[4]byte)(unionVar.memory)
}
func (unionVar *pthread_mutexattr_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD141D3E struct {
	__lock          int32
	__futex         uint32
	__total_seq     uint64
	__wakeup_seq    uint64
	__woken_seq     uint64
	__mutex         unsafe.Pointer
	__nwaiters      uint32
	__broadcast_seq uint32
}
type pthread_cond_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_cond_t) copy() pthread_cond_t {
	var buffer [72]byte
	for i := range buffer {
		buffer[i] = (*((*[72]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_cond_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_cond_t) __data() *BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD141D3E {
	if unionVar.memory == nil {
		var buffer [72]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD141D3E)(unionVar.memory)
}
func (unionVar *pthread_cond_t) __size() *[48]byte {
	if unionVar.memory == nil {
		var buffer [72]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[48]byte)(unionVar.memory)
}
func (unionVar *pthread_cond_t) __align() *int64 {
	if unionVar.memory == nil {
		var buffer [72]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int64)(unionVar.memory)
}

type pthread_condattr_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_condattr_t) copy() pthread_condattr_t {
	var buffer [8]byte
	for i := range buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_condattr_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_condattr_t) __size() *[4]byte {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[4]byte)(unionVar.memory)
}
func (unionVar *pthread_condattr_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type pthread_key_t uint32
type pthread_once_t int32
type BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD177D3E struct {
	__lock              int32
	__nr_readers        uint32
	__readers_wakeup    uint32
	__writer_wakeup     uint32
	__nr_readers_queued uint32
	__nr_writers_queued uint32
	__writer            int32
	__shared            int32
	__rwelision         int8
	__pad1              [7]uint8
	__pad2              uint32
	__flags             uint32
}
type pthread_rwlock_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_rwlock_t) copy() pthread_rwlock_t {
	var buffer [56]byte
	for i := range buffer {
		buffer[i] = (*((*[56]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_rwlock_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_rwlock_t) __data() *BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD177D3E {
	if unionVar.memory == nil {
		var buffer [56]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*BSstructSatSSusrSincludeSx86_64TlinuxTgnuSbitsSpthreadtypesPhD177D3E)(unionVar.memory)
}
func (unionVar *pthread_rwlock_t) __size() *[56]byte {
	if unionVar.memory == nil {
		var buffer [56]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[56]byte)(unionVar.memory)
}
func (unionVar *pthread_rwlock_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [56]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type pthread_rwlockattr_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_rwlockattr_t) copy() pthread_rwlockattr_t {
	var buffer [8]byte
	for i := range buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_rwlockattr_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_rwlockattr_t) __size() *[8]byte {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[8]byte)(unionVar.memory)
}
func (unionVar *pthread_rwlockattr_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type pthread_spinlock_t int32
type pthread_barrier_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_barrier_t) copy() pthread_barrier_t {
	var buffer [32]byte
	for i := range buffer {
		buffer[i] = (*((*[32]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_barrier_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_barrier_t) __size() *[32]byte {
	if unionVar.memory == nil {
		var buffer [32]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[32]byte)(unionVar.memory)
}
func (unionVar *pthread_barrier_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [32]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type pthread_barrierattr_t struct{ memory unsafe.Pointer }

func (unionVar *pthread_barrierattr_t) copy() pthread_barrierattr_t {
	var buffer [8]byte
	for i := range buffer {
		buffer[i] = (*((*[8]byte)(unionVar.memory)))[i]
	}
	var newUnion pthread_barrierattr_t
	newUnion.memory = unsafe.Pointer(&buffer)
	return newUnion
}
func (unionVar *pthread_barrierattr_t) __size() *[4]byte {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*[4]byte)(unionVar.memory)
}
func (unionVar *pthread_barrierattr_t) __align() *int32 {
	if unionVar.memory == nil {
		var buffer [8]byte
		unionVar.memory = unsafe.Pointer(&buffer)
	}
	return (*int32)(unionVar.memory)
}

type random_data struct {
	fptr      *int32_t
	rptr      *int32_t
	state     *int32_t
	rand_type int32
	rand_deg  int32
	rand_sep  int32
	end_ptr   *int32_t
}
type drand48_data struct {
	__x     [3]uint16
	__old_x [3]uint16
	__c     uint16
	__init  uint16
	__a     uint64
}
type __compar_fn_t func(unsafe.Pointer, unsafe.Pointer) int32
type comparison_fn_t __compar_fn_t
type __compar_d_fn_t func(unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32
type pcre_uint8 uint8
type pcre_uint16 uint16
type pcre_int16 int16
type pcre_uint32 uint32
type pcre_int32 int32
type uint8_t uint8
type uint16_t uint16
type uint32_t uint32
type uint64_t uint32
type int_least8_t int8
type int_least16_t int16
type int_least32_t int32
type int_least64_t int32
type uint_least8_t uint8
type uint_least16_t uint16
type uint_least32_t uint32
type uint_least64_t uint32
type int_fast8_t int8
type int_fast16_t int32
type int_fast32_t int32
type int_fast64_t int32
type uint_fast8_t uint8
type uint_fast16_t uint32
type uint_fast32_t uint32
type uint_fast64_t uint32
type intptr_t int32
type uintptr_t uint32
type intmax_t int32
type uintmax_t uint32
type pcre_uchar uint8
type pcre real_pcre8_or_16
type pcre16 real_pcre8_or_16
type pcre32 real_pcre32
type pcre_extra struct {
	flags                 uint32
	study_data            unsafe.Pointer
	match_limit           uint32
	callout_data          unsafe.Pointer
	tables                *uint8
	match_limit_recursion uint32
	mark                  **uint8
	executable_jit        unsafe.Pointer
}
type pcre16_extra struct {
	flags                 uint32
	study_data            unsafe.Pointer
	match_limit           uint32
	callout_data          unsafe.Pointer
	tables                *uint8
	match_limit_recursion uint32
	mark                  **uint16
	executable_jit        unsafe.Pointer
}
type pcre32_extra struct {
	flags                 uint32
	study_data            unsafe.Pointer
	match_limit           uint32
	callout_data          unsafe.Pointer
	tables                *uint8
	match_limit_recursion uint32
	mark                  **uint32
	executable_jit        unsafe.Pointer
}
type pcre_callout_block struct {
	version          int32
	callout_number   int32
	offset_vector    *int32
	subject          *byte
	subject_length   int32
	start_match      int32
	current_position int32
	capture_top      int32
	capture_last     int32
	callout_data     unsafe.Pointer
	pattern_position int32
	next_item_length int32
	mark             *uint8
}
type pcre16_callout_block struct {
	version          int32
	callout_number   int32
	offset_vector    *int32
	subject          *uint16
	subject_length   int32
	start_match      int32
	current_position int32
	capture_top      int32
	capture_last     int32
	callout_data     unsafe.Pointer
	pattern_position int32
	next_item_length int32
	mark             *uint16
}
type pcre32_callout_block struct {
	version          int32
	callout_number   int32
	offset_vector    *int32
	subject          *uint32
	subject_length   int32
	start_match      int32
	current_position int32
	capture_top      int32
	capture_last     int32
	callout_data     unsafe.Pointer
	pattern_position int32
	next_item_length int32
	mark             *uint32
}

var pcre_malloc func(size_t) unsafe.Pointer
var pcre_free func(unsafe.Pointer)
var pcre_stack_malloc func(size_t) unsafe.Pointer
var pcre_stack_free func(unsafe.Pointer)
var pcre_callout func(*pcre_callout_block) int32
var pcre_stack_guard func() int32
var pcre16_malloc func(size_t) unsafe.Pointer
var pcre16_free func(unsafe.Pointer)
var pcre16_stack_malloc func(size_t) unsafe.Pointer
var pcre16_stack_free func(unsafe.Pointer)
var pcre16_callout func(*pcre16_callout_block) int32
var pcre16_stack_guard func() int32
var pcre32_malloc func(size_t) unsafe.Pointer
var pcre32_free func(unsafe.Pointer)
var pcre32_stack_malloc func(size_t) unsafe.Pointer
var pcre32_stack_free func(unsafe.Pointer)
var pcre32_callout func(*pcre32_callout_block) int32
var pcre32_stack_guard func() int32


const ucp_C int32 = 0
const ucp_L int32 = 1
const ucp_M int32 = 2
const ucp_N int32 = 3
const ucp_P int32 = 4
const ucp_S int32 = 5
const ucp_Z int32 = 6
const ucp_Cc int32 = 0
const ucp_Cf int32 = 1
const ucp_Cn int32 = 2
const ucp_Co int32 = 3
const ucp_Cs int32 = 4
const ucp_Ll int32 = 5
const ucp_Lm int32 = 6
const ucp_Lo int32 = 7
const ucp_Lt int32 = 8
const ucp_Lu int32 = 9
const ucp_Mc int32 = 10
const ucp_Me int32 = 11
const ucp_Mn int32 = 12
const ucp_Nd int32 = 13
const ucp_Nl int32 = 14
const ucp_No int32 = 15
const ucp_Pc int32 = 16
const ucp_Pd int32 = 17
const ucp_Pe int32 = 18
const ucp_Pf int32 = 19
const ucp_Pi int32 = 20
const ucp_Po int32 = 21
const ucp_Ps int32 = 22
const ucp_Sc int32 = 23
const ucp_Sk int32 = 24
const ucp_Sm int32 = 25
const ucp_So int32 = 26
const ucp_Zl int32 = 27
const ucp_Zp int32 = 28
const ucp_Zs int32 = 29
const ucp_gbCR int32 = 0
const ucp_gbLF int32 = 1
const ucp_gbControl int32 = 2
const ucp_gbExtend int32 = 3
const ucp_gbPrepend int32 = 4
const ucp_gbSpacingMark int32 = 5
const ucp_gbL int32 = 6
const ucp_gbV int32 = 7
const ucp_gbT int32 = 8
const ucp_gbLV int32 = 9
const ucp_gbLVT int32 = 10
const ucp_gbRegionalIndicator int32 = 11
const ucp_gbOther int32 = 12
const ucp_Arabic int32 = 0
const ucp_Armenian int32 = 1
const ucp_Bengali int32 = 2
const ucp_Bopomofo int32 = 3
const ucp_Braille int32 = 4
const ucp_Buginese int32 = 5
const ucp_Buhid int32 = 6
const ucp_Canadian_Aboriginal int32 = 7
const ucp_Cherokee int32 = 8
const ucp_Common int32 = 9
const ucp_Coptic int32 = 10
const ucp_Cypriot int32 = 11
const ucp_Cyrillic int32 = 12
const ucp_Deseret int32 = 13
const ucp_Devanagari int32 = 14
const ucp_Ethiopic int32 = 15
const ucp_Georgian int32 = 16
const ucp_Glagolitic int32 = 17
const ucp_Gothic int32 = 18
const ucp_Greek int32 = 19
const ucp_Gujarati int32 = 20
const ucp_Gurmukhi int32 = 21
const ucp_Han int32 = 22
const ucp_Hangul int32 = 23
const ucp_Hanunoo int32 = 24
const ucp_Hebrew int32 = 25
const ucp_Hiragana int32 = 26
const ucp_Inherited int32 = 27
const ucp_Kannada int32 = 28
const ucp_Katakana int32 = 29
const ucp_Kharoshthi int32 = 30
const ucp_Khmer int32 = 31
const ucp_Lao int32 = 32
const ucp_Latin int32 = 33
const ucp_Limbu int32 = 34
const ucp_Linear_B int32 = 35
const ucp_Malayalam int32 = 36
const ucp_Mongolian int32 = 37
const ucp_Myanmar int32 = 38
const ucp_New_Tai_Lue int32 = 39
const ucp_Ogham int32 = 40
const ucp_Old_Italic int32 = 41
const ucp_Old_Persian int32 = 42
const ucp_Oriya int32 = 43
const ucp_Osmanya int32 = 44
const ucp_Runic int32 = 45
const ucp_Shavian int32 = 46
const ucp_Sinhala int32 = 47
const ucp_Syloti_Nagri int32 = 48
const ucp_Syriac int32 = 49
const ucp_Tagalog int32 = 50
const ucp_Tagbanwa int32 = 51
const ucp_Tai_Le int32 = 52
const ucp_Tamil int32 = 53
const ucp_Telugu int32 = 54
const ucp_Thaana int32 = 55
const ucp_Thai int32 = 56
const ucp_Tibetan int32 = 57
const ucp_Tifinagh int32 = 58
const ucp_Ugaritic int32 = 59
const ucp_Yi int32 = 60
const ucp_Balinese int32 = 61
const ucp_Cuneiform int32 = 62
const ucp_Nko int32 = 63
const ucp_Phags_Pa int32 = 64
const ucp_Phoenician int32 = 65
const ucp_Carian int32 = 66
const ucp_Cham int32 = 67
const ucp_Kayah_Li int32 = 68
const ucp_Lepcha int32 = 69
const ucp_Lycian int32 = 70
const ucp_Lydian int32 = 71
const ucp_Ol_Chiki int32 = 72
const ucp_Rejang int32 = 73
const ucp_Saurashtra int32 = 74
const ucp_Sundanese int32 = 75
const ucp_Vai int32 = 76
const ucp_Avestan int32 = 77
const ucp_Bamum int32 = 78
const ucp_Egyptian_Hieroglyphs int32 = 79
const ucp_Imperial_Aramaic int32 = 80
const ucp_Inscriptional_Pahlavi int32 = 81
const ucp_Inscriptional_Parthian int32 = 82
const ucp_Javanese int32 = 83
const ucp_Kaithi int32 = 84
const ucp_Lisu int32 = 85
const ucp_Meetei_Mayek int32 = 86
const ucp_Old_South_Arabian int32 = 87
const ucp_Old_Turkic int32 = 88
const ucp_Samaritan int32 = 89
const ucp_Tai_Tham int32 = 90
const ucp_Tai_Viet int32 = 91
const ucp_Batak int32 = 92
const ucp_Brahmi int32 = 93
const ucp_Mandaic int32 = 94
const ucp_Chakma int32 = 95
const ucp_Meroitic_Cursive int32 = 96
const ucp_Meroitic_Hieroglyphs int32 = 97
const ucp_Miao int32 = 98
const ucp_Sharada int32 = 99
const ucp_Sora_Sompeng int32 = 100
const ucp_Takri int32 = 101
const ucp_Bassa_Vah int32 = 102
const ucp_Caucasian_Albanian int32 = 103
const ucp_Duployan int32 = 104
const ucp_Elbasan int32 = 105
const ucp_Grantha int32 = 106
const ucp_Khojki int32 = 107
const ucp_Khudawadi int32 = 108
const ucp_Linear_A int32 = 109
const ucp_Mahajani int32 = 110
const ucp_Manichaean int32 = 111
const ucp_Mende_Kikakui int32 = 112
const ucp_Modi int32 = 113
const ucp_Mro int32 = 114
const ucp_Nabataean int32 = 115
const ucp_Old_North_Arabian int32 = 116
const ucp_Old_Permic int32 = 117
const ucp_Pahawh_Hmong int32 = 118
const ucp_Palmyrene int32 = 119
const ucp_Psalter_Pahlavi int32 = 120
const ucp_Pau_Cin_Hau int32 = 121
const ucp_Siddham int32 = 122
const ucp_Tirhuta int32 = 123
const ucp_Warang_Citi int32 = 124

type BOOL int32

const ESC_A int32 = 1
const ESC_G int32 = 2
const ESC_K int32 = 3
const ESC_B int32 = 4
const ESC_b int32 = 5
const ESC_D int32 = 6
const ESC_d int32 = 7
const ESC_S int32 = 8
const ESC_s int32 = 9
const ESC_W int32 = 10
const ESC_w int32 = 11
const ESC_N int32 = 12
const ESC_dum int32 = 13
const ESC_C int32 = 14
const ESC_P int32 = 15
const ESC_p int32 = 16
const ESC_R int32 = 17
const ESC_H int32 = 18
const ESC_h int32 = 19
const ESC_V int32 = 20
const ESC_v int32 = 21
const ESC_X int32 = 22
const ESC_Z int32 = 23
const ESC_z int32 = 24
const ESC_E int32 = 25
const ESC_Q int32 = 26
const ESC_g int32 = 27
const ESC_k int32 = 28
const ESC_DU int32 = 29
const ESC_du int32 = 30
const ESC_SU int32 = 31
const ESC_su int32 = 32
const ESC_WU int32 = 33
const ESC_wu int32 = 34
const OP_END int32 = 0
const OP_SOD int32 = 1
const OP_SOM int32 = 2
const OP_SET_SOM int32 = 3
const OP_NOT_WORD_BOUNDARY int32 = 4
const OP_WORD_BOUNDARY int32 = 5
const OP_NOT_DIGIT int32 = 6
const OP_DIGIT int32 = 7
const OP_NOT_WHITESPACE int32 = 8
const OP_WHITESPACE int32 = 9
const OP_NOT_WORDCHAR int32 = 10
const OP_WORDCHAR int32 = 11
const OP_ANY int32 = 12
const OP_ALLANY int32 = 13
const OP_ANYBYTE int32 = 14
const OP_NOTPROP int32 = 15
const OP_PROP int32 = 16
const OP_ANYNL int32 = 17
const OP_NOT_HSPACE int32 = 18
const OP_HSPACE int32 = 19
const OP_NOT_VSPACE int32 = 20
const OP_VSPACE int32 = 21
const OP_EXTUNI int32 = 22
const OP_EODN int32 = 23
const OP_EOD int32 = 24
const OP_DOLL int32 = 25
const OP_DOLLM int32 = 26
const OP_CIRC int32 = 27
const OP_CIRCM int32 = 28
const OP_CHAR int32 = 29
const OP_CHARI int32 = 30
const OP_NOT int32 = 31
const OP_NOTI int32 = 32
const OP_STAR int32 = 33
const OP_MINSTAR int32 = 34
const OP_PLUS int32 = 35
const OP_MINPLUS int32 = 36
const OP_QUERY int32 = 37
const OP_MINQUERY int32 = 38
const OP_UPTO int32 = 39
const OP_MINUPTO int32 = 40
const OP_EXACT int32 = 41
const OP_POSSTAR int32 = 42
const OP_POSPLUS int32 = 43
const OP_POSQUERY int32 = 44
const OP_POSUPTO int32 = 45
const OP_STARI int32 = 46
const OP_MINSTARI int32 = 47
const OP_PLUSI int32 = 48
const OP_MINPLUSI int32 = 49
const OP_QUERYI int32 = 50
const OP_MINQUERYI int32 = 51
const OP_UPTOI int32 = 52
const OP_MINUPTOI int32 = 53
const OP_EXACTI int32 = 54
const OP_POSSTARI int32 = 55
const OP_POSPLUSI int32 = 56
const OP_POSQUERYI int32 = 57
const OP_POSUPTOI int32 = 58
const OP_NOTSTAR int32 = 59
const OP_NOTMINSTAR int32 = 60
const OP_NOTPLUS int32 = 61
const OP_NOTMINPLUS int32 = 62
const OP_NOTQUERY int32 = 63
const OP_NOTMINQUERY int32 = 64
const OP_NOTUPTO int32 = 65
const OP_NOTMINUPTO int32 = 66
const OP_NOTEXACT int32 = 67
const OP_NOTPOSSTAR int32 = 68
const OP_NOTPOSPLUS int32 = 69
const OP_NOTPOSQUERY int32 = 70
const OP_NOTPOSUPTO int32 = 71
const OP_NOTSTARI int32 = 72
const OP_NOTMINSTARI int32 = 73
const OP_NOTPLUSI int32 = 74
const OP_NOTMINPLUSI int32 = 75
const OP_NOTQUERYI int32 = 76
const OP_NOTMINQUERYI int32 = 77
const OP_NOTUPTOI int32 = 78
const OP_NOTMINUPTOI int32 = 79
const OP_NOTEXACTI int32 = 80
const OP_NOTPOSSTARI int32 = 81
const OP_NOTPOSPLUSI int32 = 82
const OP_NOTPOSQUERYI int32 = 83
const OP_NOTPOSUPTOI int32 = 84
const OP_TYPESTAR int32 = 85
const OP_TYPEMINSTAR int32 = 86
const OP_TYPEPLUS int32 = 87
const OP_TYPEMINPLUS int32 = 88
const OP_TYPEQUERY int32 = 89
const OP_TYPEMINQUERY int32 = 90
const OP_TYPEUPTO int32 = 91
const OP_TYPEMINUPTO int32 = 92
const OP_TYPEEXACT int32 = 93
const OP_TYPEPOSSTAR int32 = 94
const OP_TYPEPOSPLUS int32 = 95
const OP_TYPEPOSQUERY int32 = 96
const OP_TYPEPOSUPTO int32 = 97
const OP_CRSTAR int32 = 98
const OP_CRMINSTAR int32 = 99
const OP_CRPLUS int32 = 100
const OP_CRMINPLUS int32 = 101
const OP_CRQUERY int32 = 102
const OP_CRMINQUERY int32 = 103
const OP_CRRANGE int32 = 104
const OP_CRMINRANGE int32 = 105
const OP_CRPOSSTAR int32 = 106
const OP_CRPOSPLUS int32 = 107
const OP_CRPOSQUERY int32 = 108
const OP_CRPOSRANGE int32 = 109
const OP_CLASS int32 = 110
const OP_NCLASS int32 = 111
const OP_XCLASS int32 = 112
const OP_REF int32 = 113
const OP_REFI int32 = 114
const OP_DNREF int32 = 115
const OP_DNREFI int32 = 116
const OP_RECURSE int32 = 117
const OP_CALLOUT int32 = 118
const OP_ALT int32 = 119
const OP_KET int32 = 120
const OP_KETRMAX int32 = 121
const OP_KETRMIN int32 = 122
const OP_KETRPOS int32 = 123
const OP_REVERSE int32 = 124
const OP_ASSERT int32 = 125
const OP_ASSERT_NOT int32 = 126
const OP_ASSERTBACK int32 = 127
const OP_ASSERTBACK_NOT int32 = 128
const OP_ONCE int32 = 129
const OP_ONCE_NC int32 = 130
const OP_BRA int32 = 131
const OP_BRAPOS int32 = 132
const OP_CBRA int32 = 133
const OP_CBRAPOS int32 = 134
const OP_COND int32 = 135
const OP_SBRA int32 = 136
const OP_SBRAPOS int32 = 137
const OP_SCBRA int32 = 138
const OP_SCBRAPOS int32 = 139
const OP_SCOND int32 = 140
const OP_CREF int32 = 141
const OP_DNCREF int32 = 142
const OP_RREF int32 = 143
const OP_DNRREF int32 = 144
const OP_DEF int32 = 145
const OP_BRAZERO int32 = 146
const OP_BRAMINZERO int32 = 147
const OP_BRAPOSZERO int32 = 148
const OP_MARK int32 = 149
const OP_PRUNE int32 = 150
const OP_PRUNE_ARG int32 = 151
const OP_SKIP int32 = 152
const OP_SKIP_ARG int32 = 153
const OP_THEN int32 = 154
const OP_THEN_ARG int32 = 155
const OP_COMMIT int32 = 156
const OP_FAIL int32 = 157
const OP_ACCEPT int32 = 158
const OP_ASSERT_ACCEPT int32 = 159
const OP_CLOSE int32 = 160
const OP_SKIPZERO int32 = 161
const OP_TABLE_LENGTH int32 = 162
const ERR0 int32 = 0
const ERR1 int32 = 1
const ERR2 int32 = 2
const ERR3 int32 = 3
const ERR4 int32 = 4
const ERR5 int32 = 5
const ERR6 int32 = 6
const ERR7 int32 = 7
const ERR8 int32 = 8
const ERR9 int32 = 9
const ERR10 int32 = 10
const ERR11 int32 = 11
const ERR12 int32 = 12
const ERR13 int32 = 13
const ERR14 int32 = 14
const ERR15 int32 = 15
const ERR16 int32 = 16
const ERR17 int32 = 17
const ERR18 int32 = 18
const ERR19 int32 = 19
const ERR20 int32 = 20
const ERR21 int32 = 21
const ERR22 int32 = 22
const ERR23 int32 = 23
const ERR24 int32 = 24
const ERR25 int32 = 25
const ERR26 int32 = 26
const ERR27 int32 = 27
const ERR28 int32 = 28
const ERR29 int32 = 29
const ERR30 int32 = 30
const ERR31 int32 = 31
const ERR32 int32 = 32
const ERR33 int32 = 33
const ERR34 int32 = 34
const ERR35 int32 = 35
const ERR36 int32 = 36
const ERR37 int32 = 37
const ERR38 int32 = 38
const ERR39 int32 = 39
const ERR40 int32 = 40
const ERR41 int32 = 41
const ERR42 int32 = 42
const ERR43 int32 = 43
const ERR44 int32 = 44
const ERR45 int32 = 45
const ERR46 int32 = 46
const ERR47 int32 = 47
const ERR48 int32 = 48
const ERR49 int32 = 49
const ERR50 int32 = 50
const ERR51 int32 = 51
const ERR52 int32 = 52
const ERR53 int32 = 53
const ERR54 int32 = 54
const ERR55 int32 = 55
const ERR56 int32 = 56
const ERR57 int32 = 57
const ERR58 int32 = 58
const ERR59 int32 = 59
const ERR60 int32 = 60
const ERR61 int32 = 61
const ERR62 int32 = 62
const ERR63 int32 = 63
const ERR64 int32 = 64
const ERR65 int32 = 65
const ERR66 int32 = 66
const ERR67 int32 = 67
const ERR68 int32 = 68
const ERR69 int32 = 69
const ERR70 int32 = 70
const ERR71 int32 = 71
const ERR72 int32 = 72
const ERR73 int32 = 73
const ERR74 int32 = 74
const ERR75 int32 = 75
const ERR76 int32 = 76
const ERR77 int32 = 77
const ERR78 int32 = 78
const ERR79 int32 = 79
const ERR80 int32 = 80
const ERR81 int32 = 81
const ERR82 int32 = 82
const ERR83 int32 = 83
const ERR84 int32 = 84
const ERR85 int32 = 85
const ERR86 int32 = 86
const ERR87 int32 = 87
const ERRCOUNT int32 = 88
const JIT_COMPILE int32 = 0
const JIT_PARTIAL_SOFT_COMPILE int32 = 1
const JIT_PARTIAL_HARD_COMPILE int32 = 2
const JIT_NUMBER_OF_COMPILE_MODES int32 = 3

type real_pcre8_or_16 struct {
	magic_number      pcre_uint32
	size              pcre_uint32
	options           pcre_uint32
	flags             pcre_uint32
	limit_match       pcre_uint32
	limit_recursion   pcre_uint32
	first_char        pcre_uint16
	req_char          pcre_uint16
	max_lookbehind    pcre_uint16
	top_bracket       pcre_uint16
	top_backref       pcre_uint16
	name_table_offset pcre_uint16
	name_entry_size   pcre_uint16
	name_count        pcre_uint16
	ref_count         pcre_uint16
	dummy1            pcre_uint16
	dummy2            pcre_uint16
	dummy3            pcre_uint16
	tables            *pcre_uint8
	nullpad           unsafe.Pointer
}
type real_pcre real_pcre8_or_16
type real_pcre16 real_pcre8_or_16
type real_pcre32 struct {
	magic_number      pcre_uint32
	size              pcre_uint32
	options           pcre_uint32
	flags             pcre_uint32
	limit_match       pcre_uint32
	limit_recursion   pcre_uint32
	first_char        pcre_uint32
	req_char          pcre_uint32
	max_lookbehind    pcre_uint16
	top_bracket       pcre_uint16
	top_backref       pcre_uint16
	name_table_offset pcre_uint16
	name_entry_size   pcre_uint16
	name_count        pcre_uint16
	ref_count         pcre_uint16
	dummy             pcre_uint16
	tables            *pcre_uint8
	nullpad           unsafe.Pointer
}
type __assert_real_pcre_size_divisible_8 []int32
type pcre_study_data struct {
	size       pcre_uint32
	flags      pcre_uint32
	start_bits [32]pcre_uint8
	minlength  pcre_uint32
}
type open_capitem struct {
	next   *open_capitem
	number pcre_uint16
	flag   pcre_uint16
}
type named_group struct {
	name   *pcre_uchar
	length int32
	number pcre_uint32
}
type compile_data struct {
	lcc                   *pcre_uint8
	fcc                   *pcre_uint8
	cbits                 *pcre_uint8
	ctypes                *pcre_uint8
	start_workspace       *pcre_uchar
	start_code            *pcre_uchar
	start_pattern         *pcre_uchar
	end_pattern           *pcre_uchar
	hwm                   *pcre_uchar
	open_caps             *open_capitem
	named_groups          *named_group
	name_table            *pcre_uchar
	names_found           int32
	name_entry_size       int32
	named_group_list_size int32
	workspace_size        int32
	bracount              uint32
	final_bracount        int32
	max_lookbehind        int32
	top_backref           int32
	backref_map           uint32
	namedrefcount         uint32
	parens_depth          int32
	assert_depth          int32
	external_options      pcre_uint32
	external_flags        pcre_uint32
	req_varyopt           int32
	had_accept            BOOL
	had_pruneorskip       BOOL
	check_lookbehind      BOOL
	dupnames              BOOL
	dupgroups             BOOL
	iscondassert          BOOL
	nltype                int32
	nllen                 int32
	nl                    [4]pcre_uchar
}
type branch_chain struct {
	outer          *branch_chain
	current_branch *pcre_uchar
}
type recurse_check struct {
	prev  *recurse_check
	group *pcre_uchar
}
type recursion_info struct {
	prevrec            *recursion_info
	group_num          uint32
	offset_save        *int32
	saved_max          int32
	saved_capture_last int32
	subject_position   *pcre_uchar
}
type dfa_recursion_info struct {
	prevrec          *dfa_recursion_info
	group_num        int32
	subject_position *pcre_uchar
}
type eptrblock struct {
	epb_prev       *eptrblock
	epb_saved_eptr *pcre_uchar
}
type match_data struct {
	match_call_count      uint32
	match_limit           uint32
	match_limit_recursion uint32
	offset_vector         *int32
	offset_end            int32
	offset_max            int32
	nltype                int32
	nllen                 int32
	name_count            int32
	name_entry_size       int32
	skip_arg_count        uint32
	ignore_skip_arg       uint32
	name_table            *pcre_uchar
	nl                    [4]pcre_uchar
	lcc                   *pcre_uint8
	fcc                   *pcre_uint8
	ctypes                *pcre_uint8
	notbol                BOOL
	noteol                BOOL
	utf                   BOOL
	jscript_compat        BOOL
	use_ucp               BOOL
	endonly               BOOL
	notempty              BOOL
	notempty_atstart      BOOL
	hitend                BOOL
	bsr_anycrlf           BOOL
	hasthen               BOOL
	start_code            *pcre_uchar
	start_subject         *pcre_uchar
	end_subject           *pcre_uchar
	start_match_ptr       *pcre_uchar
	end_match_ptr         *pcre_uchar
	start_used_ptr        *pcre_uchar
	partial               int32
	end_offset_top        int32
	capture_last          pcre_int32
	start_offset          int32
	match_function_type   int32
	eptrchain             *eptrblock
	eptrn                 int32
	recursive             *recursion_info
	callout_data          unsafe.Pointer
	mark                  *pcre_uchar
	nomatch_mark          *pcre_uchar
	once_target           *pcre_uchar
}
type dfa_match_data struct {
	start_code     *pcre_uchar
	start_subject  *pcre_uchar
	end_subject    *pcre_uchar
	start_used_ptr *pcre_uchar
	tables         *pcre_uint8
	start_offset   int32
	moptions       int32
	poptions       int32
	nltype         int32
	nllen          int32
	nl             [4]pcre_uchar
	callout_data   unsafe.Pointer
	recursive      *dfa_recursion_info
}
type ucp_type_table struct {
	name_offset pcre_uint16
	type_       pcre_uint16
	value       pcre_uint16
}
type ucd_record struct {
	script     pcre_uint8
	chartype   pcre_uint8
	gbprop     pcre_uint8
	caseset    pcre_uint8
	other_case pcre_int32
}

// swap_uint32 - transpiled function from  /root/Documents/pcre/pcre_byte_order.c:66
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2014 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains an internal function that tests a compiled pattern to
see if it was compiled with the opposite endianness. If so, it uses an
auxiliary local function to flip the appropriate bytes. */ //
/*************************************************
*             Swap byte functions                *
*************************************************/ //
/* The following functions swap the bytes of a pcre_uint16
and pcre_uint32 value.

Arguments:
  value        any number

Returns:       the byte swapped value
*/ //
//
func swap_uint32(value pcre_uint32) pcre_uint32 {
	return (((((value & pcre_uint32((uint32(int32(255))))) << uint64(int32(24))) | ((value & pcre_uint32((uint32(int32(65280))))) << uint64(int32(8)))) | ((value & pcre_uint32((uint32(int32(16711680))))) >> uint64(int32(8)))) | (value >> uint64(int32(24))))
}

// swap_uint16 - transpiled function from  /root/Documents/pcre/pcre_byte_order.c:75
func swap_uint16(value pcre_uint16) pcre_uint16 {
	return pcre_uint16(((int32(uint16((value))) >> uint64(int32(8))) | (int32(uint16((value))) << uint64(int32(8)))))
}

// pcre_pattern_to_host_byte_order - transpiled function from  /root/Documents/pcre/pcre_byte_order.c:99
/*************************************************
*       Test for a byte-flipped compiled regex   *
*************************************************/ //
/* This function swaps the bytes of a compiled pattern usually
loaded form the disk. It also sets the tables pointer, which
is likely an invalid pointer after reload.

Arguments:
  argument_re     points to the compiled expression
  extra_data      points to extra data or is NULL
  tables          points to the character tables or NULL

Returns:          0 if the swap is successful, negative on error
*/ //
//
func pcre_pattern_to_host_byte_order(argument_re *pcre, extra_data *pcre_extra, tables *uint8) int32 {
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(argument_re))
	var study *pcre_study_data
	if re == nil {
		return (-int32(2))
	}
	if uint32((pcre_uint32((*re).magic_number))) == uint32(1346589253) {
		if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
			return (-int32(28))
		}
		(*re).tables = (*pcre_uint8)(unsafe.Pointer(tables))
		return int32(0)
	}
	if uint32((pcre_uint32((*re).magic_number))) != uint32(1163019088) {
		return (-int32(4))
	}
	if (swap_uint32(pcre_uint32((*re).flags)) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		return (-int32(28))
	}
	(*re).magic_number = pcre_uint32(1346589253)
	(*re).size = swap_uint32(pcre_uint32((*re).size))
	(*re).options = swap_uint32(pcre_uint32((*re).options))
	(*re).flags = swap_uint32(pcre_uint32((*re).flags))
	(*re).limit_match = swap_uint32(pcre_uint32((*re).limit_match))
	(*re).limit_recursion = swap_uint32(pcre_uint32((*re).limit_recursion))
	(*re).first_char = swap_uint16(pcre_uint16((*re).first_char))
	(*re).req_char = swap_uint16(pcre_uint16((*re).req_char))
	(*re).max_lookbehind = swap_uint16(pcre_uint16((*re).max_lookbehind))
	(*re).top_bracket = swap_uint16(pcre_uint16((*re).top_bracket))
	(*re).top_backref = swap_uint16(pcre_uint16((*re).top_backref))
	(*re).name_table_offset = swap_uint16(pcre_uint16((*re).name_table_offset))
	(*re).name_entry_size = swap_uint16(pcre_uint16((*re).name_entry_size))
	(*re).name_count = swap_uint16(pcre_uint16((*re).name_count))
	(*re).ref_count = swap_uint16(pcre_uint16((*re).ref_count))
	(*re).tables = (*pcre_uint8)(unsafe.Pointer(tables))
	if (extra_data != nil) && (((*extra_data).flags & uint32(int32(1))) != uint32(int32(0))) {
		study = (*pcre_study_data)((*extra_data).study_data)
		(*study).size = swap_uint32(pcre_uint32((*study).size))
		(*study).flags = swap_uint32(pcre_uint32((*study).flags))
		(*study).minlength = swap_uint32(pcre_uint32((*study).minlength))
	}
	return int32(0)
}

var _pcre_default_tables []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(3)), pcre_uint8(int32(4)), pcre_uint8(int32(5)), pcre_uint8(int32(6)), pcre_uint8(int32(7)), pcre_uint8(int32(8)), pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(11)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_uint8(int32(14)), pcre_uint8(int32(15)), pcre_uint8(int32(16)), pcre_uint8(int32(17)), pcre_uint8(int32(18)), pcre_uint8(int32(19)), pcre_uint8(int32(20)), pcre_uint8(int32(21)), pcre_uint8(int32(22)), pcre_uint8(int32(23)), pcre_uint8(int32(24)), pcre_uint8(int32(25)), pcre_uint8(int32(26)), pcre_uint8(int32(27)), pcre_uint8(int32(28)), pcre_uint8(int32(29)), pcre_uint8(int32(30)), pcre_uint8(int32(31)), pcre_uint8(int32(32)), pcre_uint8(int32(33)), pcre_uint8(int32(34)), pcre_uint8(int32(35)), pcre_uint8(int32(36)), pcre_uint8(int32(37)), pcre_uint8(int32(38)), pcre_uint8(int32(39)), pcre_uint8(int32(40)), pcre_uint8(int32(41)), pcre_uint8(int32(42)), pcre_uint8(int32(43)), pcre_uint8(int32(44)), pcre_uint8(int32(45)), pcre_uint8(int32(46)), pcre_uint8(int32(47)), pcre_uint8(int32(48)), pcre_uint8(int32(49)), pcre_uint8(int32(50)), pcre_uint8(int32(51)), pcre_uint8(int32(52)), pcre_uint8(int32(53)), pcre_uint8(int32(54)), pcre_uint8(int32(55)), pcre_uint8(int32(56)), pcre_uint8(int32(57)), pcre_uint8(int32(58)), pcre_uint8(int32(59)), pcre_uint8(int32(60)), pcre_uint8(int32(61)), pcre_uint8(int32(62)), pcre_uint8(int32(63)), pcre_uint8(int32(64)), pcre_uint8(int32(97)), pcre_uint8(int32(98)), pcre_uint8(int32(99)), pcre_uint8(int32(100)), pcre_uint8(int32(101)), pcre_uint8(int32(102)), pcre_uint8(int32(103)), pcre_uint8(int32(104)), pcre_uint8(int32(105)), pcre_uint8(int32(106)), pcre_uint8(int32(107)), pcre_uint8(int32(108)), pcre_uint8(int32(109)), pcre_uint8(int32(110)), pcre_uint8(int32(111)), pcre_uint8(int32(112)), pcre_uint8(int32(113)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(121)), pcre_uint8(int32(122)), pcre_uint8(int32(91)), pcre_uint8(int32(92)), pcre_uint8(int32(93)), pcre_uint8(int32(94)), pcre_uint8(int32(95)), pcre_uint8(int32(96)), pcre_uint8(int32(97)), pcre_uint8(int32(98)), pcre_uint8(int32(99)), pcre_uint8(int32(100)), pcre_uint8(int32(101)), pcre_uint8(int32(102)), pcre_uint8(int32(103)), pcre_uint8(int32(104)), pcre_uint8(int32(105)), pcre_uint8(int32(106)), pcre_uint8(int32(107)), pcre_uint8(int32(108)), pcre_uint8(int32(109)), pcre_uint8(int32(110)), pcre_uint8(int32(111)), pcre_uint8(int32(112)), pcre_uint8(int32(113)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(121)), pcre_uint8(int32(122)), pcre_uint8(int32(123)), pcre_uint8(int32(124)), pcre_uint8(int32(125)), pcre_uint8(int32(126)), pcre_uint8(int32(127)), pcre_uint8(int32(128)), pcre_uint8(int32(129)), pcre_uint8(int32(130)), pcre_uint8(int32(131)), pcre_uint8(int32(132)), pcre_uint8(int32(133)), pcre_uint8(int32(134)), pcre_uint8(int32(135)), pcre_uint8(int32(136)), pcre_uint8(int32(137)), pcre_uint8(int32(138)), pcre_uint8(int32(139)), pcre_uint8(int32(140)), pcre_uint8(int32(141)), pcre_uint8(int32(142)), pcre_uint8(int32(143)), pcre_uint8(int32(144)), pcre_uint8(int32(145)), pcre_uint8(int32(146)), pcre_uint8(int32(147)), pcre_uint8(int32(148)), pcre_uint8(int32(149)), pcre_uint8(int32(150)), pcre_uint8(int32(151)), pcre_uint8(int32(152)), pcre_uint8(int32(153)), pcre_uint8(int32(154)), pcre_uint8(int32(155)), pcre_uint8(int32(156)), pcre_uint8(int32(157)), pcre_uint8(int32(158)), pcre_uint8(int32(159)), pcre_uint8(int32(160)), pcre_uint8(int32(161)), pcre_uint8(int32(162)), pcre_uint8(int32(163)), pcre_uint8(int32(164)), pcre_uint8(int32(165)), pcre_uint8(int32(166)), pcre_uint8(int32(167)), pcre_uint8(int32(168)), pcre_uint8(int32(169)), pcre_uint8(int32(170)), pcre_uint8(int32(171)), pcre_uint8(int32(172)), pcre_uint8(int32(173)), pcre_uint8(int32(174)), pcre_uint8(int32(175)), pcre_uint8(int32(176)), pcre_uint8(int32(177)), pcre_uint8(int32(178)), pcre_uint8(int32(179)), pcre_uint8(int32(180)), pcre_uint8(int32(181)), pcre_uint8(int32(182)), pcre_uint8(int32(183)), pcre_uint8(int32(184)), pcre_uint8(int32(185)), pcre_uint8(int32(186)), pcre_uint8(int32(187)), pcre_uint8(int32(188)), pcre_uint8(int32(189)), pcre_uint8(int32(190)), pcre_uint8(int32(191)), pcre_uint8(int32(192)), pcre_uint8(int32(193)), pcre_uint8(int32(194)), pcre_uint8(int32(195)), pcre_uint8(int32(196)), pcre_uint8(int32(197)), pcre_uint8(int32(198)), pcre_uint8(int32(199)), pcre_uint8(int32(200)), pcre_uint8(int32(201)), pcre_uint8(int32(202)), pcre_uint8(int32(203)), pcre_uint8(int32(204)), pcre_uint8(int32(205)), pcre_uint8(int32(206)), pcre_uint8(int32(207)), pcre_uint8(int32(208)), pcre_uint8(int32(209)), pcre_uint8(int32(210)), pcre_uint8(int32(211)), pcre_uint8(int32(212)), pcre_uint8(int32(213)), pcre_uint8(int32(214)), pcre_uint8(int32(215)), pcre_uint8(int32(216)), pcre_uint8(int32(217)), pcre_uint8(int32(218)), pcre_uint8(int32(219)), pcre_uint8(int32(220)), pcre_uint8(int32(221)), pcre_uint8(int32(222)), pcre_uint8(int32(223)), pcre_uint8(int32(224)), pcre_uint8(int32(225)), pcre_uint8(int32(226)), pcre_uint8(int32(227)), pcre_uint8(int32(228)), pcre_uint8(int32(229)), pcre_uint8(int32(230)), pcre_uint8(int32(231)), pcre_uint8(int32(232)), pcre_uint8(int32(233)), pcre_uint8(int32(234)), pcre_uint8(int32(235)), pcre_uint8(int32(236)), pcre_uint8(int32(237)), pcre_uint8(int32(238)), pcre_uint8(int32(239)), pcre_uint8(int32(240)), pcre_uint8(int32(241)), pcre_uint8(int32(242)), pcre_uint8(int32(243)), pcre_uint8(int32(244)), pcre_uint8(int32(245)), pcre_uint8(int32(246)), pcre_uint8(int32(247)), pcre_uint8(int32(248)), pcre_uint8(int32(249)), pcre_uint8(int32(250)), pcre_uint8(int32(251)), pcre_uint8(int32(252)), pcre_uint8(int32(253)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(3)), pcre_uint8(int32(4)), pcre_uint8(int32(5)), pcre_uint8(int32(6)), pcre_uint8(int32(7)), pcre_uint8(int32(8)), pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(11)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_uint8(int32(14)), pcre_uint8(int32(15)), pcre_uint8(int32(16)), pcre_uint8(int32(17)), pcre_uint8(int32(18)), pcre_uint8(int32(19)), pcre_uint8(int32(20)), pcre_uint8(int32(21)), pcre_uint8(int32(22)), pcre_uint8(int32(23)), pcre_uint8(int32(24)), pcre_uint8(int32(25)), pcre_uint8(int32(26)), pcre_uint8(int32(27)), pcre_uint8(int32(28)), pcre_uint8(int32(29)), pcre_uint8(int32(30)), pcre_uint8(int32(31)), pcre_uint8(int32(32)), pcre_uint8(int32(33)), pcre_uint8(int32(34)), pcre_uint8(int32(35)), pcre_uint8(int32(36)), pcre_uint8(int32(37)), pcre_uint8(int32(38)), pcre_uint8(int32(39)), pcre_uint8(int32(40)), pcre_uint8(int32(41)), pcre_uint8(int32(42)), pcre_uint8(int32(43)), pcre_uint8(int32(44)), pcre_uint8(int32(45)), pcre_uint8(int32(46)), pcre_uint8(int32(47)), pcre_uint8(int32(48)), pcre_uint8(int32(49)), pcre_uint8(int32(50)), pcre_uint8(int32(51)), pcre_uint8(int32(52)), pcre_uint8(int32(53)), pcre_uint8(int32(54)), pcre_uint8(int32(55)), pcre_uint8(int32(56)), pcre_uint8(int32(57)), pcre_uint8(int32(58)), pcre_uint8(int32(59)), pcre_uint8(int32(60)), pcre_uint8(int32(61)), pcre_uint8(int32(62)), pcre_uint8(int32(63)), pcre_uint8(int32(64)), pcre_uint8(int32(97)), pcre_uint8(int32(98)), pcre_uint8(int32(99)), pcre_uint8(int32(100)), pcre_uint8(int32(101)), pcre_uint8(int32(102)), pcre_uint8(int32(103)), pcre_uint8(int32(104)), pcre_uint8(int32(105)), pcre_uint8(int32(106)), pcre_uint8(int32(107)), pcre_uint8(int32(108)), pcre_uint8(int32(109)), pcre_uint8(int32(110)), pcre_uint8(int32(111)), pcre_uint8(int32(112)), pcre_uint8(int32(113)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(121)), pcre_uint8(int32(122)), pcre_uint8(int32(91)), pcre_uint8(int32(92)), pcre_uint8(int32(93)), pcre_uint8(int32(94)), pcre_uint8(int32(95)), pcre_uint8(int32(96)), pcre_uint8(int32(65)), pcre_uint8(int32(66)), pcre_uint8(int32(67)), pcre_uint8(int32(68)), pcre_uint8(int32(69)), pcre_uint8(int32(70)), pcre_uint8(int32(71)), pcre_uint8(int32(72)), pcre_uint8(int32(73)), pcre_uint8(int32(74)), pcre_uint8(int32(75)), pcre_uint8(int32(76)), pcre_uint8(int32(77)), pcre_uint8(int32(78)), pcre_uint8(int32(79)), pcre_uint8(int32(80)), pcre_uint8(int32(81)), pcre_uint8(int32(82)), pcre_uint8(int32(83)), pcre_uint8(int32(84)), pcre_uint8(int32(85)), pcre_uint8(int32(86)), pcre_uint8(int32(87)), pcre_uint8(int32(88)), pcre_uint8(int32(89)), pcre_uint8(int32(90)), pcre_uint8(int32(123)), pcre_uint8(int32(124)), pcre_uint8(int32(125)), pcre_uint8(int32(126)), pcre_uint8(int32(127)), pcre_uint8(int32(128)), pcre_uint8(int32(129)), pcre_uint8(int32(130)), pcre_uint8(int32(131)), pcre_uint8(int32(132)), pcre_uint8(int32(133)), pcre_uint8(int32(134)), pcre_uint8(int32(135)), pcre_uint8(int32(136)), pcre_uint8(int32(137)), pcre_uint8(int32(138)), pcre_uint8(int32(139)), pcre_uint8(int32(140)), pcre_uint8(int32(141)), pcre_uint8(int32(142)), pcre_uint8(int32(143)), pcre_uint8(int32(144)), pcre_uint8(int32(145)), pcre_uint8(int32(146)), pcre_uint8(int32(147)), pcre_uint8(int32(148)), pcre_uint8(int32(149)), pcre_uint8(int32(150)), pcre_uint8(int32(151)), pcre_uint8(int32(152)), pcre_uint8(int32(153)), pcre_uint8(int32(154)), pcre_uint8(int32(155)), pcre_uint8(int32(156)), pcre_uint8(int32(157)), pcre_uint8(int32(158)), pcre_uint8(int32(159)), pcre_uint8(int32(160)), pcre_uint8(int32(161)), pcre_uint8(int32(162)), pcre_uint8(int32(163)), pcre_uint8(int32(164)), pcre_uint8(int32(165)), pcre_uint8(int32(166)), pcre_uint8(int32(167)), pcre_uint8(int32(168)), pcre_uint8(int32(169)), pcre_uint8(int32(170)), pcre_uint8(int32(171)), pcre_uint8(int32(172)), pcre_uint8(int32(173)), pcre_uint8(int32(174)), pcre_uint8(int32(175)), pcre_uint8(int32(176)), pcre_uint8(int32(177)), pcre_uint8(int32(178)), pcre_uint8(int32(179)), pcre_uint8(int32(180)), pcre_uint8(int32(181)), pcre_uint8(int32(182)), pcre_uint8(int32(183)), pcre_uint8(int32(184)), pcre_uint8(int32(185)), pcre_uint8(int32(186)), pcre_uint8(int32(187)), pcre_uint8(int32(188)), pcre_uint8(int32(189)), pcre_uint8(int32(190)), pcre_uint8(int32(191)), pcre_uint8(int32(192)), pcre_uint8(int32(193)), pcre_uint8(int32(194)), pcre_uint8(int32(195)), pcre_uint8(int32(196)), pcre_uint8(int32(197)), pcre_uint8(int32(198)), pcre_uint8(int32(199)), pcre_uint8(int32(200)), pcre_uint8(int32(201)), pcre_uint8(int32(202)), pcre_uint8(int32(203)), pcre_uint8(int32(204)), pcre_uint8(int32(205)), pcre_uint8(int32(206)), pcre_uint8(int32(207)), pcre_uint8(int32(208)), pcre_uint8(int32(209)), pcre_uint8(int32(210)), pcre_uint8(int32(211)), pcre_uint8(int32(212)), pcre_uint8(int32(213)), pcre_uint8(int32(214)), pcre_uint8(int32(215)), pcre_uint8(int32(216)), pcre_uint8(int32(217)), pcre_uint8(int32(218)), pcre_uint8(int32(219)), pcre_uint8(int32(220)), pcre_uint8(int32(221)), pcre_uint8(int32(222)), pcre_uint8(int32(223)), pcre_uint8(int32(224)), pcre_uint8(int32(225)), pcre_uint8(int32(226)), pcre_uint8(int32(227)), pcre_uint8(int32(228)), pcre_uint8(int32(229)), pcre_uint8(int32(230)), pcre_uint8(int32(231)), pcre_uint8(int32(232)), pcre_uint8(int32(233)), pcre_uint8(int32(234)), pcre_uint8(int32(235)), pcre_uint8(int32(236)), pcre_uint8(int32(237)), pcre_uint8(int32(238)), pcre_uint8(int32(239)), pcre_uint8(int32(240)), pcre_uint8(int32(241)), pcre_uint8(int32(242)), pcre_uint8(int32(243)), pcre_uint8(int32(244)), pcre_uint8(int32(245)), pcre_uint8(int32(246)), pcre_uint8(int32(247)), pcre_uint8(int32(248)), pcre_uint8(int32(249)), pcre_uint8(int32(250)), pcre_uint8(int32(251)), pcre_uint8(int32(252)), pcre_uint8(int32(253)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(0)), pcre_uint8(int32(62)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(255)), pcre_uint8(int32(3)), pcre_uint8(int32(126)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(126)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(255)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(7)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(7)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(255)), pcre_uint8(int32(3)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(135)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(7)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(127)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(127)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(254)), pcre_uint8(int32(255)), pcre_uint8(int32(0)), pcre_uint8(int32(252)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(248)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(120)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(255)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(28)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(128)), pcre_uint8(int32(16)), pcre_uint8(int32(0)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(18)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}
var escapes []int16 = []int16{int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(int32(0)), int16(':'), int16(';'), int16('<'), int16('='), int16('>'), int16('?'), int16('@'), int16(-ESC_A), int16(-ESC_B), int16(-ESC_C), int16(-ESC_D), int16(-ESC_E), int16(int32(0)), int16(-ESC_G), int16(-ESC_H), int16(int32(0)), int16(int32(0)), int16(-ESC_K), int16(int32(0)), int16(int32(0)), int16(-ESC_N), int16(int32(0)), int16(-ESC_P), int16(-ESC_Q), int16(-ESC_R), int16(-ESC_S), int16(int32(0)), int16(int32(0)), int16(-ESC_V), int16(-ESC_W), int16(-ESC_X), int16(int32(0)), int16(-ESC_Z), int16('['), int16('\\'), int16(']'), int16('^'), int16('_'), int16('`'), int16('\a'), int16(-ESC_b), int16(int32(0)), int16(-ESC_d), int16('\x1b'), int16('\f'), int16(int32(0)), int16(-ESC_h), int16(int32(0)), int16(int32(0)), int16(-ESC_k), int16(int32(0)), int16(int32(0)), int16('\n'), int16(int32(0)), int16(-ESC_p), int16(int32(0)), int16('\r'), int16(-ESC_s), int16('\t'), int16(int32(0)), int16(-ESC_v), int16(-ESC_w), int16(int32(0)), int16(int32(0)), int16(-ESC_z)}

type verbitem struct {
	len    int32
	op     int32
	op_arg int32
}

var // Warning: using unsafe slice cast to convert from []byte to []byte
verbnames []byte = *(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("\x00MARK\x00ACCEPT\x00COMMIT\x00F\x00FAIL\x00PRUNE\x00SKIP\x00THEN\x00"), 1, 1)))
var verbs []verbitem = []verbitem{verbitem{int32(0), -int32(1), OP_MARK}, verbitem{int32(4), -int32(1), OP_MARK}, verbitem{int32(6), OP_ACCEPT, -int32(1)}, verbitem{int32(6), OP_COMMIT, -int32(1)}, verbitem{int32(1), OP_FAIL, -int32(1)}, verbitem{int32(4), OP_FAIL, -int32(1)}, verbitem{int32(5), OP_PRUNE, OP_PRUNE_ARG}, verbitem{int32(4), OP_SKIP, OP_SKIP_ARG}, verbitem{int32(4), OP_THEN, OP_THEN_ARG}}
var verbcount int32 = int32((144 / 16))
var sub_start_of_word []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('b'), pcre_uchar('('), pcre_uchar('?'), pcre_uchar('='), pcre_uchar('\\'), pcre_uchar('w'), pcre_uchar(')'), pcre_uchar('\x00')}
var sub_end_of_word []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('b'), pcre_uchar('('), pcre_uchar('?'), pcre_uchar('<'), pcre_uchar('='), pcre_uchar('\\'), pcre_uchar('w'), pcre_uchar(')'), pcre_uchar('\x00')}
var posix_names []byte = *(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("alpha\x00lower\x00upper\x00alnum\x00ascii\x00blank\x00cntrl\x00digit\x00graph\x00print\x00punct\x00space\x00word\x00xdigit\x00"), 1, 1)))
var posix_name_lengths []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(4)), pcre_uint8(int32(6)), pcre_uint8(int32(0))}
var posix_class_maps []int32 = []int32{int32(160), int32(64), -int32(2), int32(128), -int32(1), int32(0), int32(96), -int32(1), int32(0), int32(160), -int32(1), int32(2), int32(224), int32(288), int32(0), int32(0), -int32(1), int32(1), int32(288), -int32(1), int32(0), int32(64), -int32(1), int32(0), int32(192), -int32(1), int32(0), int32(224), -int32(1), int32(0), int32(256), -int32(1), int32(0), int32(0), -int32(1), int32(0), int32(160), -int32(1), int32(0), int32(32), -int32(1), int32(0)}
var string_PNd []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('N'), pcre_uchar('d'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pNd []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('N'), pcre_uchar('d'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PXsp []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('s'), pcre_uchar('p'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pXsp []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('s'), pcre_uchar('p'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PXwd []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('w'), pcre_uchar('d'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pXwd []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('w'), pcre_uchar('d'), pcre_uchar('}'), pcre_uchar('\x00')}
var substitutes []*pcre_uchar = []*pcre_uchar{&string_PNd[0], &string_pNd[0], &string_PXsp[0], &string_pXsp[0], &string_PXwd[0], &string_pXwd[0]}
var string_pL []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pLl []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('l'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pLu []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('u'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_pXan []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('a'), pcre_uchar('n'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_h []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('h'), pcre_uchar('\x00')}
var string_pXps []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('p'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('p'), pcre_uchar('s'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PL []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PLl []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('l'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PLu []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('L'), pcre_uchar('u'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_PXan []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('a'), pcre_uchar('n'), pcre_uchar('}'), pcre_uchar('\x00')}
var string_H []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('H'), pcre_uchar('\x00')}
var string_PXps []pcre_uchar = []pcre_uchar{pcre_uchar('\\'), pcre_uchar('P'), pcre_uchar('{'), pcre_uchar('X'), pcre_uchar('p'), pcre_uchar('s'), pcre_uchar('}'), pcre_uchar('\x00')}
var posix_substitutes []*pcre_uchar = []*pcre_uchar{&string_pL[0], &string_pLl[0], &string_pLu[0], &string_pXan[0], nil, &string_h[0], nil, &string_pNd[0], nil, nil, nil, &string_pXps[0], &string_pXwd[0], nil, &string_PL[0], &string_PLl[0], &string_PLu[0], &string_PXan[0], nil, &string_H[0], nil, &string_PNd[0], nil, nil, nil, &string_PXps[0], &string_PXwd[0], nil}
var error_texts []byte = *(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("no error\x00\\ at end of pattern\x00\\c at end of pattern\x00unrecognized character follows \\\x00numbers out of order in {} quantifier\x00number too big in {} quantifier\x00missing terminating ] for character class\x00invalid escape sequence in character class\x00range out of order in character class\x00nothing to repeat\x00internal error: invalid forward reference offset\x00internal error: unexpected repeat\x00unrecognized character after (? or (?-\x00POSIX named classes are supported only within a class\x00missing )\x00reference to non-existent subpattern\x00erroffset passed as NULL\x00unknown option bit(s) set\x00missing ) after comment\x00parentheses nested too deeply\x00regular expression is too large\x00failed to get memory\x00unmatched parentheses\x00internal error: code overflow\x00unrecognized character after (?<\x00lookbehind assertion is not fixed length\x00malformed number or name after (?(\x00conditional group contains more than two branches\x00assertion expected after (?( or (?(?C)\x00(?R or (?[+-]digits must be followed by )\x00unknown POSIX class name\x00POSIX collating elements are not supported\x00this version of PCRE is compiled without UTF support\x00spare error\x00character value in \\x{} or \\o{} is too large\x00invalid condition (?(0)\x00\\C not allowed in lookbehind assertion\x00PCRE does not support \\L, \\l, \\N{name}, \\U, or \\u\x00number after (?C is > 255\x00closing ) for (?C expected\x00recursive call could loop indefinitely\x00unrecognized character after (?P\x00syntax error in subpattern name (missing terminator)\x00two named subpatterns have the same name\x00invalid UTF-8 string\x00support for \\P, \\p, and \\X has not been compiled\x00malformed \\P or \\p sequence\x00unknown property name after \\P or \\p\x00subpattern name is too long (maximum 32 characters)\x00too many named subpatterns (maximum 10000)\x00repeated subpattern is too long\x00octal value is greater than \\377 in 8-bit non-UTF-8 mode\x00internal error: overran compiling workspace\x00internal error: previously-checked referenced subpattern not found\x00DEFINE group contains more than one branch\x00repeating a DEFINE group is not allowed\x00inconsistent NEWLINE options\x00\\g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number\x00a numbered reference must not be zero\x00an argument is not allowed for (*ACCEPT), (*FAIL), or (*COMMIT)\x00(*VERB) not recognized or malformed\x00number is too big\x00subpattern name expected\x00digit expected after (?+\x00] is an invalid data character in JavaScript compatibility mode\x00different names for subpatterns of the same number are not allowed\x00(*MARK) must have an argument\x00this version of PCRE is not compiled with Unicode property support\x00\\c must be followed by an ASCII character\x00\\k is not followed by a braced, angle-bracketed, or quoted name\x00internal error: unknown opcode in find_fixedlength()\x00\\N is not supported in a class\x00too many forward references\x00disallowed Unicode code point (>= 0xd800 && <= 0xdfff)\x00invalid UTF-16 string\x00name is too long in (*MARK), (*PRUNE), (*SKIP), or (*THEN)\x00character value in \\u.... sequence is too large\x00invalid UTF-32 string\x00setting UTF is disabled by the application\x00non-hex character in \\x{} (closing brace missing?)\x00non-octal character in \\o{} (closing brace missing?)\x00missing opening brace after \\o\x00parentheses are too deeply nested\x00invalid range in character class\x00group name must start with a non-digit\x00parentheses are too deeply nested (stack check)\x00digits missing in \\x{} or \\o{}\x00regular expression is too complicated\x00\x00"), 1, 1)))
var digitab []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(8)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}
var autoposstab [][]pcre_uint8 = [][]pcre_uint8{[]pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}}
var propposstab [][]pcre_uint8 = [][]pcre_uint8{[]pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(2)), pcre_uint8(int32(4)), pcre_uint8(int32(0)), pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(10)), pcre_uint8(int32(11)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(5)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_uint8(int32(15)), pcre_uint8(int32(16)), pcre_uint8(int32(16)), pcre_uint8(int32(17)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(3)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(7)), pcre_uint8(int32(13)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(7)), pcre_uint8(int32(13)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(8)), pcre_uint8(int32(14)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}, []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(3))}}
var catposstab [][]pcre_uint8 = [][]pcre_uint8{[]pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}, []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}}
var posspropstab [][]pcre_uint8 = [][]pcre_uint8{[]pcre_uint8{pcre_uint8(ucp_L), pcre_uint8(ucp_N), pcre_uint8(ucp_N), pcre_uint8(ucp_Nl)}, []pcre_uint8{pcre_uint8(ucp_Z), pcre_uint8(ucp_Z), pcre_uint8(ucp_C), pcre_uint8(ucp_Cc)}, []pcre_uint8{pcre_uint8(ucp_L), pcre_uint8(ucp_N), pcre_uint8(ucp_P), pcre_uint8(ucp_Po)}}
var opcode_possessify []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_POSSTAR), pcre_uint8(int32(0)), pcre_uint8(OP_POSPLUS), pcre_uint8(int32(0)), pcre_uint8(OP_POSQUERY), pcre_uint8(int32(0)), pcre_uint8(OP_POSUPTO), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_POSSTARI), pcre_uint8(int32(0)), pcre_uint8(OP_POSPLUSI), pcre_uint8(int32(0)), pcre_uint8(OP_POSQUERYI), pcre_uint8(int32(0)), pcre_uint8(OP_POSUPTOI), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSSTAR), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSPLUS), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSQUERY), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSUPTO), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSSTARI), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSPLUSI), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSQUERYI), pcre_uint8(int32(0)), pcre_uint8(OP_NOTPOSUPTOI), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_TYPEPOSSTAR), pcre_uint8(int32(0)), pcre_uint8(OP_TYPEPOSPLUS), pcre_uint8(int32(0)), pcre_uint8(OP_TYPEPOSQUERY), pcre_uint8(int32(0)), pcre_uint8(OP_TYPEPOSUPTO), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(OP_CRPOSSTAR), pcre_uint8(int32(0)), pcre_uint8(OP_CRPOSPLUS), pcre_uint8(int32(0)), pcre_uint8(OP_CRPOSQUERY), pcre_uint8(int32(0)), pcre_uint8(OP_CRPOSRANGE), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}

// find_error_text - transpiled function from  /root/Documents/pcre/pcre_compile.c:894
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2016 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_compile(), along with
supporting internal functions that are not used by other modules. */ //
/* When PCRE_DEBUG is defined, we need the pcre(16|32)_printint() function, which
is also used by pcretest. PCRE_DEBUG is not defined when building a production
library. We do not need to select pcre16_printint.c specially, because the
COMPILE_PCREx macro will already be appropriately set. */ //
/* Macro for setting individual bits in class bitmaps. */ //
/* Maximum length value to check against when making sure that the integer that
holds the compiled pattern length does not overflow. We make it a bit less than
INT_MAX to allow for adding in group terminating bytes, so that we don't have
to check them every time. */ //
/* Definitions to allow mutual recursion */ //
/*************************************************
*      Code parameters and static tables         *
*************************************************/ //
/* This value specifies the size of stack workspace that is used during the
first pre-compile phase that determines how much memory is required. The regex
is partly compiled into this space, but the compiled parts are discarded as
soon as they can be, so that hopefully there will never be an overrun. The code
does, however, check for an overrun. The largest amount I've seen used is 218,
so this number is very generous.

The same workspace is used during the second, actual compile phase for
remembering forward references to groups so that they can be filled in at the
end. Each entry in this list occupies LINK_SIZE bytes, so even when LINK_SIZE
is 4 there is plenty of room for most patterns. However, the memory can get
filled up by repetitions of forward references, for example patterns like
/(?1){0,1999}(b)/, and one user did hit the limit. The code has been changed so
that the workspace is expanded using malloc() in this situation. The value
below is therefore a minimum, and we put a maximum on it for safety. The
minimum is now also defined in terms of LINK_SIZE so that the use of malloc()
kicks in at the same number of forward references in all cases. */ //
/* This value determines the size of the initial vector that is used for
remembering named groups during the pre-compile. It is allocated on the stack,
but if it is too small, it is expanded using malloc(), in a similar way to the
workspace. The value is the number of slots in the list. */ //
/* The overrun tests check for a slightly smaller size so that they detect the
overrun before it actually does run off the end of the data block. */ //
/* Private flags added to firstchar and reqchar. */ //
/* Negative values for the firstchar and reqchar flags */ //
/* Repeated character flags. */ //
/* Table for handling escaped characters in the range '0'-'z'. Positive returns
are simple data values; negative values are for special things like \d and so
on. Zero means further processing is needed (for things like \x), or the escape
is invalid. */ //
/* This is the "normal" table for ASCII systems or for EBCDIC systems running
in UTF-8 mode. */ //
/* Table of special "verbs" like (*PRUNE). This is a short table, so it is
searched linearly. Put all the names into a single string, in order to reduce
the number of relocations when a shared library is dynamically linked. The
string is built from string macros so that it works in UTF-8 mode on EBCDIC
platforms. */ //
/* Length of verb name */ //
/* Op when no arg, or -1 if arg mandatory */ //
/* Op when arg present, or -1 if not allowed */ //
/* Empty name is a shorthand for MARK */ //
/* Substitutes for [[:<:]] and [[:>:]], which mean start and end of word in
another regex library. */ //
/* Tables of names of POSIX character classes and their lengths. The names are
now all in a single string, to reduce the number of relocations when a shared
library is dynamically loaded. The list of lengths is terminated by a zero
length entry. The first three must be alpha, lower, upper, as this is assumed
for handling case independence. The indices for graph, print, and punct are
needed, so identify them. */ //
/* Table of class bit maps for each POSIX class. Each class is formed from a
base map, with an optional addition or removal of another map. Then, for some
classes, there is some additional tweaking: for [:blank:] the vertical space
characters are removed, and for [:alpha:] and [:alnum:] the underscore
character is removed. The triples in the table consist of the base map offset,
second map offset or -1 if no second map, and a non-negative value for map
addition or a negative value for map subtraction (if there are two maps). The
absolute value of the third field has these meanings: 0 => no tweaking, 1 =>
remove vertical space characters, 2 => remove underscore. */ //
/* alpha */ //
/* lower */ //
/* upper */ //
/* alnum - word without underscore */ //
/* ascii */ //
/* blank - a GNU extension */ //
/* cntrl */ //
/* digit */ //
/* graph */ //
/* print */ //
/* punct */ //
/* space */ //
/* word - a Perl extension */ //
/* xdigit */ //
/* Table of substitutes for \d etc when PCRE_UCP is set. They are replaced by
Unicode property escapes. */ //
/* \D */ //
/* \d */ //
/* \S */ //
/* Xsp is Perl space, but from 8.34, Perl */ //
/* \s */ //
/* space and POSIX space are the same. */ //
/* \W */ //
/* \w */ //
/* The POSIX class substitutes must be in the order of the POSIX class names,
defined above, and there are both positive and negative cases. NULL means no
general substitute of a Unicode property escape (\p or \P). However, for some
POSIX classes (e.g. graph, print, punct) a special property code is compiled
directly. */ //
/* alpha */ //
/* lower */ //
/* upper */ //
/* alnum */ //
/* ascii */ //
/* blank */ //
/* cntrl */ //
/* digit */ //
/* graph */ //
/* print */ //
/* punct */ //
/* space */ //
/* Xps is POSIX space, but from 8.34 */ //
/* word  */ //
/* Perl and POSIX space are the same */ //
/* xdigit */ //
/* Negated cases */ //
/* ^alpha */ //
/* ^lower */ //
/* ^upper */ //
/* ^alnum */ //
/* ^ascii */ //
/* ^blank */ //
/* ^cntrl */ //
/* ^digit */ //
/* ^graph */ //
/* ^print */ //
/* ^punct */ //
/* ^space */ //
/* Xps is POSIX space, but from 8.34 */ //
/* ^word */ //
/* Perl and POSIX space are the same */ //
/* ^xdigit */ //
/* The texts of compile-time error messages. These are "char *" because they
are passed to the outside world. Do not ever re-use any error number, because
they are documented. Always add a new error instead. Messages marked DEAD below
are no longer used. This used to be a table of strings, but in order to reduce
the number of relocations needed when a shared library is loaded dynamically,
it is now one long string. We cannot use a table of offsets, because the
lengths of inserts such as XSTRING(MAX_NAME_SIZE) are not known. Instead, we
simply count through to the one we want - this isn't a performance issue
because these strings are used only when there is a compilation error.

Each substring ends with \0 to insert a null character. This includes the final
substring, so that the whole string ends with \0\0, which can be detected when
counting through. */ //
/* 5 */ //
/* 10 */ //
/* 15 */ //
/** DEAD **/ //
/* 20 */ //
/* 25 */ //
/* 30 */ //
/** DEAD **/ //
/* 35 */ //
/* 40 */ //
/* 45 */ //
/* 50 */ //
/** DEAD **/ //
/* 55 */ //
/** DEAD **/ //
/* 60 */ //
/* 65 */ //
/* 70 */ //
/* 75 */ //
/* 80 */ //
/* 85 */ //
/* Table to identify digits and hex digits. This is used when compiling
patterns. Note that the tables in chartables are dependent on the locale, and
may mark arbitrary characters as digits - but the PCRE compiling code expects
to handle only 0-9, a-z, and A-Z as digits when compiling. That is why we have
a private table here. It costs 256 bytes, but it is a lot faster than doing
character value tests (at least in some simple cases I timed), and in some
applications one wants PCRE to compile efficiently as well as match
efficiently.

For convenience, we use the same bit definitions as in chartables:

  0x04   decimal digit
  0x08   hexadecimal digit

Then we can use ctype_digit and ctype_xdigit in the code. */ //
/* Using a simple comparison for decimal numbers rather than a memory read
is much faster, and the resulting code is simpler (the compiler turns it
into a subtraction and unsigned comparison). */ //
/* This is the "normal" case, for ASCII systems, and EBCDIC systems running in
UTF-8 mode. */ //
/*   0-  7 */ //
/*   8- 15 */ //
/*  16- 23 */ //
/*  24- 31 */ //
/*    - '  */ //
/*  ( - /  */ //
/*  0 - 7  */ //
/*  8 - ?  */ //
/*  @ - G  */ //
/*  H - O  */ //
/*  P - W  */ //
/*  X - _  */ //
/*  ` - g  */ //
/*  h - o  */ //
/*  p - w  */ //
/*  x -127 */ //
/* 128-135 */ //
/* 136-143 */ //
/* 144-151 */ //
/* 152-159 */ //
/* 160-167 */ //
/* 168-175 */ //
/* 176-183 */ //
/* 184-191 */ //
/* 192-199 */ //
/* 200-207 */ //
/* 208-215 */ //
/* 216-223 */ //
/* 224-231 */ //
/* 232-239 */ //
/* 240-247 */ //
/* 248-255 */ //
/* This table is used to check whether auto-possessification is possible
between adjacent character-type opcodes. The left-hand (repeated) opcode is
used to select the row, and the right-hand opcode is use to select the column.
A value of 1 means that auto-possessification is OK. For example, the second
value in the first row means that \D+\d can be turned into \D++\d.

The Unicode property types (\P and \p) have to be present to fill out the table
because of what their opcode values are, but the table values should always be
zero because property types are handled separately in the code. The last four
columns apply to items that cannot be repeated, so there is no need to have
rows for them. Note that OP_DIGIT etc. are generated only when PCRE_UCP is
*not* set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes. */ //
/* \D \d \S \s \W \w  . .+ \C \P \p \R \H \h \V \v \X \Z \z  $ $M */ //
/* \D */ //
/* \d */ //
/* \S */ //
/* \s */ //
/* \W */ //
/* \w */ //
/* .  */ //
/* .+ */ //
/* \C */ //
/* \P */ //
/* \p */ //
/* \R */ //
/* \H */ //
/* \h */ //
/* \V */ //
/* \v */ //
/* \X */ //
/* This table is used to check whether auto-possessification is possible
between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP). The
left-hand (repeated) opcode is used to select the row, and the right-hand
opcode is used to select the column. The values are as follows:

  0   Always return FALSE (never auto-possessify)
  1   Character groups are distinct (possessify if both are OP_PROP)
  2   Check character categories in the same group (general or particular)
  3   TRUE if the two opcodes are not the same (PROP vs NOTPROP)

  4   Check left general category vs right particular category
  5   Check right general category vs left particular category

  6   Left alphanum vs right general category
  7   Left space vs right general category
  8   Left word vs right general category

  9   Right alphanum vs left general category
 10   Right space vs left general category
 11   Right word vs left general category

 12   Left alphanum vs right particular category
 13   Left space vs right particular category
 14   Left word vs right particular category

 15   Right alphanum vs left particular category
 16   Right space vs left particular category
 17   Right word vs left particular category
*/ //
/* ANY LAMP GC  PC  SC ALNUM SPACE PXSPACE WORD CLIST UCNC */ //
/* PT_ANY */ //
/* PT_LAMP */ //
/* PT_GC */ //
/* PT_PC */ //
/* PT_SC */ //
/* PT_ALNUM */ //
/* PT_SPACE */ //
/* PT_PXSPACE */ //
/* PT_WORD */ //
/* PT_CLIST */ //
/* PT_UCNC */ //
/* This table is used to check whether auto-possessification is possible
between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP) when one
specifies a general category and the other specifies a particular category. The
row is selected by the general category and the column by the particular
category. The value is 1 if the particular category is not part of the general
category. */ //
/* Cc Cf Cn Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs */ //
/* C */ //
/* L */ //
/* M */ //
/* N */ //
/* P */ //
/* S */ //
/* Z */ //
/* This table is used when checking ALNUM, (PX)SPACE, SPACE, and WORD against
a general or particular category. The properties in each row are those
that apply to the character set in question. Duplication means that a little
unnecessary work is done when checking, but this keeps things much simpler
because they can all use the same code. For more details see the comment where
this table is used.

Note: SPACE and PXSPACE used to be different because Perl excluded VT from
"space", but from Perl 5.18 it's included, so both categories are treated the
same here. */ //
/* ALNUM, 3rd and 4th values redundant */ //
/* SPACE and PXSPACE, 2nd value redundant */ //
/* WORD */ //
/* This table is used when converting repeating opcodes into possessified
versions as a result of an explicit possessive quantifier such as ++. A zero
value means there is no possessified version - in those cases the item in
question must be wrapped in ONCE brackets. The table is truncated at OP_CALLOUT
because all relevant opcodes are less than that. */ //
/* 0 - 15  */ //
/* 16 - 31 */ //
/* NOTI */ //
/* STAR, MINSTAR */ //
/* PLUS, MINPLUS */ //
/* QUERY, MINQUERY */ //
/* UPTO, MINUPTO */ //
/* EXACT */ //
/* POS{STAR,PLUS,QUERY,UPTO} */ //
/* STARI, MINSTARI */ //
/* PLUSI, MINPLUSI */ //
/* QUERYI, MINQUERYI */ //
/* UPTOI, MINUPTOI */ //
/* EXACTI */ //
/* POS{STARI,PLUSI,QUERYI,UPTOI} */ //
/* NOTSTAR, NOTMINSTAR */ //
/* NOTPLUS, NOTMINPLUS */ //
/* NOTQUERY, NOTMINQUERY */ //
/* NOTUPTO, NOTMINUPTO */ //
/* NOTEXACT */ //
/* NOTPOS{STAR,PLUS,QUERY,UPTO} */ //
/* NOTSTARI, NOTMINSTARI */ //
/* NOTPLUSI, NOTMINPLUSI */ //
/* NOTQUERYI, NOTMINQUERYI */ //
/* NOTUPTOI, NOTMINUPTOI */ //
/* NOTEXACTI */ //
/* NOTPOS{STARI,PLUSI,QUERYI,UPTOI} */ //
/* TYPESTAR, TYPEMINSTAR */ //
/* TYPEPLUS, TYPEMINPLUS */ //
/* TYPEQUERY, TYPEMINQUERY */ //
/* TYPEUPTO, TYPEMINUPTO */ //
/* TYPEEXACT */ //
/* TYPEPOS{STAR,PLUS,QUERY,UPTO} */ //
/* CRSTAR, CRMINSTAR */ //
/* CRPLUS, CRMINPLUS */ //
/* CRQUERY, CRMINQUERY */ //
/* CRRANGE, CRMINRANGE */ //
/* CRPOS{STAR,PLUS,QUERY,RANGE} */ //
/* CLASS, NCLASS, XCLASS */ //
/* REF, REFI */ //
/* DNREF, DNREFI */ //
/* RECURSE, CALLOUT */ //
/*************************************************
*            Find an error text                  *
*************************************************/ //
/* The error texts are now all in one long string, to save on relocations. As
some of the text is of unknown length, we can't use a table of offsets.
Instead, just count through the strings. This is not a performance issue
because it happens only when there has been a compilation error.

Argument:   the error number
Returns:    pointer to the error string
*/ //
//
func find_error_text(n int32) *byte {
	var s *byte = &error_texts[0]
	for ; n > int32(0); n-- {
		for int32(*func() *byte {
			defer func() {
				s = ((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(s)) + (uintptr)(1)*unsafe.Sizeof(*s))))
			}()
			return s
		}()) != int32('\x00') {
		}
		if int32(*s) == int32('\x00') {
			return (&[]byte("Error text not found (please report)\x00")[0])
		}
	}
	return s
}

// expand_workspace - transpiled function from  /root/Documents/pcre/pcre_compile.c:921
/*************************************************
*           Expand the workspace                 *
*************************************************/ //
/* This function is called during the second compiling phase, if the number of
forward references fills the existing workspace, which is originally a block on
the stack. A larger block is obtained from malloc() unless the ultimate limit
has been reached or the increase will be rather small.

Argument: pointer to the compile data block
Returns:  0 if all went well, else an error number
*/ //
//
func expand_workspace(cd *compile_data) int32 {
	var newspace *pcre_uchar
	var newsize int32 = ((*cd).workspace_size * int32(2))
	if newsize > (int32(100) * (int32(2048) * int32(2))) {
		newsize = (int32(100) * (int32(2048) * int32(2)))
	}
	if ((*cd).workspace_size >= (int32(100) * (int32(2048) * int32(2)))) || ((newsize - (*cd).workspace_size) < int32(100)) {
		return ERR72
	}
	newspace = (*pcre_uchar)(pcre_malloc(size_t((newsize))))
	if newspace == nil {
		return ERR21
	}
	noarch.Memcpy(unsafe.Pointer(newspace), unsafe.Pointer((*cd).start_workspace), int32((uint32((*cd).workspace_size) * 1)))
	(*cd).hwm = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(newspace)) + (uintptr)(int32((int64(uintptr(unsafe.Pointer((*cd).hwm)))-int64(uintptr(unsafe.Pointer((*cd).start_workspace))))))*unsafe.Sizeof(*newspace))))
	if (*cd).workspace_size > (int32(2048) * int32(2)) {
		pcre_free(unsafe.Pointer((*cd).start_workspace))
	}
	(*cd).start_workspace = newspace
	(*cd).workspace_size = newsize
	return int32(0)
}

// is_counted_repeat - transpiled function from  /root/Documents/pcre/pcre_compile.c:960
/*************************************************
*            Check for counted repeat            *
*************************************************/ //
/* This function is called when a '{' is encountered in a place where it might
start a quantifier. It looks ahead to see if it really is a quantifier or not.
It is only a quantifier if it is one of the forms {ddd} {ddd,} or {ddd,ddd}
where the ddds are digits.

Arguments:
  p         pointer to the first char after '{'

Returns:    TRUE or FALSE
*/ //
//
func is_counted_repeat(p *pcre_uchar) BOOL {
	if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')))])) != 0 {
		return BOOL((int32(0)))
	}
	p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
	for (int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')) {
		p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
	}
	if int32(uint8((*p))) == int32('}') {
		return BOOL((int32(1)))
	}
	if int32(uint8((*func() *pcre_uchar {
		defer func() {
			p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
		}()
		return p
	}()))) != int32(',') {
		return BOOL((int32(0)))
	}
	if int32(uint8((*p))) == int32('}') {
		return BOOL((int32(1)))
	}
	if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')))])) != 0 {
		return BOOL((int32(0)))
	}
	p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
	for (int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')) {
		p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
	}
	return BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*p))) == int32('}'))]))
}

// check_escape - transpiled function from  /root/Documents/pcre/pcre_compile.c:1005
/*************************************************
*            Handle escapes                      *
*************************************************/ //
/* This function is called when a \ has been encountered. It either returns a
positive value for a simple escape such as \n, or 0 for a data character which
will be placed in chptr. A backreference to group n is returned as negative n.
When UTF-8 is enabled, a positive value greater than 255 may be returned in
chptr. On entry, ptr is pointing at the \. On exit, it is on the final
character of the escape sequence.

Arguments:
  ptrptr         points to the pattern position pointer
  chptr          points to a returned data character
  errorcodeptr   points to the errorcode variable
  bracount       number of previous extracting brackets
  options        the options bits
  isclass        TRUE if inside a character class

Returns:         zero => a data character
                 positive => a special escape sequence
                 negative => a back reference
                 on error, errorcodeptr is set
*/ //
/* PCRE_UTF16 has the same value as PCRE_UTF8. */ //
/* Get character value, increment pointer */ //
/* Set pointer back to the last byte */ //
/* If backslash is at the end of the pattern, it's an error. */ //
/* Non-alphanumerics are literals. For digits or letters, do an initial lookup
in a table. A non-zero result is something that can be returned immediately.
Otherwise further processing may be required. */ //
/* Not alphanumeric */ //
/* Escapes that need further processing, or are illegal. */ //
/* A number of Perl escapes are not handled by PCRE. We give an explicit
   error. */ //
/* In JavaScript, \u must be followed by four hexadecimal numbers.
   Otherwise it is a lowercase u letter. */ //
/* Convert to upper case */ //
/* In JavaScript, \U is an uppercase U letter. */ //
/* In a character class, \g is just a literal "g". Outside a character
   class, \g must be followed by one of a number of specific things:

   (1) A number, either plain or braced. If positive, it is an absolute
   backreference. If negative, it is a relative backreference. This is a Perl
   5.10 feature.

   (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
   is part of Perl's movement towards a unified syntax for back references. As
   this is synonymous with \k{name}, we fudge it up by pretending it really
   was \k.

   (3) For Oniguruma compatibility we also support \g followed by a name or a
   number either in angle brackets or in single quotes. However, these are
   (possibly recursive) subroutine calls, _not_ backreferences. Just return
   the ESC_g code (cf \k). */ //
/* Handle the Perl-compatible cases */ //
/* The integer range is limited by the machine's int representation. */ //
/* Integer overflow */ //
/* Integer overflow */ //
/* The handling of escape sequences consisting of a string of digits
   starting with one that is not zero is not straightforward. Perl has changed
   over the years. Nowadays \g{} for backreferences and \o{} for octal are
   recommended to avoid the ambiguities in the old syntax.

   Outside a character class, the digits are read as a decimal number. If the
   number is less than 8 (used to be 10), or if there are that many previous
   extracting left brackets, then it is a back reference. Otherwise, up to
   three octal digits are read to form an escaped byte. Thus \123 is likely to
   be octal 123 (cf \0123, which is octal 012 followed by the literal 3). If
   the octal value is greater than 377, the least significant 8 bits are
   taken. \8 and \9 are treated as the literal characters 8 and 9.

   Inside a character class, \ followed by a digit is always either a literal
   8 or 9 or an octal number. */ //
/* The integer range is limited by the machine's int representation. */ //
/* Integer overflow */ //
/* Integer overflow */ //
/* Check for back reference */ //
/* Put the pointer back and fall through */ //
/* Handle a digit following \ when the number is not a back reference. If
   the first digit is 8 or 9, Perl used to generate a binary zero byte and
   then treat the digit as a following literal. At least by Perl 5.18 this
   changed so as not to insert the binary zero. */ //
/* Fall through with a digit less than 8 */ //
/* \0 always starts an octal number, but we may drop through to here with a
   larger first octal digit. The original code used just to take the least
   significant 8 bits of octal numbers (I think this is what early Perls used
   to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
   but no more than 3 octal digits. */ //
/* \o is a relatively new Perl feature, supporting a more general way of
   specifying character codes in octal. The only supported form is \o{ddd}. */ //
/* Leading zeroes */ //
/* \x is complicated. In JavaScript, \x must be followed by two hexadecimal
   numbers. Otherwise it is a lowercase x letter. */ //
/* Convert to upper case */ //
/* End JavaScript handling */ //
/* Handle \x in Perl's style. \x{ddd} is a character number which can be
   greater than 0xff in utf or non-8bit mode, but only if the ddd are hex
   digits. If not, { used to be treated as a data character. However, Perl
   seems to read hex digits up to the first non-such, and ignore the rest, so
   that, for example \x{zz} matches a binary zero. This seems crazy, so PCRE
   now gives an error. */ //
/* Leading zeroes */ //
/* Convert to upper case */ //
/* If the sequence of hex digits does not end with '}', give an error.
   We used just to recognize this construct and fall through to the normal
   \x handling, but nowadays Perl gives an error, which seems much more
   sensible, so we do too. */ //
/* End of \x{} processing */ //
/* Read a single-byte hex-defined char (up to two hex digits after \x) */ //
/* Some compilers don't like */ //
/* ++ in initializers */ //
/* Convert to upper case */ //
/* End of \xdd handling */ //
/* End of Perl-style \x handling */ //
/* For \c, a following letter is upper-cased; then the 0x40 bit is flipped.
   An error is given if the byte following \c is not an ASCII character. This
   coding is ASCII-specific, but then the whole concept of \cx is
   ASCII-specific. (However, an EBCDIC equivalent has now been added.) */ //
/* Excludes all non-ASCII in either mode */ //
/* PCRE_EXTRA enables extensions to Perl in the matter of escapes. Any
   other alphanumeric following \ is an error if PCRE_EXTRA was set;
   otherwise, for Perl compatibility, it is a literal. This code looks a bit
   odd, but there used to be some cases other than the default, and there may
   be again in future, so I haven't "optimized" it. */ //
/* Perl supports \N{name} for character names, as well as plain \N for "not
newline". PCRE does not support \N{name}. However, it does support
quantification such as \N{2,3}. */ //
/* If PCRE_UCP is set, we change the values for \d etc. */ //
/* Set the pointer to the final character before returning. */ //
//
func check_escape(ptrptr **pcre_uchar, chptr *pcre_uint32, errorcodeptr *int32, bracount int32, options int32, isclass BOOL) int32 {
	var utf BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))]))
	var ptr *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := *ptrptr
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
	}()))
	var c pcre_uint32
	var escape int32 = int32(0)
	var i int32
	c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
		defer func() {
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
		}()
		return ptr
	}())))))
	if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
		if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
			c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
				defer func() {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}()
				return ptr
			}()))) & int32(63))))))
		} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
			c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*ptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
		} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
			c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*ptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))
		} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
			c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*ptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))
		} else {
			c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*ptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))
		}
	}
	ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))
	if c == pcre_uint32((uint32('\x00'))) {
		*errorcodeptr = ERR1
	} else if (c < pcre_uint32((uint32('0')))) || (c > pcre_uint32((uint32('z')))) {
	} else if (func() int32 {
		tempVar := int32(*((*int16)(func() unsafe.Pointer {
			tempVar := &escapes[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c-pcre_uint32((uint32('0')))))))*unsafe.Sizeof(*tempVar))
		}())))
		i = tempVar
		return tempVar
	}()) != int32(0) {
		if i > int32(0) {
			c = pcre_uint32(i)
		} else {
			escape = -i
		}
	} else {
		var oldptr *pcre_uchar
		var braced BOOL
		var negated BOOL
		var overflow BOOL
		var s int32
		switch pcre_uint32(c) {
		case pcre_uint32('l'):
			fallthrough
		case pcre_uint32('L'):
			{
				*errorcodeptr = ERR37
			}
		case pcre_uint32('u'):
			{
				if (options & int32(33554432)) != int32(0) {
					if (((((((int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0))) && (int32(1) != 0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0))) && (int32(1) != 0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0))) && (int32(1) != 0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0)) {
						c = pcre_uint32(int32(0))
						for i = int32(0); i < int32(4); i++ {
							var cc pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								return ptr
							}())))))
							if cc >= pcre_uint32((uint32('a'))) {
								cc -= pcre_uint32((uint32(int32(32))))
							}
							c = (((c << uint64(int32(4))) + cc) - pcre_uint32((uint32(func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(cc < pcre_uint32((uint32('A'))))]) != 0 {
									return int32('0')
								} else {
									return (int32(('A' - byte(int32(10)))))
								}
							}()))))
						}
						if c > pcre_uint32((func() uint32 {
							if int32((BOOL(utf))) != 0 {
								return uint32(1114111)
							} else {
								return uint32(255)
							}
						}())) {
							*errorcodeptr = ERR76
						} else if ((int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(55296)))))) && (c <= pcre_uint32((uint32(int32(57343))))) {
							*errorcodeptr = ERR73
						}
					}
				} else {
					*errorcodeptr = ERR37
				}
			}
		case pcre_uint32('U'):
			{
				if (options & int32(33554432)) == int32(0) {
					*errorcodeptr = ERR37
				}
			}
		case pcre_uint32('g'):
			{
				if int32((BOOL(isclass))) != 0 {
					break
				}
				if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('<')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\'')) {
					escape = ESC_g
					break
				}
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('{') {
					var p *pcre_uchar
					for p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr)))); (int32(uint8((*p))) != int32('\x00')) && (int32(uint8((*p))) != int32('}')); p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p)))) {
						if (int32(uint8((*p))) != int32('-')) && (noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')))])) != 0) {
							break
						}
					}
					if (int32(uint8((*p))) != int32('\x00')) && (int32(uint8((*p))) != int32('}')) {
						escape = ESC_k
						break
					}
					braced = BOOL((int32(1)))
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				} else {
					braced = BOOL((int32(0)))
				}
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('-') {
					negated = BOOL((int32(1)))
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				} else {
					negated = BOOL((int32(0)))
				}
				s = int32(0)
				overflow = BOOL((int32(0)))
				for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('9')) {
					if s > ((int32(2147483647) / int32(10)) - int32(1)) {
						overflow = BOOL((int32(1)))
						break
					}
					s = ((s * int32(10)) + (int32(uint8((*func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()))) - int32('0')))
				}
				if int32((BOOL(overflow))) != 0 {
					for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('9')) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					}
					*errorcodeptr = ERR61
					break
				}
				if (int32((braced)) != 0) && (int32(uint8((*func() *pcre_uchar {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					return ptr
				}()))) != int32('}')) {
					*errorcodeptr = ERR57
					break
				}
				if s == int32(0) {
					*errorcodeptr = ERR58
					break
				}
				if int32((BOOL(negated))) != 0 {
					if s > bracount {
						*errorcodeptr = ERR15
						break
					}
					s = (bracount - (s - int32(1)))
				}
				escape = -s
			}
		case pcre_uint32('1'):
			fallthrough
		case pcre_uint32('2'):
			fallthrough
		case pcre_uint32('3'):
			fallthrough
		case pcre_uint32('4'):
			fallthrough
		case pcre_uint32('5'):
			fallthrough
		case pcre_uint32('6'):
			fallthrough
		case pcre_uint32('7'):
			fallthrough
		case pcre_uint32('8'):
			fallthrough
		case pcre_uint32('9'):
			{
				if int32((NotBOOL(BOOL(isclass)))) != 0 {
					oldptr = ptr
					s = int32((uint32((c - pcre_uint32((uint32('0')))))))
					overflow = BOOL((int32(0)))
					for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('9')) {
						if s > ((int32(2147483647) / int32(10)) - int32(1)) {
							overflow = BOOL((int32(1)))
							break
						}
						s = ((s * int32(10)) + (int32(uint8((*func() *pcre_uchar {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							return ptr
						}()))) - int32('0')))
					}
					if int32((BOOL(overflow))) != 0 {
						for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('9')) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
						*errorcodeptr = ERR61
						break
					}
					if (s < int32(8)) || (s <= bracount) {
						escape = -s
						break
					}
					ptr = oldptr
				}
				if (func() pcre_uint32 {
					tempVar := pcre_uint32((uint32(uint8((*ptr)))))
					c = tempVar
					return tempVar
				}()) >= pcre_uint32((uint32('8'))) {
					break
				}
			}
			fallthrough
		case pcre_uint32('0'):
			{
				c -= pcre_uint32((uint32('0')))
				for ((func() int32 {
					defer func() {
						i += 1
					}()
					return i
				}() < int32(2)) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('7')) {
					c = (((c * pcre_uint32((uint32(int32(8))))) + pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}())))))) - pcre_uint32((uint32('0'))))
				}
				if (int32((NotBOOL(BOOL(utf)))) != 0) && (c > pcre_uint32((uint32(int32(255))))) {
					*errorcodeptr = ERR51
				}
			}
		case pcre_uint32('o'):
			{
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('{') {
					*errorcodeptr = ERR81
				} else if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('}') {
					*errorcodeptr = ERR86
				} else {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
					c = pcre_uint32(int32(0))
					overflow = BOOL((int32(0)))
					for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('7')) {
						var cc pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}()
							return ptr
						}())))))
						if (c == pcre_uint32((uint32(int32(0))))) && (cc == pcre_uint32((uint32('0')))) {
							continue
						}
						c = (((c << uint64(int32(3))) + cc) - pcre_uint32((uint32('0'))))
						if c > pcre_uint32((func() uint32 {
							if int32((BOOL(utf))) != 0 {
								return uint32(1114111)
							} else {
								return uint32(255)
							}
						}())) {
							overflow = BOOL((int32(1)))
							break
						}
					}
					if int32((BOOL(overflow))) != 0 {
						for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('7')) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
						*errorcodeptr = ERR34
					} else if int32(uint8((*ptr))) == int32('}') {
						if ((int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(55296)))))) && (c <= pcre_uint32((uint32(int32(57343))))) {
							*errorcodeptr = ERR73
						}
					} else {
						*errorcodeptr = ERR80
					}
				}
			}
		case pcre_uint32('x'):
			{
				if (options & int32(33554432)) != int32(0) {
					if (((int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0))) && (int32(1) != 0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &digitab[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(8)) != int32(0)) {
						c = pcre_uint32(int32(0))
						for i = int32(0); i < int32(2); i++ {
							var cc pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								return ptr
							}())))))
							if cc >= pcre_uint32((uint32('a'))) {
								cc -= pcre_uint32((uint32(int32(32))))
							}
							c = (((c << uint64(int32(4))) + cc) - pcre_uint32((uint32(func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(cc < pcre_uint32((uint32('A'))))]) != 0 {
									return int32('0')
								} else {
									return (int32(('A' - byte(int32(10)))))
								}
							}()))))
						}
					}
				} else {
					if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('{') {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						if int32(uint8((*ptr))) == int32('}') {
							*errorcodeptr = ERR86
							break
						}
						c = pcre_uint32(int32(0))
						overflow = BOOL((int32(0)))
						for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &digitab[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(8)) != int32(0)) {
							var cc pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								}()
								return ptr
							}())))))
							if (c == pcre_uint32((uint32(int32(0))))) && (cc == pcre_uint32((uint32('0')))) {
								continue
							}
							if cc >= pcre_uint32((uint32('a'))) {
								cc -= pcre_uint32((uint32(int32(32))))
							}
							c = (((c << uint64(int32(4))) + cc) - pcre_uint32((uint32(func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(cc < pcre_uint32((uint32('A'))))]) != 0 {
									return int32('0')
								} else {
									return (int32(('A' - byte(int32(10)))))
								}
							}()))))
							if c > pcre_uint32((func() uint32 {
								if int32((BOOL(utf))) != 0 {
									return uint32(1114111)
								} else {
									return uint32(255)
								}
							}())) {
								overflow = BOOL((int32(1)))
								break
							}
						}
						if int32((BOOL(overflow))) != 0 {
							for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &digitab[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(8)) != int32(0)) {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}
							*errorcodeptr = ERR34
						} else if int32(uint8((*ptr))) == int32('}') {
							if ((int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(55296)))))) && (c <= pcre_uint32((uint32(int32(57343))))) {
								*errorcodeptr = ERR73
							}
						} else {
							*errorcodeptr = ERR79
						}
					} else {
						c = pcre_uint32(int32(0))
						for ((func() int32 {
							defer func() {
								i += 1
							}()
							return i
						}() < int32(2)) && (int32(1) != 0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &digitab[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(8)) != int32(0)) {
							var cc pcre_uint32
							cc = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								return ptr
							}())))))
							if cc >= pcre_uint32((uint32('a'))) {
								cc -= pcre_uint32((uint32(int32(32))))
							}
							c = (((c * pcre_uint32((uint32(int32(16))))) + cc) - pcre_uint32((uint32(func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(cc < pcre_uint32((uint32('A'))))]) != 0 {
									return int32('0')
								} else {
									return (int32(('A' - byte(int32(10)))))
								}
							}()))))
						}
					}
				}
			}
		case pcre_uint32('c'):
			{
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					return ptr
				}())))))
				if c == pcre_uint32((uint32('\x00'))) {
					*errorcodeptr = ERR2
					break
				}
				if c > pcre_uint32((uint32(int32(127)))) {
					*errorcodeptr = ERR68
					break
				}
				if (c >= pcre_uint32((uint32('a')))) && (c <= pcre_uint32((uint32('z')))) {
					c -= pcre_uint32((uint32(int32(32))))
				}
				c ^= pcre_uint32((uint32(int32(64))))
			}
		default:
			{
				if (options & int32(64)) != int32(0) {
					switch pcre_uint32(c) {
					default:
						{
							*errorcodeptr = ERR3
							break
						}
					}
				}
				break
			}
		}
	}
	if ((escape == ESC_N) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('{'))) && (int32((NotBOOL(is_counted_repeat(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr)))))))) != 0) {
		*errorcodeptr = ERR37
	}
	if (((options & int32(536870912)) != int32(0)) && (escape >= ESC_D)) && (escape <= ESC_w) {
		escape += (ESC_DU - ESC_D)
	}
	*ptrptr = ptr
	*chptr = c
	return escape
}

// get_ucp - transpiled function from  /root/Documents/pcre/pcre_compile.c:1511
/*************************************************
*               Handle \P and \p                 *
*************************************************/ //
/* This function is called after \P or \p has been encountered, provided that
PCRE is compiled with support for Unicode properties. On entry, ptrptr is
pointing at the P or p. On exit, it is pointing at the final character of the
escape sequence.

Argument:
  ptrptr         points to the pattern position pointer
  negptr         points to a boolean that is set TRUE for negation else FALSE
  ptypeptr       points to an unsigned int that is set to the type value
  pdataptr       points to an unsigned int that is set to the detailed property value
  errorcodeptr   points to the error code variable

Returns:         TRUE if the type value was found, or FALSE for an invalid type
*/ //
/* \P or \p can be followed by a name in {}, optionally preceded by ^ for
negation. */ //
/* Otherwise there is just one following character */ //
/* Search for a recognized property name using binary chop */ //
//
func get_ucp(ptrptr **pcre_uchar, negptr *BOOL, ptypeptr *uint32, pdataptr *uint32, errorcodeptr *int32) BOOL {
	var c pcre_uchar
	var i int32
	var bot int32
	var top int32
	var ptr *pcre_uchar = *ptrptr
	var name []pcre_uchar = make([]pcre_uchar, 32, 32)
	c = *func() *pcre_uchar {
		ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
		return ptr
	}()
	if int32(uint8((c))) == int32('\x00') {
		goto ERROR_RETURN
	}
	*negptr = BOOL((int32(0)))
	if int32(uint8((c))) == int32('{') {
		if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('^') {
			*negptr = BOOL((int32(1)))
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
		}
		for i = int32(0); i < (int32((32 / 1)) - int32(1)); i++ {
			c = *func() *pcre_uchar {
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				return ptr
			}()
			if int32(uint8((c))) == int32('\x00') {
				goto ERROR_RETURN
			}
			if int32(uint8((c))) == int32('}') {
				break
			}
			*((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := &name[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
			}())) = c
		}
		if int32(uint8((c))) != int32('}') {
			goto ERROR_RETURN
		}
		*((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := &name[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
		}())) = pcre_uchar(int32(0))
	} else {
		*&name[0] = c
		*((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := &name[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
		}())) = pcre_uchar(int32(0))
	}
	*ptrptr = ptr
	bot = int32(0)
	top = _pcre_utt_size
	for bot < top {
		var r int32
		i = ((bot + top) >> uint64(int32(1)))
		r = noarch.Strcmp((*byte)(unsafe.Pointer(&(name)[0])), ((*byte)(func() unsafe.Pointer {
			tempVar := &_pcre_utt_names[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*((*ucp_type_table)(func() unsafe.Pointer {
				tempVar := &_pcre_utt[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
			}()))).name_offset)))))*unsafe.Sizeof(*tempVar))
		}())))
		if r == int32(0) {
			*ptypeptr = uint32(uint16((pcre_uint16((*((*ucp_type_table)(func() unsafe.Pointer {
				tempVar := &_pcre_utt[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
			}()))).type_))))
			*pdataptr = uint32(uint16((pcre_uint16((*((*ucp_type_table)(func() unsafe.Pointer {
				tempVar := &_pcre_utt[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
			}()))).value))))
			return BOOL((int32(1)))
		}
		if r > int32(0) {
			bot = (i + int32(1))
		} else {
			top = i
		}
	}
	*errorcodeptr = ERR47
	*ptrptr = ptr
	return BOOL((int32(0)))
ERROR_RETURN:
	;
	*errorcodeptr = ERR46
	*ptrptr = ptr
	return BOOL((int32(0)))
}

// read_repeat_counts - transpiled function from  /root/Documents/pcre/pcre_compile.c:1607
/*************************************************
*         Read repeat counts                     *
*************************************************/ //
/* Read an item of the form {n,m} and return the values. This is called only
after is_counted_repeat() has confirmed that a repeat-count quantifier exists,
so the syntax is guaranteed to be correct, but we need to check the values.

Arguments:
  p              pointer to first char after '{'
  minp           pointer to int for min
  maxp           pointer to int for max
                 returned as -1 if no max
  errorcodeptr   points to error code variable

Returns:         pointer to '}' on success;
                 current ptr on error, with errorcodeptr set non-zero
*/ //
//
func read_repeat_counts(p *pcre_uchar, minp *int32, maxp *int32, errorcodeptr *int32) *pcre_uchar {
	var min int32 = int32(0)
	var max int32 = -int32(1)
	for (int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')) {
		min = ((min * int32(10)) + (int32(uint8((*func() *pcre_uchar {
			defer func() {
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}()))) - int32('0')))
		if min > int32(65535) {
			*errorcodeptr = ERR5
			return p
		}
	}
	if int32(uint8((*p))) == int32('}') {
		max = min
	} else {
		if int32(uint8((*func() *pcre_uchar {
			p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			return p
		}()))) != int32('}') {
			max = int32(0)
			for (int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')) {
				max = ((max * int32(10)) + (int32(uint8((*func() *pcre_uchar {
					defer func() {
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}()
					return p
				}()))) - int32('0')))
				if max > int32(65535) {
					*errorcodeptr = ERR5
					return p
				}
			}
			if max < min {
				*errorcodeptr = ERR4
				return p
			}
		}
	}
	*minp = min
	*maxp = max
	return p
}

// first_significant_code - transpiled function from  /root/Documents/pcre/pcre_compile.c:1669
/*************************************************
*      Find first significant op code            *
*************************************************/ //
/* This is called by several functions that scan a compiled expression looking
for a fixed first character, or an anchoring op code etc. It skips over things
that do not influence this. For some calls, it makes sense to skip negative
forward and all backward assertions, and also the \b assertion; for others it
does not.

Arguments:
  code         pointer to the start of the group
  skipassert   TRUE if certain assertions are to be skipped

Returns:       pointer to the first significant opcode
*/ //
/* Fall through */ //
/* Control never reaches here */ //
//
func first_significant_code(code *pcre_uchar, skipassert BOOL) (c2goDefaultReturn *pcre_uchar) {
	for {
		switch int32(uint8((pcre_uchar(*code)))) {
		case OP_ASSERT_NOT:
			fallthrough
		case OP_ASSERTBACK:
			fallthrough
		case OP_ASSERTBACK_NOT:
			{
				if int32((NotBOOL(BOOL(skipassert)))) != 0 {
					return code
				}
				for {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
						break
					}
				}
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*code))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
			}
		case OP_WORD_BOUNDARY:
			fallthrough
		case OP_NOT_WORD_BOUNDARY:
			{
				if int32((NotBOOL(BOOL(skipassert)))) != 0 {
					return code
				}
			}
			fallthrough
		case OP_CALLOUT:
			fallthrough
		case OP_CREF:
			fallthrough
		case OP_DNCREF:
			fallthrough
		case OP_RREF:
			fallthrough
		case OP_DNRREF:
			fallthrough
		case OP_DEF:
			{
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*code))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
			}
		default:
			{
				return code
			}
		}
	}
	return
}

// find_fixedlength - transpiled function from  /root/Documents/pcre/pcre_compile.c:1736
/*************************************************
*        Find the fixed length of a branch       *
*************************************************/ //
/* Scan a branch and compute the fixed length of subject that will match it,
if the length is fixed. This is needed for dealing with backward assertions.
In UTF8 mode, the result is in characters rather than bytes. The branch is
temporarily terminated with OP_END when this function is called.

This function is called when a backward assertion is encountered, so that if it
fails, the error message can point to the correct place in the pattern.
However, we cannot do this when the assertion contains subroutine calls,
because they can be forward references. We solve this by remembering this case
and doing the check at the end; a flag specifies which mode we are running in.

Arguments:
  code     points to the start of the pattern (the bracket)
  utf      TRUE in UTF-8 / UTF-16 / UTF-32 mode
  atend    TRUE if called when the pattern is complete
  cd       the "compile data" structure
  recurses    chain of recurse_check to catch mutual recursion

Returns:   the fixed length,
             or -1 if there is no fixed length,
             or -2 if \C was encountered (in UTF-8 mode only)
             or -3 if an OP_RECURSE item was encountered and atend is FALSE
             or -4 if an unknown opcode was encountered (internal error)
*/ //
/* Scan along the opcodes for this branch. If we get to the end of the
branch, check the length against that of the other branches. */ //
/* We only need to continue for OP_CBRA (normal capturing bracket) and
   OP_BRA (normal non-capturing bracket) because the other variants of these
   opcodes are all concerned with unlimited repeated groups, which of course
   are not of fixed length. */ //
/* Reached end of a branch; if it's a ket it is the end of a nested call.
   If it's ALT it is an alternation in a nested call. An ACCEPT is effectively
   an ALT. If it is END it's the end of the outer call. All can be handled by
   the same code. Note that we must not include the OP_KETRxxx opcodes here,
   because they all imply an unlimited repeat. */ //
/* A true recursion implies not fixed length, but a subroutine call may
   be OK. If the subroutine is a forward reference, we can't deal with
   it until the end of the pattern, so return -3. */ //
/* Start subpattern */ //
/* End subpattern */ //
/* Recursion */ //
/* Check for mutual recursion */ //
/* Mutual recursion */ //
/* Skip over assertive subpatterns */ //
/* Skip over things that don't match chars */ //
/* Handle literal characters */ //
/* Handle exact repetitions. The count is already in characters, but we
   need to skip over a multibyte character in UTF8 mode.  */ //
/* Handle single-char matchers */ //
/* Fall through */ //
/* The single-byte matcher isn't allowed. This only happens in UTF-8 mode;
   otherwise \C is coded as OP_ALLANY. */ //
/* Check a class for variable quantification */ //
/* The original code caused an unsigned overflow in 64 bit systems,
   so now we use a conditional statement. */ //
/* Anything else is variable length */ //
/* Catch unrecognized opcodes so that when new ones are added they
   are not forgotten, as has happened in the past. */ //
/* Control never gets here */ //
//
func find_fixedlength(code *pcre_uchar, utf BOOL, atend BOOL, cd *compile_data, recurses *recurse_check) (c2goDefaultReturn int32) {
	var length int32 = -int32(1)
	var this_recurse recurse_check
	var branchlength int32 = int32(0)
	var cc *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
	}()))
	for {
		var d int32
		var ce *pcre_uchar
		var cs *pcre_uchar
		var op pcre_uchar = *cc
		switch int32(uint8((pcre_uchar(op)))) {
		case OP_CBRA:
			fallthrough
		case OP_BRA:
			fallthrough
		case OP_ONCE:
			fallthrough
		case OP_ONCE_NC:
			fallthrough
		case OP_COND:
			{
				d = find_fixedlength(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(func() int32 {
					if (map[bool]int32{false: 0, true: 1}[(int32(uint8((op))) == OP_CBRA)]) != 0 {
						return int32(2)
					} else {
						return int32(0)
					}
				}())*unsafe.Sizeof(*cc)))), BOOL(utf), BOOL(atend), cd, recurses)
				if d < int32(0) {
					return d
				}
				branchlength += d
				for {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*cc))) == OP_ALT)])) != 0 {
						break
					}
				}
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
			}
		case OP_ALT:
			fallthrough
		case OP_KET:
			fallthrough
		case OP_END:
			fallthrough
		case OP_ACCEPT:
			fallthrough
		case OP_ASSERT_ACCEPT:
			{
				if length < int32(0) {
					length = branchlength
				} else if length != branchlength {
					return -int32(1)
				}
				if int32(uint8((*cc))) != OP_ALT {
					return length
				}
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
				branchlength = int32(0)
			}
		case OP_RECURSE:
			{
				if int32((NotBOOL(BOOL(atend)))) != 0 {
					return -int32(3)
				}
				ce = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*cd).start_code
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*tempVar))
				}()))
				cs = ce
				for {
					ce = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ce)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ce))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ce))))))))))*unsafe.Sizeof(*ce))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ce))) == OP_ALT)])) != 0 {
						break
					}
				}
				if (int64(uintptr(unsafe.Pointer(cc))) > int64(uintptr(unsafe.Pointer(cs)))) && (int64(uintptr(unsafe.Pointer(cc))) < int64(uintptr(unsafe.Pointer(ce)))) {
					return -int32(1)
				} else {
					var r *recurse_check = recurses
					for r = recurses; r != nil; r = (*r).prev {
						if int64(uintptr(unsafe.Pointer((*r).group))) == int64(uintptr(unsafe.Pointer(cs))) {
							break
						}
					}
					if r != nil {
						return -int32(1)
					}
				}
				this_recurse.prev = recurses
				this_recurse.group = cs
				d = find_fixedlength(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cs)) + (uintptr)(int32(2))*unsafe.Sizeof(*cs)))), BOOL(utf), BOOL(atend), cd, &this_recurse)
				if d < int32(0) {
					return d
				}
				branchlength += d
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
			}
		case OP_ASSERT:
			fallthrough
		case OP_ASSERT_NOT:
			fallthrough
		case OP_ASSERTBACK:
			fallthrough
		case OP_ASSERTBACK_NOT:
			{
				for {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*cc))) == OP_ALT)])) != 0 {
						break
					}
				}
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
			}
		case OP_MARK:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			{
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc)))))))+int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*cc))))*unsafe.Sizeof(*tempVar))
				}())))))))*unsafe.Sizeof(*cc))))
			}
		case OP_CALLOUT:
			fallthrough
		case OP_CIRC:
			fallthrough
		case OP_CIRCM:
			fallthrough
		case OP_CLOSE:
			fallthrough
		case OP_COMMIT:
			fallthrough
		case OP_CREF:
			fallthrough
		case OP_DEF:
			fallthrough
		case OP_DNCREF:
			fallthrough
		case OP_DNRREF:
			fallthrough
		case OP_DOLL:
			fallthrough
		case OP_DOLLM:
			fallthrough
		case OP_EOD:
			fallthrough
		case OP_EODN:
			fallthrough
		case OP_FAIL:
			fallthrough
		case OP_NOT_WORD_BOUNDARY:
			fallthrough
		case OP_PRUNE:
			fallthrough
		case OP_REVERSE:
			fallthrough
		case OP_RREF:
			fallthrough
		case OP_SET_SOM:
			fallthrough
		case OP_SKIP:
			fallthrough
		case OP_SOD:
			fallthrough
		case OP_SOM:
			fallthrough
		case OP_THEN:
			fallthrough
		case OP_WORD_BOUNDARY:
			{
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*cc))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*cc))))
			}
		case OP_CHAR:
			fallthrough
		case OP_CHARI:
			fallthrough
		case OP_NOT:
			fallthrough
		case OP_NOTI:
			{
				branchlength += 1
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
				if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc))))))) >= int32(192)) {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_utf8_table4[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*cc))))
				}
			}
		case OP_EXACT:
			fallthrough
		case OP_EXACTI:
			fallthrough
		case OP_NOTEXACT:
			fallthrough
		case OP_NOTEXACTI:
			{
				branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*cc))))
				if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc))))))) >= int32(192)) {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_utf8_table4[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*cc))))
				}
			}
		case OP_TYPEEXACT:
			{
				branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
				if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_NOTPROP) {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
				}
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*cc))))
			}
		case OP_PROP:
			fallthrough
		case OP_NOTPROP:
			{
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
			}
			fallthrough
		case OP_HSPACE:
			fallthrough
		case OP_VSPACE:
			fallthrough
		case OP_NOT_HSPACE:
			fallthrough
		case OP_NOT_VSPACE:
			fallthrough
		case OP_NOT_DIGIT:
			fallthrough
		case OP_DIGIT:
			fallthrough
		case OP_NOT_WHITESPACE:
			fallthrough
		case OP_WHITESPACE:
			fallthrough
		case OP_NOT_WORDCHAR:
			fallthrough
		case OP_WORDCHAR:
			fallthrough
		case OP_ANY:
			fallthrough
		case OP_ALLANY:
			{
				branchlength += 1
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
			}
		case OP_ANYBYTE:
			{
				return -int32(2)
			}
		case OP_CLASS:
			fallthrough
		case OP_NCLASS:
			fallthrough
		case OP_XCLASS:
			{
				if int32(uint8((op))) == OP_XCLASS {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
				} else {
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_OP_lengths[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CLASS)*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*cc))))
				}
				switch int32(uint8((pcre_uchar(*cc)))) {
				case OP_CRSTAR:
					fallthrough
				case OP_CRMINSTAR:
					fallthrough
				case OP_CRPLUS:
					fallthrough
				case OP_CRMINPLUS:
					fallthrough
				case OP_CRQUERY:
					fallthrough
				case OP_CRMINQUERY:
					fallthrough
				case OP_CRPOSSTAR:
					fallthrough
				case OP_CRPOSPLUS:
					fallthrough
				case OP_CRPOSQUERY:
					{
						return -int32(1)
					}
				case OP_CRRANGE:
					fallthrough
				case OP_CRMINRANGE:
					fallthrough
				case OP_CRPOSRANGE:
					{
						if uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))) != uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(cc)))))))))) {
							return -int32(1)
						}
						branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
						cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*cc))))
					}
				default:
					{
						branchlength += 1
					}
				}
			}
		case OP_ANYNL:
			fallthrough
		case OP_BRAMINZERO:
			fallthrough
		case OP_BRAPOS:
			fallthrough
		case OP_BRAPOSZERO:
			fallthrough
		case OP_BRAZERO:
			fallthrough
		case OP_CBRAPOS:
			fallthrough
		case OP_EXTUNI:
			fallthrough
		case OP_KETRMAX:
			fallthrough
		case OP_KETRMIN:
			fallthrough
		case OP_KETRPOS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_MINQUERY:
			fallthrough
		case OP_MINQUERYI:
			fallthrough
		case OP_MINSTAR:
			fallthrough
		case OP_MINSTARI:
			fallthrough
		case OP_MINUPTO:
			fallthrough
		case OP_MINUPTOI:
			fallthrough
		case OP_NOTMINPLUS:
			fallthrough
		case OP_NOTMINPLUSI:
			fallthrough
		case OP_NOTMINQUERY:
			fallthrough
		case OP_NOTMINQUERYI:
			fallthrough
		case OP_NOTMINSTAR:
			fallthrough
		case OP_NOTMINSTARI:
			fallthrough
		case OP_NOTMINUPTO:
			fallthrough
		case OP_NOTMINUPTOI:
			fallthrough
		case OP_NOTPLUS:
			fallthrough
		case OP_NOTPLUSI:
			fallthrough
		case OP_NOTPOSPLUS:
			fallthrough
		case OP_NOTPOSPLUSI:
			fallthrough
		case OP_NOTPOSQUERY:
			fallthrough
		case OP_NOTPOSQUERYI:
			fallthrough
		case OP_NOTPOSSTAR:
			fallthrough
		case OP_NOTPOSSTARI:
			fallthrough
		case OP_NOTPOSUPTO:
			fallthrough
		case OP_NOTPOSUPTOI:
			fallthrough
		case OP_NOTQUERY:
			fallthrough
		case OP_NOTQUERYI:
			fallthrough
		case OP_NOTSTAR:
			fallthrough
		case OP_NOTSTARI:
			fallthrough
		case OP_NOTUPTO:
			fallthrough
		case OP_NOTUPTOI:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_POSPLUS:
			fallthrough
		case OP_POSPLUSI:
			fallthrough
		case OP_POSQUERY:
			fallthrough
		case OP_POSQUERYI:
			fallthrough
		case OP_POSSTAR:
			fallthrough
		case OP_POSSTARI:
			fallthrough
		case OP_POSUPTO:
			fallthrough
		case OP_POSUPTOI:
			fallthrough
		case OP_QUERY:
			fallthrough
		case OP_QUERYI:
			fallthrough
		case OP_REF:
			fallthrough
		case OP_REFI:
			fallthrough
		case OP_DNREF:
			fallthrough
		case OP_DNREFI:
			fallthrough
		case OP_SBRA:
			fallthrough
		case OP_SBRAPOS:
			fallthrough
		case OP_SCBRA:
			fallthrough
		case OP_SCBRAPOS:
			fallthrough
		case OP_SCOND:
			fallthrough
		case OP_SKIPZERO:
			fallthrough
		case OP_STAR:
			fallthrough
		case OP_STARI:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSUPTO:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEUPTO:
			fallthrough
		case OP_UPTO:
			fallthrough
		case OP_UPTOI:
			{
				return -int32(1)
			}
		default:
			{
				return -int32(4)
			}
		}
	}
	return
}

// _pcre_find_bracket - transpiled function from  /root/Documents/pcre/pcre_compile.c:2080
/*************************************************
*    Scan compiled regex for specific bracket    *
*************************************************/ //
/* This little function scans through a compiled pattern until it finds a
capturing bracket with the given number, or, if the number is negative, an
instance of OP_REVERSE for a lookbehind. The function is global in the C sense
so that it can be called from pcre_study() when finding the minimum matching
length.

Arguments:
  code        points to start of expression
  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode
  number      the required bracket number or negative to find a lookbehind

Returns:      pointer to the opcode for the bracket, or NULL if not found
*/ //
/* XCLASS is used for classes that cannot be represented just by a bit
map. This includes negated single high-valued characters. The length in
the table is zero; the actual length is stored in the compiled code. */ //
/* Handle recursion */ //
/* Handle capturing bracket */ //
/* Otherwise, we can get the item's length from the table, except that for
repeated character types, we have to test for \p and \P, which have an extra
two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we
must add in its length. */ //
/* Add in the fixed length from the table */ //
/* In UTF-8 mode, opcodes that are followed by a character may be followed by
a multi-byte character. The length in the table is a minimum, so we have to
arrange to skip the extra bytes. */ //
//
func _pcre_find_bracket(code *pcre_uchar, utf BOOL, number int32) (c2goDefaultReturn *pcre_uchar) {
	for {
		var c pcre_uchar = *code
		if int32(uint8((c))) == OP_END {
			return nil
		}
		if int32(uint8((c))) == OP_XCLASS {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		} else if int32(uint8((c))) == OP_REVERSE {
			if number < int32(0) {
				return code
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
		} else if (((int32(uint8((c))) == OP_CBRA) || (int32(uint8((c))) == OP_SCBRA)) || (int32(uint8((c))) == OP_CBRAPOS)) || (int32(uint8((c))) == OP_SCBRAPOS) {
			var n int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(code)))))))))))
			if n == number {
				return code
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
		} else {
			switch int32(uint8((pcre_uchar(c)))) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				}
			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				fallthrough
			case OP_TYPEPOSUPTO:
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				}
			case OP_MARK:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				{
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*code))))
					break
				}
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
			if int32((BOOL(utf))) != 0 {
				switch int32(uint8((pcre_uchar(c)))) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					{
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code))))))) >= int32(192))]) != 0 {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_utf8_table4[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*code))))
						}
						break
					}
				}
			}
		}
	}
	return
}

// find_recurse - transpiled function from  /root/Documents/pcre/pcre_compile.c:2243
/*************************************************
*   Scan compiled regex for recursion reference  *
*************************************************/ //
/* This little function scans through a compiled pattern until it finds an
instance of OP_RECURSE.

Arguments:
  code        points to start of expression
  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode

Returns:      pointer to the opcode for OP_RECURSE, or NULL if not found
*/ //
/* XCLASS is used for classes that cannot be represented just by a bit
map. This includes negated single high-valued characters. The length in
the table is zero; the actual length is stored in the compiled code. */ //
/* Otherwise, we can get the item's length from the table, except that for
repeated character types, we have to test for \p and \P, which have an extra
two bytes of parameters, and for MARK/PRUNE/SKIP/THEN with an argument, we
must add in its length. */ //
/* Add in the fixed length from the table */ //
/* In UTF-8 mode, opcodes that are followed by a character may be followed
   by a multi-byte character. The length in the table is a minimum, so we have
   to arrange to skip the extra bytes. */ //
//
func find_recurse(code *pcre_uchar, utf BOOL) (c2goDefaultReturn *pcre_uchar) {
	for {
		var c pcre_uchar = *code
		if int32(uint8((c))) == OP_END {
			return nil
		}
		if int32(uint8((c))) == OP_RECURSE {
			return code
		}
		if int32(uint8((c))) == OP_XCLASS {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		} else {
			switch int32(uint8((pcre_uchar(c)))) {
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEPOSPLUS:
				fallthrough
			case OP_TYPEPOSQUERY:
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				}
			case OP_TYPEPOSUPTO:
				fallthrough
			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEEXACT:
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				}
			case OP_MARK:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_THEN_ARG:
				{
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*code))))
					break
				}
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
			if int32((BOOL(utf))) != 0 {
				switch int32(uint8((pcre_uchar(c)))) {
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					fallthrough
				case OP_UPTO:
					fallthrough
				case OP_UPTOI:
					fallthrough
				case OP_NOTUPTO:
					fallthrough
				case OP_NOTUPTOI:
					fallthrough
				case OP_MINUPTO:
					fallthrough
				case OP_MINUPTOI:
					fallthrough
				case OP_NOTMINUPTO:
					fallthrough
				case OP_NOTMINUPTOI:
					fallthrough
				case OP_POSUPTO:
					fallthrough
				case OP_POSUPTOI:
					fallthrough
				case OP_NOTPOSUPTO:
					fallthrough
				case OP_NOTPOSUPTOI:
					fallthrough
				case OP_STAR:
					fallthrough
				case OP_STARI:
					fallthrough
				case OP_NOTSTAR:
					fallthrough
				case OP_NOTSTARI:
					fallthrough
				case OP_MINSTAR:
					fallthrough
				case OP_MINSTARI:
					fallthrough
				case OP_NOTMINSTAR:
					fallthrough
				case OP_NOTMINSTARI:
					fallthrough
				case OP_POSSTAR:
					fallthrough
				case OP_POSSTARI:
					fallthrough
				case OP_NOTPOSSTAR:
					fallthrough
				case OP_NOTPOSSTARI:
					fallthrough
				case OP_PLUS:
					fallthrough
				case OP_PLUSI:
					fallthrough
				case OP_NOTPLUS:
					fallthrough
				case OP_NOTPLUSI:
					fallthrough
				case OP_MINPLUS:
					fallthrough
				case OP_MINPLUSI:
					fallthrough
				case OP_NOTMINPLUS:
					fallthrough
				case OP_NOTMINPLUSI:
					fallthrough
				case OP_POSPLUS:
					fallthrough
				case OP_POSPLUSI:
					fallthrough
				case OP_NOTPOSPLUS:
					fallthrough
				case OP_NOTPOSPLUSI:
					fallthrough
				case OP_QUERY:
					fallthrough
				case OP_QUERYI:
					fallthrough
				case OP_NOTQUERY:
					fallthrough
				case OP_NOTQUERYI:
					fallthrough
				case OP_MINQUERY:
					fallthrough
				case OP_MINQUERYI:
					fallthrough
				case OP_NOTMINQUERY:
					fallthrough
				case OP_NOTMINQUERYI:
					fallthrough
				case OP_POSQUERY:
					fallthrough
				case OP_POSQUERYI:
					fallthrough
				case OP_NOTPOSQUERY:
					fallthrough
				case OP_NOTPOSQUERYI:
					{
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code))))))) >= int32(192))]) != 0 {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_utf8_table4[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*code))))
						}
						break
					}
				}
			}
		}
	}
	return
}

// could_be_empty_branch - transpiled function from  /root/Documents/pcre/pcre_compile.c:2396
/*************************************************
*    Scan compiled branch for non-emptiness      *
*************************************************/ //
/* This function scans through a branch of a compiled pattern to see whether it
can match the empty string or not. It is called from could_be_empty()
below and from compile_branch() when checking for an unlimited repeat of a
group that can match nothing. Note that first_significant_code() skips over
backward and negative forward assertions when its final argument is TRUE. If we
hit an unclosed bracket, we return "empty" - this means we've struck an inner
bracket whose current branch will already have been scanned.

Arguments:
  code        points to start of search
  endcode     points to where to stop
  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode
  cd          contains pointers to tables etc.
  recurses    chain of recurse_check to catch mutual recursion

Returns:      TRUE if what is matched could be empty
*/ //
/* Skip over forward assertions; the other assertions are skipped by
first_significant_code() with a TRUE final argument. */ //
/* For a recursion/subroutine call, if its end has been reached, which
implies a backward reference subroutine call, we can scan it. If it's a
forward reference subroutine call, we can't. To detect forward reference
we have to scan up the list that is kept in the workspace. This function is
called only when doing the real compile, not during the pre-compile that
measures the size of the compiled pattern. */ //
/* Test for forward reference or uncompleted reference. This is disabled
   when called to scan a completed pattern by setting cd->start_workspace to
   NULL. */ //
/* Unclosed */ //
/* If the reference is to a completed group, we need to detect whether this
   is a recursive call, as otherwise there will be an infinite loop. If it is
   a recursion, just skip over it. Simple recursions are easily detected. For
   mutual recursions we keep a chain on the stack. */ //
/* Simple recursion */ //
/* Mutual recursion */ //
/* Completed reference; scan the referenced group, remembering it on the
   stack chain to detect mutual recursions. */ //
/* All branches are non-empty */ //
/* Groups with zero repeats can of course be empty; skip them. */ //
/* A nested group that is already marked as "could be empty" can just be
skipped. */ //
/* For other groups, scan the branches. */ //
/* Hit unclosed bracket */ //
/* If a conditional group has only one branch, there is a second, implied,
   empty branch, so just skip over the conditional, because it could be empty.
   Otherwise, scan the individual branches of the group. */ //
/* All branches are non-empty */ //
/* Handle the other opcodes */ //
/* Check for quantifiers after a class. XCLASS is used for classes that
   cannot be represented just by a bit map. This includes negated single
   high-valued characters. The length in PRIV(OP_lengths)[] is zero; the
   actual length is stored in the compiled code, so we must update "code"
   here. */ //
/* These could be empty; continue */ //
/* Non-repeat => class must match */ //
/* These repeats aren't empty */ //
/* Minimum > 0 */ //
/* Opcodes that must match a character */ //
/* These are going to continue, as they may be empty, but we have to
   fudge the length for the \p and \P cases. */ //
/* Same for these */ //
/* End of branch */ //
/* In UTF-8 mode, STAR, MINSTAR, POSSTAR, QUERY, MINQUERY, POSQUERY, UPTO,
   MINUPTO, and POSUPTO and their caseless and negative versions may be
   followed by a multibyte character. */ //
/* MARK, and PRUNE/SKIP/THEN with an argument must skip over the argument
   string. */ //
/* None of the remaining opcodes are required to match a character. */ //
//
func could_be_empty_branch(code *pcre_uchar, endcode *pcre_uchar, utf BOOL, cd *compile_data, recurses *recurse_check) BOOL {
	var c pcre_uchar
	var this_recurse recurse_check
	for code = first_significant_code(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := &_pcre_OP_lengths[0]
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*code))))*unsafe.Sizeof(*tempVar))
	}()))))))*unsafe.Sizeof(*code)))), BOOL((int32(1)))); int64(uintptr(unsafe.Pointer(code))) < int64(uintptr(unsafe.Pointer(endcode))); code = first_significant_code(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := &_pcre_OP_lengths[0]
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
	}()))))))*unsafe.Sizeof(*code)))), BOOL((int32(1)))) {
		var ccode *pcre_uchar
		c = *code
		if int32(uint8((c))) == OP_ASSERT {
			for {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
					break
				}
			}
			c = *code
			continue
		}
		if int32(uint8((c))) == OP_RECURSE {
			var scode *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*cd).start_code
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*tempVar))
			}()))
			var endgroup *pcre_uchar = scode
			var empty_branch BOOL
			if (*cd).start_workspace != nil {
				var tcode *pcre_uchar
				for tcode = (*cd).start_workspace; int64(uintptr(unsafe.Pointer(tcode))) < int64(uintptr(unsafe.Pointer((*cd).hwm))); tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode)))) {
					if ((int32(uint8((*(tcode)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(tcode))))))))) == (int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) - int64(uintptr(unsafe.Pointer((*cd).start_code)))))) {
						return BOOL((int32(1)))
					}
				}
				if ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))) == int32(0) {
					return BOOL((int32(1)))
				}
			}
			for {
				endgroup = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endgroup)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endgroup))) + (uintptr)(int32(1))*unsafe.Sizeof(*(endgroup))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endgroup))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(endgroup))))))))))*unsafe.Sizeof(*endgroup))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*endgroup))) == OP_ALT)])) != 0 {
					break
				}
			}
			if (int64(uintptr(unsafe.Pointer(code))) >= int64(uintptr(unsafe.Pointer(scode)))) && (int64(uintptr(unsafe.Pointer(code))) <= int64(uintptr(unsafe.Pointer(endgroup)))) {
				continue
			} else {
				var r *recurse_check = recurses
				for r = recurses; r != nil; r = (*r).prev {
					if int64(uintptr(unsafe.Pointer((*r).group))) == int64(uintptr(unsafe.Pointer(scode))) {
						break
					}
				}
				if r != nil {
					continue
				}
			}
			empty_branch = BOOL((int32(0)))
			this_recurse.prev = recurses
			this_recurse.group = scode
			for {
				if int32((could_be_empty_branch(scode, endcode, BOOL(utf), cd, &this_recurse))) != 0 {
					empty_branch = BOOL((int32(1)))
					break
				}
				scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))))*unsafe.Sizeof(*scode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*scode))) == OP_ALT)])) != 0 {
					break
				}
			}
			if int32((NotBOOL(BOOL(empty_branch)))) != 0 {
				return BOOL((int32(0)))
			}
			continue
		}
		if (((int32(uint8((c))) == OP_BRAZERO) || (int32(uint8((c))) == OP_BRAMINZERO)) || (int32(uint8((c))) == OP_SKIPZERO)) || (int32(uint8((c))) == OP_BRAPOSZERO) {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
			for {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
					break
				}
			}
			c = *code
			continue
		}
		if (((int32(uint8((c))) == OP_SBRA) || (int32(uint8((c))) == OP_SBRAPOS)) || (int32(uint8((c))) == OP_SCBRA)) || (int32(uint8((c))) == OP_SCBRAPOS) {
			for {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
					break
				}
			}
			c = *code
			continue
		}
		if (((((((int32(uint8((c))) == OP_BRA) || (int32(uint8((c))) == OP_BRAPOS)) || (int32(uint8((c))) == OP_CBRA)) || (int32(uint8((c))) == OP_CBRAPOS)) || (int32(uint8((c))) == OP_ONCE)) || (int32(uint8((c))) == OP_ONCE_NC)) || (int32(uint8((c))) == OP_COND)) || (int32(uint8((c))) == OP_SCOND) {
			var empty_branch BOOL
			if ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))) == int32(0) {
				return BOOL((int32(1)))
			}
			if (int32(uint8((c))) == OP_COND) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))))) != OP_ALT) {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
			} else {
				empty_branch = BOOL((int32(0)))
				for {
					if (int32((NotBOOL(BOOL(empty_branch)))) != 0) && (int32((could_be_empty_branch(code, endcode, BOOL(utf), cd, recurses))) != 0) {
						empty_branch = BOOL((int32(1)))
					}
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
						break
					}
				}
				if int32((NotBOOL(BOOL(empty_branch)))) != 0 {
					return BOOL((int32(0)))
				}
			}
			c = *code
			continue
		}
		switch int32(uint8((pcre_uchar(c)))) {
		case OP_XCLASS:
			goto SW_GENERATED_LABEL_1
		case OP_CLASS:
			goto SW_GENERATED_LABEL_2
		case OP_NCLASS:
			goto SW_GENERATED_LABEL_3
		case OP_ANY:
			goto SW_GENERATED_LABEL_4
		case OP_ALLANY:
			goto SW_GENERATED_LABEL_5
		case OP_ANYBYTE:
			goto SW_GENERATED_LABEL_6
		case OP_PROP:
			goto SW_GENERATED_LABEL_7
		case OP_NOTPROP:
			goto SW_GENERATED_LABEL_8
		case OP_ANYNL:
			goto SW_GENERATED_LABEL_9
		case OP_NOT_HSPACE:
			goto SW_GENERATED_LABEL_10
		case OP_HSPACE:
			goto SW_GENERATED_LABEL_11
		case OP_NOT_VSPACE:
			goto SW_GENERATED_LABEL_12
		case OP_VSPACE:
			goto SW_GENERATED_LABEL_13
		case OP_EXTUNI:
			goto SW_GENERATED_LABEL_14
		case OP_NOT_DIGIT:
			goto SW_GENERATED_LABEL_15
		case OP_DIGIT:
			goto SW_GENERATED_LABEL_16
		case OP_NOT_WHITESPACE:
			goto SW_GENERATED_LABEL_17
		case OP_WHITESPACE:
			goto SW_GENERATED_LABEL_18
		case OP_NOT_WORDCHAR:
			goto SW_GENERATED_LABEL_19
		case OP_WORDCHAR:
			goto SW_GENERATED_LABEL_20
		case OP_CHAR:
			goto SW_GENERATED_LABEL_21
		case OP_CHARI:
			goto SW_GENERATED_LABEL_22
		case OP_NOT:
			goto SW_GENERATED_LABEL_23
		case OP_NOTI:
			goto SW_GENERATED_LABEL_24
		case OP_PLUS:
			goto SW_GENERATED_LABEL_25
		case OP_PLUSI:
			goto SW_GENERATED_LABEL_26
		case OP_MINPLUS:
			goto SW_GENERATED_LABEL_27
		case OP_MINPLUSI:
			goto SW_GENERATED_LABEL_28
		case OP_NOTPLUS:
			goto SW_GENERATED_LABEL_29
		case OP_NOTPLUSI:
			goto SW_GENERATED_LABEL_30
		case OP_NOTMINPLUS:
			goto SW_GENERATED_LABEL_31
		case OP_NOTMINPLUSI:
			goto SW_GENERATED_LABEL_32
		case OP_POSPLUS:
			goto SW_GENERATED_LABEL_33
		case OP_POSPLUSI:
			goto SW_GENERATED_LABEL_34
		case OP_NOTPOSPLUS:
			goto SW_GENERATED_LABEL_35
		case OP_NOTPOSPLUSI:
			goto SW_GENERATED_LABEL_36
		case OP_EXACT:
			goto SW_GENERATED_LABEL_37
		case OP_EXACTI:
			goto SW_GENERATED_LABEL_38
		case OP_NOTEXACT:
			goto SW_GENERATED_LABEL_39
		case OP_NOTEXACTI:
			goto SW_GENERATED_LABEL_40
		case OP_TYPEPLUS:
			goto SW_GENERATED_LABEL_41
		case OP_TYPEMINPLUS:
			goto SW_GENERATED_LABEL_42
		case OP_TYPEPOSPLUS:
			goto SW_GENERATED_LABEL_43
		case OP_TYPEEXACT:
			goto SW_GENERATED_LABEL_44
		case OP_TYPESTAR:
			goto SW_GENERATED_LABEL_45
		case OP_TYPEMINSTAR:
			goto SW_GENERATED_LABEL_46
		case OP_TYPEPOSSTAR:
			goto SW_GENERATED_LABEL_47
		case OP_TYPEQUERY:
			goto SW_GENERATED_LABEL_48
		case OP_TYPEMINQUERY:
			goto SW_GENERATED_LABEL_49
		case OP_TYPEPOSQUERY:
			goto SW_GENERATED_LABEL_50
		case OP_TYPEUPTO:
			goto SW_GENERATED_LABEL_51
		case OP_TYPEMINUPTO:
			goto SW_GENERATED_LABEL_52
		case OP_TYPEPOSUPTO:
			goto SW_GENERATED_LABEL_53
		case OP_KET:
			goto SW_GENERATED_LABEL_54
		case OP_KETRMAX:
			goto SW_GENERATED_LABEL_55
		case OP_KETRMIN:
			goto SW_GENERATED_LABEL_56
		case OP_KETRPOS:
			goto SW_GENERATED_LABEL_57
		case OP_ALT:
			goto SW_GENERATED_LABEL_58
		case OP_STAR:
			goto SW_GENERATED_LABEL_59
		case OP_STARI:
			goto SW_GENERATED_LABEL_60
		case OP_NOTSTAR:
			goto SW_GENERATED_LABEL_61
		case OP_NOTSTARI:
			goto SW_GENERATED_LABEL_62
		case OP_MINSTAR:
			goto SW_GENERATED_LABEL_63
		case OP_MINSTARI:
			goto SW_GENERATED_LABEL_64
		case OP_NOTMINSTAR:
			goto SW_GENERATED_LABEL_65
		case OP_NOTMINSTARI:
			goto SW_GENERATED_LABEL_66
		case OP_POSSTAR:
			goto SW_GENERATED_LABEL_67
		case OP_POSSTARI:
			goto SW_GENERATED_LABEL_68
		case OP_NOTPOSSTAR:
			goto SW_GENERATED_LABEL_69
		case OP_NOTPOSSTARI:
			goto SW_GENERATED_LABEL_70
		case OP_QUERY:
			goto SW_GENERATED_LABEL_71
		case OP_QUERYI:
			goto SW_GENERATED_LABEL_72
		case OP_NOTQUERY:
			goto SW_GENERATED_LABEL_73
		case OP_NOTQUERYI:
			goto SW_GENERATED_LABEL_74
		case OP_MINQUERY:
			goto SW_GENERATED_LABEL_75
		case OP_MINQUERYI:
			goto SW_GENERATED_LABEL_76
		case OP_NOTMINQUERY:
			goto SW_GENERATED_LABEL_77
		case OP_NOTMINQUERYI:
			goto SW_GENERATED_LABEL_78
		case OP_POSQUERY:
			goto SW_GENERATED_LABEL_79
		case OP_POSQUERYI:
			goto SW_GENERATED_LABEL_80
		case OP_NOTPOSQUERY:
			goto SW_GENERATED_LABEL_81
		case OP_NOTPOSQUERYI:
			goto SW_GENERATED_LABEL_82
		case OP_UPTO:
			goto SW_GENERATED_LABEL_83
		case OP_UPTOI:
			goto SW_GENERATED_LABEL_84
		case OP_NOTUPTO:
			goto SW_GENERATED_LABEL_85
		case OP_NOTUPTOI:
			goto SW_GENERATED_LABEL_86
		case OP_MINUPTO:
			goto SW_GENERATED_LABEL_87
		case OP_MINUPTOI:
			goto SW_GENERATED_LABEL_88
		case OP_NOTMINUPTO:
			goto SW_GENERATED_LABEL_89
		case OP_NOTMINUPTOI:
			goto SW_GENERATED_LABEL_90
		case OP_POSUPTO:
			goto SW_GENERATED_LABEL_91
		case OP_POSUPTOI:
			goto SW_GENERATED_LABEL_92
		case OP_NOTPOSUPTO:
			goto SW_GENERATED_LABEL_93
		case OP_NOTPOSUPTOI:
			goto SW_GENERATED_LABEL_94
		case OP_MARK:
			goto SW_GENERATED_LABEL_95
		case OP_PRUNE_ARG:
			goto SW_GENERATED_LABEL_96
		case OP_SKIP_ARG:
			goto SW_GENERATED_LABEL_97
		case OP_THEN_ARG:
			goto SW_GENERATED_LABEL_98
		default:
			goto SW_GENERATED_LABEL_99
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_1:
		{
			ccode = func() *pcre_uchar {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				return code
			}()
			goto CHECK_CLASS_REPEAT
		}
	SW_GENERATED_LABEL_2:
		;
	SW_GENERATED_LABEL_3:
		{
			ccode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CLASS)*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
		}
	CHECK_CLASS_REPEAT:
		{
			switch int32(uint8((pcre_uchar(*ccode)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSQUERY:
				{
				}
			default:
				fallthrough
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRPOSPLUS:
				{
					return BOOL((int32(0)))
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					if uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ccode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ccode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ccode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ccode)))))))))) > uint32(int32(0)) {
						return BOOL((int32(0)))
					}
					break
				}
			}
			goto SW_GENERATED_LABEL_0
		}
	SW_GENERATED_LABEL_4:
		;
	SW_GENERATED_LABEL_5:
		;
	SW_GENERATED_LABEL_6:
		;
	SW_GENERATED_LABEL_7:
		;
	SW_GENERATED_LABEL_8:
		;
	SW_GENERATED_LABEL_9:
		;
	SW_GENERATED_LABEL_10:
		;
	SW_GENERATED_LABEL_11:
		;
	SW_GENERATED_LABEL_12:
		;
	SW_GENERATED_LABEL_13:
		;
	SW_GENERATED_LABEL_14:
		;
	SW_GENERATED_LABEL_15:
		;
	SW_GENERATED_LABEL_16:
		;
	SW_GENERATED_LABEL_17:
		;
	SW_GENERATED_LABEL_18:
		;
	SW_GENERATED_LABEL_19:
		;
	SW_GENERATED_LABEL_20:
		;
	SW_GENERATED_LABEL_21:
		;
	SW_GENERATED_LABEL_22:
		;
	SW_GENERATED_LABEL_23:
		;
	SW_GENERATED_LABEL_24:
		;
	SW_GENERATED_LABEL_25:
		;
	SW_GENERATED_LABEL_26:
		;
	SW_GENERATED_LABEL_27:
		;
	SW_GENERATED_LABEL_28:
		;
	SW_GENERATED_LABEL_29:
		;
	SW_GENERATED_LABEL_30:
		;
	SW_GENERATED_LABEL_31:
		;
	SW_GENERATED_LABEL_32:
		;
	SW_GENERATED_LABEL_33:
		;
	SW_GENERATED_LABEL_34:
		;
	SW_GENERATED_LABEL_35:
		;
	SW_GENERATED_LABEL_36:
		;
	SW_GENERATED_LABEL_37:
		;
	SW_GENERATED_LABEL_38:
		;
	SW_GENERATED_LABEL_39:
		;
	SW_GENERATED_LABEL_40:
		;
	SW_GENERATED_LABEL_41:
		;
	SW_GENERATED_LABEL_42:
		;
	SW_GENERATED_LABEL_43:
		;
	SW_GENERATED_LABEL_44:
		{
			return BOOL((int32(0)))
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_45:
		;
	SW_GENERATED_LABEL_46:
		;
	SW_GENERATED_LABEL_47:
		;
	SW_GENERATED_LABEL_48:
		;
	SW_GENERATED_LABEL_49:
		;
	SW_GENERATED_LABEL_50:
		{
			if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
			}
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_51:
		;
	SW_GENERATED_LABEL_52:
		;
	SW_GENERATED_LABEL_53:
		{
			if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
			}
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_54:
		;
	SW_GENERATED_LABEL_55:
		;
	SW_GENERATED_LABEL_56:
		;
	SW_GENERATED_LABEL_57:
		;
	SW_GENERATED_LABEL_58:
		{
			return BOOL((int32(1)))
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_59:
		;
	SW_GENERATED_LABEL_60:
		;
	SW_GENERATED_LABEL_61:
		;
	SW_GENERATED_LABEL_62:
		;
	SW_GENERATED_LABEL_63:
		;
	SW_GENERATED_LABEL_64:
		;
	SW_GENERATED_LABEL_65:
		;
	SW_GENERATED_LABEL_66:
		;
	SW_GENERATED_LABEL_67:
		;
	SW_GENERATED_LABEL_68:
		;
	SW_GENERATED_LABEL_69:
		;
	SW_GENERATED_LABEL_70:
		;
	SW_GENERATED_LABEL_71:
		;
	SW_GENERATED_LABEL_72:
		;
	SW_GENERATED_LABEL_73:
		;
	SW_GENERATED_LABEL_74:
		;
	SW_GENERATED_LABEL_75:
		;
	SW_GENERATED_LABEL_76:
		;
	SW_GENERATED_LABEL_77:
		;
	SW_GENERATED_LABEL_78:
		;
	SW_GENERATED_LABEL_79:
		;
	SW_GENERATED_LABEL_80:
		;
	SW_GENERATED_LABEL_81:
		;
	SW_GENERATED_LABEL_82:
		{
			if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) >= int32(192)) {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_utf8_table4[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
			}
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_83:
		;
	SW_GENERATED_LABEL_84:
		;
	SW_GENERATED_LABEL_85:
		;
	SW_GENERATED_LABEL_86:
		;
	SW_GENERATED_LABEL_87:
		;
	SW_GENERATED_LABEL_88:
		;
	SW_GENERATED_LABEL_89:
		;
	SW_GENERATED_LABEL_90:
		;
	SW_GENERATED_LABEL_91:
		;
	SW_GENERATED_LABEL_92:
		;
	SW_GENERATED_LABEL_93:
		;
	SW_GENERATED_LABEL_94:
		{
			if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) >= int32(192)) {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_utf8_table4[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
			}
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_95:
		;
	SW_GENERATED_LABEL_96:
		;
	SW_GENERATED_LABEL_97:
		;
	SW_GENERATED_LABEL_98:
		{
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*code))))
		}
		goto SW_GENERATED_LABEL_0
	SW_GENERATED_LABEL_99:
		{
			goto SW_GENERATED_LABEL_0
		}
	SW_GENERATED_LABEL_0:
	}
	return BOOL((int32(1)))
}

// could_be_empty - transpiled function from  /root/Documents/pcre/pcre_compile.c:2771
/*************************************************
*    Scan compiled regex for non-emptiness       *
*************************************************/ //
/* This function is called to check for left recursive calls. We want to check
the current branch of the current pattern to see if it could match the empty
string. If it could, we must look outwards for branches at other levels,
stopping when we pass beyond the bracket which is the subject of the recursion.
This function is called only during the real compile, not during the
pre-compile.

Arguments:
  code        points to start of the recursion
  endcode     points to where to stop (current RECURSE item)
  bcptr       points to the chain of current (unclosed) branch starts
  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode
  cd          pointers to tables etc

Returns:      TRUE if what is matched could be empty
*/ //
//
func could_be_empty(code *pcre_uchar, endcode *pcre_uchar, bcptr *branch_chain, utf BOOL, cd *compile_data) BOOL {
	for (bcptr != nil) && (int64(uintptr(unsafe.Pointer((*bcptr).current_branch))) >= int64(uintptr(unsafe.Pointer(code)))) {
		if int32((NotBOOL(could_be_empty_branch((*bcptr).current_branch, endcode, BOOL(utf), cd, nil)))) != 0 {
			return BOOL((int32(0)))
		}
		bcptr = (*bcptr).outer
	}
	return BOOL((int32(1)))
}

// get_repeat_base - transpiled function from  /root/Documents/pcre/pcre_compile.c:2797
/*************************************************
*        Base opcode of repeated opcodes         *
*************************************************/ //
/* Returns the base opcode for repeated single character type opcodes. If the
opcode is not a repeated character type, it returns with the original value.

Arguments:  c opcode
Returns:    base opcode for the type
*/ //
//
func get_repeat_base(c pcre_uchar) pcre_uchar {
	return pcre_uchar(func() int32 {
		if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) > OP_TYPEPOSUPTO)]) != 0 {
			return int32(uint8((pcre_uchar(c))))
		} else {
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) >= OP_TYPESTAR)]) != 0 {
					return OP_TYPESTAR
				} else {
					return func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) >= OP_NOTSTARI)]) != 0 {
							return OP_NOTSTARI
						} else {
							return func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) >= OP_NOTSTAR)]) != 0 {
									return OP_NOTSTAR
								} else {
									return func() int32 {
										if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) >= OP_STARI)]) != 0 {
											return OP_STARI
										} else {
											return OP_STAR
										}
									}()
								}
							}()
						}
					}()
				}
			}()
		}
	}())
}

// check_char_prop - transpiled function from  /root/Documents/pcre/pcre_compile.c:2827
/*************************************************
*        Check a character and a property        *
*************************************************/ //
/* This function is called by check_auto_possessive() when a property item
is adjacent to a fixed character.

Arguments:
  c            the character
  ptype        the property type
  pdata        the data for the type
  negated      TRUE if it's a negated property (\P or \p{^)

Returns:       TRUE if auto-possessifying is OK
*/ //
/* These are specials */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included, which
means that Perl space and POSIX space are now identical. PCRE was changed
at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Control never reaches here */ //
/* Control never reaches here */ //
//
func check_char_prop(c pcre_uint32, ptype uint32, pdata uint32, negated BOOL) BOOL {
	var p *pcre_uint32
	var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
		tempVar := &_pcre_ucd_records[0]
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
			tempVar := &_pcre_ucd_stage2[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_stage1[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
			}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
		}()))))))*unsafe.Sizeof(*tempVar))
	}()))
	switch ptype {
	case uint32(int32(1)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[((((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt)) == (int32((negated)) != 0))]))
		}
	case uint32(int32(2)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[((pdata == uint32((*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucp_gentype[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
			}()))))) == (int32((negated)) != 0))]))
		}
	case uint32(int32(3)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[((pdata == uint32(uint8((pcre_uint8((*prop).chartype))))) == (int32((negated)) != 0))]))
		}
	case uint32(int32(4)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[((pdata == uint32(uint8((pcre_uint8((*prop).script))))) == (int32((negated)) != 0))]))
		}
	case uint32(int32(5)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucp_gentype[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucp_gentype[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(ucp_N))))) == (int32((negated)) != 0))]))
		}
	case uint32(int32(6)):
		fallthrough
	case uint32(int32(7)):
		{
			switch pcre_uint32(c) {
			case pcre_uint32('\t'):
				fallthrough
			case pcre_uint32(' '):
				fallthrough
			case pcre_uint32((uint8('\u00a0'))):
				fallthrough
			case pcre_uint32(int32(5760)):
				fallthrough
			case pcre_uint32(int32(6158)):
				fallthrough
			case pcre_uint32(int32(8192)):
				fallthrough
			case pcre_uint32(int32(8193)):
				fallthrough
			case pcre_uint32(int32(8194)):
				fallthrough
			case pcre_uint32(int32(8195)):
				fallthrough
			case pcre_uint32(int32(8196)):
				fallthrough
			case pcre_uint32(int32(8197)):
				fallthrough
			case pcre_uint32(int32(8198)):
				fallthrough
			case pcre_uint32(int32(8199)):
				fallthrough
			case pcre_uint32(int32(8200)):
				fallthrough
			case pcre_uint32(int32(8201)):
				fallthrough
			case pcre_uint32(int32(8202)):
				fallthrough
			case pcre_uint32(int32(8239)):
				fallthrough
			case pcre_uint32(int32(8287)):
				fallthrough
			case pcre_uint32(int32(12288)):
				fallthrough
			case pcre_uint32('\n'):
				fallthrough
			case pcre_uint32('\v'):
				fallthrough
			case pcre_uint32('\f'):
				fallthrough
			case pcre_uint32('\r'):
				fallthrough
			case pcre_uint32((uint8('\u0085'))):
				fallthrough
			case pcre_uint32(int32(8232)):
				fallthrough
			case pcre_uint32(int32(8233)):
				{
					return BOOL(negated)
				}
			default:
				{
					return BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_Z)))) == (int32((negated)) != 0))]))
				}
			}
		}
	case uint32(int32(8)):
		{
			return BOOL((map[bool]int32{false: 0, true: 1}[((((*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucp_gentype[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucp_gentype[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_'))))) == (int32((negated)) != 0))]))
		}
	case uint32(int32(9)):
		{
			p = ((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_caseless_sets[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).caseset)))))*unsafe.Sizeof(*tempVar))
			}()))
			for {
				if c < *p {
					return NotBOOL(BOOL(negated))
				}
				if c == *func() *pcre_uint32 {
					defer func() {
						p = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}()
					return p
				}() {
					return BOOL(negated)
				}
			}
			break
		}
	}
	return BOOL((int32(0)))
}

// get_chr_property_list - transpiled function from  /root/Documents/pcre/pcre_compile.c:2915
/*************************************************
*        Fill the character property list        *
*************************************************/ //
/* Checks whether the code points to an opcode that can take part in auto-
possessification, and if so, fills a list with its properties.

Arguments:
  code        points to start of expression
  utf         TRUE if in UTF-8 / UTF-16 / UTF-32 mode
  fcc         points to case-flipping table
  list        points to output list
              list[0] will be filled with the opcode
              list[1] will be non-zero if this opcode
                can match an empty character string
              list[2..7] depends on the opcode

Returns:      points to the start of the next opcode if *code is accepted
              NULL if *code is not accepted
*/ //
/* The othercase might be the same value. */ //
/* Convert only if we have enough space. */ //
/* Early return if there is not enough space. This should never
   happen, since all clists are shorter than 5 character now. */ //
/* All characters are stored. The terminating NOTACHAR
is copied form the clist itself. */ //
/* Opcode not accepted */ //
//
func get_chr_property_list(code *pcre_uchar, utf BOOL, fcc *pcre_uint8, list *pcre_uint32) *pcre_uchar {
	var c pcre_uchar = *code
	var base pcre_uchar
	var end *pcre_uchar
	var chr pcre_uint32
	var clist_dest *pcre_uint32
	var clist_src *pcre_uint32
	*list = pcre_uint32((uint32(uint8((c)))))
	*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(1))*unsafe.Sizeof(*list)))) = pcre_uint32(int32(0))
	code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
	if (int32(uint8((c))) >= OP_STAR) && (int32(uint8((c))) <= OP_TYPEPOSUPTO) {
		base = get_repeat_base(pcre_uchar(c))
		c -= pcre_uchar((uint8((int32(uint8((base))) - OP_STAR))))
		if (((int32(uint8((c))) == OP_UPTO) || (int32(uint8((c))) == OP_MINUPTO)) || (int32(uint8((c))) == OP_EXACT)) || (int32(uint8((c))) == OP_POSUPTO) {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
		}
		*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(1))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(map[bool]int32{false: 0, true: 1}[((((int32(uint8((c))) != OP_PLUS) && (int32(uint8((c))) != OP_MINPLUS)) && (int32(uint8((c))) != OP_EXACT)) && (int32(uint8((c))) != OP_POSPLUS))])))
		switch int32(uint8((pcre_uchar(base)))) {
		case OP_STAR:
			{
				*list = pcre_uint32((uint32(OP_CHAR)))
			}
		case OP_STARI:
			{
				*list = pcre_uint32((uint32(OP_CHARI)))
			}
		case OP_NOTSTAR:
			{
				*list = pcre_uint32((uint32(OP_NOT)))
			}
		case OP_NOTSTARI:
			{
				*list = pcre_uint32((uint32(OP_NOTI)))
			}
		case OP_TYPESTAR:
			{
				*list = pcre_uint32((uint32(uint8((*code)))))
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				break
			}
		}
		c = pcre_uchar((uint8(uint32((*list)))))
	}
	switch int32(uint8((pcre_uchar(c)))) {
	case OP_NOT_DIGIT:
		fallthrough
	case OP_DIGIT:
		fallthrough
	case OP_NOT_WHITESPACE:
		fallthrough
	case OP_WHITESPACE:
		fallthrough
	case OP_NOT_WORDCHAR:
		fallthrough
	case OP_WORDCHAR:
		fallthrough
	case OP_ANY:
		fallthrough
	case OP_ALLANY:
		fallthrough
	case OP_ANYNL:
		fallthrough
	case OP_NOT_HSPACE:
		fallthrough
	case OP_HSPACE:
		fallthrough
	case OP_NOT_VSPACE:
		fallthrough
	case OP_VSPACE:
		fallthrough
	case OP_EXTUNI:
		fallthrough
	case OP_EODN:
		fallthrough
	case OP_EOD:
		fallthrough
	case OP_DOLL:
		fallthrough
	case OP_DOLLM:
		{
			return code
		}
	case OP_CHAR:
		fallthrough
	case OP_NOT:
		{
			chr = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}())))))
			if (int32((utf)) != 0) && (chr >= pcre_uint32((uint32(int32(192))))) {
				if (chr & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					chr = (((chr & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}()))) & int32(63))))))
				} else if (chr & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					chr = ((((chr & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				} else if (chr & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					chr = (((((chr & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))
				} else if (chr & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					chr = ((((((chr & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(4))*unsafe.Sizeof(*code))))
				} else {
					chr = (((((((chr & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(4))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(5))*unsafe.Sizeof(*code))))
				}
			}
			*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list)))) = chr
			*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(4294967295)))
			return code
		}
	case OP_CHARI:
		fallthrough
	case OP_NOTI:
		{
			*list = pcre_uint32((uint32(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) == OP_CHARI)]) != 0 {
					return OP_CHAR
				} else {
					return OP_NOT
				}
			}())))
			chr = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}())))))
			if (int32((utf)) != 0) && (chr >= pcre_uint32((uint32(int32(192))))) {
				if (chr & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					chr = (((chr & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}()))) & int32(63))))))
				} else if (chr & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					chr = ((((chr & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				} else if (chr & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					chr = (((((chr & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))
				} else if (chr & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					chr = ((((((chr & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(4))*unsafe.Sizeof(*code))))
				} else {
					chr = (((((((chr & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*code))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(4))*unsafe.Sizeof(*code))))))) & int32(63))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(5))*unsafe.Sizeof(*code))))
				}
			}
			*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list)))) = chr
			if (chr < pcre_uint32((uint32(int32(128))))) || ((chr < pcre_uint32((uint32(int32(256))))) && (int32((NotBOOL(BOOL(utf)))) != 0)) {
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(fcc)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*fcc)))))))))
			} else {
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((int32(uint32((pcre_uint32(chr)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_records[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage1[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((chr)))))/int32(128)))*unsafe.Sizeof(*tempVar))
						}())))))*int32(128))+(int32(uint32((pcre_uint32((chr)))))%int32(128))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*tempVar))
				}()))).other_case))))))
			}
			if chr == *((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) {
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(4294967295)))
			} else {
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(4))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(4294967295)))
			}
			return code
		}
	case OP_PROP:
		fallthrough
	case OP_NOTPROP:
		{
			if int32(uint8((*code))) != int32(9) {
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(uint8((*code)))))
				*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))))
				return ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
			}
			clist_src = ((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_caseless_sets[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*tempVar))
			}()))
			clist_dest = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list))))
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
			for {
				if int64(uintptr(unsafe.Pointer(clist_dest))) >= int64(uintptr(unsafe.Pointer(((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(8))*unsafe.Sizeof(*list))))))) {
					*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(uint8((*code)))))
					*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(3))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))))
					return code
				}
				*func() *pcre_uint32 {
					defer func() {
						clist_dest = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(clist_dest)) + (uintptr)(1)*unsafe.Sizeof(*clist_dest))))
					}()
					return clist_dest
				}() = *clist_src
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(*func() *pcre_uint32 {
					defer func() {
						clist_src = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(clist_src)) + (uintptr)(1)*unsafe.Sizeof(*clist_src))))
					}()
					return clist_src
				}() != pcre_uint32((uint32(4294967295))))])) != 0 {
					break
				}
			}
			*list = pcre_uint32((uint32(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) == OP_PROP)]) != 0 {
					return OP_CHAR
				} else {
					return OP_NOT
				}
			}())))
			return code
		}
	case OP_NCLASS:
		fallthrough
	case OP_CLASS:
		fallthrough
	case OP_XCLASS:
		{
			if int32(uint8((c))) == OP_XCLASS {
				end = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*(code))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
				}()))
			} else {
				end = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*code))))
			}
			switch int32(uint8((pcre_uchar(*end)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSQUERY:
				{
					*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(1))*unsafe.Sizeof(*list)))) = pcre_uint32(int32(1))
					end = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end)) + (uintptr)(1)*unsafe.Sizeof(*end))))
				}
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRPOSPLUS:
				{
					end = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end)) + (uintptr)(1)*unsafe.Sizeof(*end))))
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(1))*unsafe.Sizeof(*list)))) = pcre_uint32((uint32(map[bool]int32{false: 0, true: 1}[(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end)))))))))) == uint32(int32(0)))])))
					end = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*end))))
					break
				}
			}
			*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list)) + (uintptr)(int32(2))*unsafe.Sizeof(*list)))) = pcre_uint32((int32((int64(uintptr(unsafe.Pointer(end))) - int64(uintptr(unsafe.Pointer(code)))))))
			return end
		}
	}
	return nil
}

// compare_opcodes - transpiled function from  /root/Documents/pcre/pcre_compile.c:3120
/*************************************************
*    Scan further character sets for match       *
*************************************************/ //
/* Checks whether the base and the current opcode have a common character, in
which case the base cannot be possessified.

Arguments:
  code        points to the byte code
  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode
  cd          static compile data
  base_list   the data list of the base opcode

Returns:      TRUE if the auto-possessification is possible
*/ //
/* Note: the base_list[1] contains whether the current opcode has greedy
(represented by a non-zero value) quantifier. This is a different from
other character type lists, which stores here that the character iterator
matches to an empty string (also represented by a non-zero value). */ //
/* All operations move the code pointer forward.
Therefore infinite recursions are not possible. */ //
/* Skip over callouts */ //
/* TRUE only in greedy case. The non-greedy case could be replaced by
   an OP_EXACT, but it is probably not worth it. (And note that OP_EXACT
   uses more memory, which we cannot get at this stage.) */ //
/* If the bracket is capturing, and referenced by an OP_RECURSE, or
   it is an atomic sub-pattern (assert, once, etc.) the non-greedy case
   cannot be converted to a possessive form. */ //
/* Atomic sub-patterns and assertions can always auto-possessify their
   last iterator. However, if the group was entered as a result of checking
   a previous iterator, this is not possible. */ //
/* The bracket content will be checked by the
   OP_BRA/OP_CBRA case above. */ //
/* Check for a supported opcode, and load its properties. */ //
/* Unsupported */ //
/* If either opcode is a small character list, set pointers for comparing
characters from that list with another list, or with a property. */ //
/* Character bitsets can also be compared to certain opcodes. */ //
/* In 8 bit, non-UTF mode, OP_CLASS and OP_NCLASS are the same. */ //
/* No bits are set for characters < 256. */ //
/* Might be an empty repeat. */ //
/* Fall through */ //
/* Fall through */ //
/* Fall through */ //
/* Because the sets are unaligned, we need
   to perform byte comparison here. */ //
/* Might be an empty repeat. */ //
/* Some property combinations also acceptable. Unicode property opcodes are
processed specially; the rest can be handled with a lookup table. */ //
/* Always set in non-unicode case. */ //
/* There's a table that specifies how each combination is to be
   processed:
     0   Always return FALSE (never auto-possessify)
     1   Character groups are distinct (possessify if both are OP_PROP)
     2   Check character categories in the same group (general or particular)
     3   Return TRUE if the two opcodes are not the same
     ... see comments below
*/ //
/* Left general category, right particular category */ //
/* Right general category, left particular category */ //
/* This code is logically tricky. Think hard before fiddling with it.
   The posspropstab table has four entries per row. Each row relates to
   one of PCRE's special properties such as ALNUM or SPACE or WORD.
   Only WORD actually needs all four entries, but using repeats for the
   others means they can all use the same code below.

   The first two entries in each row are Unicode general categories, and
   apply always, because all the characters they include are part of the
   PCRE character set. The third and fourth entries are a general and a
   particular category, respectively, that include one or more relevant
   characters. One or the other is used, depending on whether the check
   is for a general or a particular category. However, in both cases the
   category contains more characters than the specials that are defined
   for the property being tested against. Therefore, it cannot be used
   in a NOTPROP case.

   Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.
   Underscore is covered by ucp_P or ucp_Po. */ //
/* Left alphanum vs right general category */ //
/* Left space vs right general category */ //
/* Left word vs right general category */ //
/* Right alphanum vs left general category */ //
/* Right space vs left general category */ //
/* Right word vs left general category */ //
/* Left alphanum vs right particular category */ //
/* Left space vs right particular category */ //
/* Left word vs right particular category */ //
/* Right alphanum vs left particular category */ //
/* Right space vs left particular category */ //
/* Right word vs left particular category */ //
/* Might be an empty repeat. */ //
/* Control reaches here only if one of the items is a small character list.
All characters are checked against the other side. */ //
/* Not found */ //
/* Note that OP_DIGIT etc. are generated only when PCRE_UCP is *not*
   set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes. */ //
/* Can always possessify before \z */ //
/* Fall through */ //
/* At least one character must be matched from this opcode. */ //
/* Control never reaches here. There used to be a fail-save return FALSE; here,
but some compilers complain about an unreachable statement. */ //
//
func compare_opcodes(code *pcre_uchar, utf BOOL, cd *compile_data, base_list *pcre_uint32, base_end *pcre_uchar, rec_limit *int32) (c2goDefaultReturn BOOL) {
	var c pcre_uchar
	var list []pcre_uint32 = make([]pcre_uint32, 8, 8)
	var chr_ptr *pcre_uint32
	var ochr_ptr *pcre_uint32
	var list_ptr *pcre_uint32
	var next_code *pcre_uchar
	var xclass_flags *pcre_uchar
	var class_bitset *pcre_uint8
	var set1 *pcre_uint8
	var set2 *pcre_uint8
	var set_end *pcre_uint8
	var chr pcre_uint32
	var accepted BOOL
	var invert_bits BOOL
	var entered_a_group BOOL = BOOL((int32(0)))
	if *rec_limit == int32(0) {
		return BOOL((int32(0)))
	}
	*rec_limit -= int32(1)
	for {
		c = *code
		if int32(uint8((c))) == OP_CALLOUT {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*code))))
			continue
		}
		if int32(uint8((c))) == OP_ALT {
			for {
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
					break
				}
			}
			c = *code
		}
		switch int32(uint8((pcre_uchar(c)))) {
		case OP_END:
			fallthrough
		case OP_KETRPOS:
			{
				return BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(1))*unsafe.Sizeof(*base_list)))) != pcre_uint32((uint32(int32(0)))))]))
			}
		case OP_KET:
			{
				if *((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(1))*unsafe.Sizeof(*base_list)))) == pcre_uint32((uint32(int32(0)))) {
					return BOOL((int32(0)))
				}
				switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(int32(uint8(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))))*unsafe.Sizeof(*code)))))))) {
				case OP_ASSERT:
					fallthrough
				case OP_ASSERT_NOT:
					fallthrough
				case OP_ASSERTBACK:
					fallthrough
				case OP_ASSERTBACK_NOT:
					fallthrough
				case OP_ONCE:
					fallthrough
				case OP_ONCE_NC:
					{
						return NotBOOL(BOOL(entered_a_group))
					}
				}
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
				continue
			}
			fallthrough
		case OP_ONCE:
			fallthrough
		case OP_ONCE_NC:
			fallthrough
		case OP_BRA:
			fallthrough
		case OP_CBRA:
			{
				next_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
				for int32(uint8((*next_code))) == OP_ALT {
					if int32((NotBOOL(compare_opcodes(code, BOOL(utf), cd, base_list, base_end, rec_limit)))) != 0 {
						return BOOL((int32(0)))
					}
					code = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next_code)) + (uintptr)(int32(1))*unsafe.Sizeof(*next_code))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}()))
					next_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(next_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(next_code))))))))))*unsafe.Sizeof(*next_code))))
				}
				entered_a_group = BOOL((int32(1)))
				continue
			}
			fallthrough
		case OP_BRAZERO:
			fallthrough
		case OP_BRAMINZERO:
			{
				next_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
				if (((int32(uint8((*next_code))) != OP_BRA) && (int32(uint8((*next_code))) != OP_CBRA)) && (int32(uint8((*next_code))) != OP_ONCE)) && (int32(uint8((*next_code))) != OP_ONCE_NC) {
					return BOOL((int32(0)))
				}
				for {
					next_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(next_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(next_code))))))))))*unsafe.Sizeof(*next_code))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*next_code))) == OP_ALT)])) != 0 {
						break
					}
				}
				next_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next_code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*next_code))))
				if int32((NotBOOL(compare_opcodes(next_code, BOOL(utf), cd, base_list, base_end, rec_limit)))) != 0 {
					return BOOL((int32(0)))
				}
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))
				continue
			}
			fallthrough
		default:
			{
				break
			}
		}
		code = get_chr_property_list(code, BOOL(utf), (*cd).fcc, &list[0])
		if code == nil {
			return BOOL((int32(0)))
		}
		if *base_list == pcre_uint32((uint32(OP_CHAR))) {
			chr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(2))*unsafe.Sizeof(*base_list))))
			list_ptr = &list[0]
		} else if *&list[0] == pcre_uint32((uint32(OP_CHAR))) {
			chr_ptr = ((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &list[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
			list_ptr = base_list
		} else if ((*base_list == pcre_uint32((uint32(OP_CLASS)))) || (*&list[0] == pcre_uint32((uint32(OP_CLASS))))) || ((int32((NotBOOL(BOOL(utf)))) != 0) && ((*base_list == pcre_uint32((uint32(OP_NCLASS)))) || (*&list[0] == pcre_uint32((uint32(OP_NCLASS)))))) {
			if (*base_list == pcre_uint32((uint32(OP_CLASS)))) || ((int32((NotBOOL(BOOL(utf)))) != 0) && (*base_list == pcre_uint32((uint32(OP_NCLASS))))) {
				set1 = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(base_end)) - (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(2))*unsafe.Sizeof(*base_list))))))))*unsafe.Sizeof(*base_end))))))
				list_ptr = &list[0]
			} else {
				set1 = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
					tempVar := &list[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*code))))))
				list_ptr = base_list
			}
			invert_bits = BOOL((int32(0)))
			switch pcre_uint32(*list_ptr) {
			case pcre_uint32(OP_CLASS):
				fallthrough
			case pcre_uint32(OP_NCLASS):
				{
					set2 = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := func() *pcre_uchar {
							if int64(uintptr(unsafe.Pointer(list_ptr))) == int64(uintptr(unsafe.Pointer(&list[0]))) {
								return code
							} else {
								return base_end
							}
						}()
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))
				}
			case pcre_uint32(OP_XCLASS):
				{
					xclass_flags = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := func() *pcre_uchar {
								if int64(uintptr(unsafe.Pointer(list_ptr))) == int64(uintptr(unsafe.Pointer(&list[0]))) {
									return code
								} else {
									return base_end
								}
							}()
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))))))*unsafe.Sizeof(*tempVar))
						}()))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}()))
					if (int32(uint8((*xclass_flags))) & int32(4)) != int32(0) {
						return BOOL((int32(0)))
					}
					if (int32(uint8((*xclass_flags))) & int32(2)) == int32(0) {
						if *((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &list[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}())) == pcre_uint32((uint32(int32(0)))) {
							return BOOL((int32(1)))
						}
						continue
					}
					set2 = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(xclass_flags)) + (uintptr)(int32(1))*unsafe.Sizeof(*xclass_flags))))))
				}
			case pcre_uint32(OP_NOT_DIGIT):
				{
					invert_bits = BOOL((int32(1)))
				}
				fallthrough
			case pcre_uint32(OP_DIGIT):
				{
					set2 = ((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).cbits
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(64))*unsafe.Sizeof(*tempVar))
					}()))
				}
			case pcre_uint32(OP_NOT_WHITESPACE):
				{
					invert_bits = BOOL((int32(1)))
				}
				fallthrough
			case pcre_uint32(OP_WHITESPACE):
				{
					set2 = ((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).cbits
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(0))*unsafe.Sizeof(*tempVar))
					}()))
				}
			case pcre_uint32(OP_NOT_WORDCHAR):
				{
					invert_bits = BOOL((int32(1)))
				}
				fallthrough
			case pcre_uint32(OP_WORDCHAR):
				{
					set2 = ((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).cbits
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(160))*unsafe.Sizeof(*tempVar))
					}()))
				}
			default:
				{
					return BOOL((int32(0)))
				}
			}
			set_end = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(set1)) + (uintptr)(int32(32))*unsafe.Sizeof(*set1))))
			if int32((BOOL(invert_bits))) != 0 {
				for {
					if (int32(uint8((*func() *pcre_uint8 {
						defer func() {
							set1 = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(set1)) + (uintptr)(1)*unsafe.Sizeof(*set1))))
						}()
						return set1
					}()))) & ^int32(uint8((pcre_uint8((*func() *pcre_uint8 {
						defer func() {
							set2 = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(set2)) + (uintptr)(1)*unsafe.Sizeof(*set2))))
						}()
						return set2
					}())))))) != int32(0) {
						return BOOL((int32(0)))
					}
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(set1))) < int64(uintptr(unsafe.Pointer(set_end))))])) != 0 {
						break
					}
				}
			} else {
				for {
					if (int32(uint8((*func() *pcre_uint8 {
						defer func() {
							set1 = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(set1)) + (uintptr)(1)*unsafe.Sizeof(*set1))))
						}()
						return set1
					}()))) & int32(uint8((*func() *pcre_uint8 {
						defer func() {
							set2 = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(set2)) + (uintptr)(1)*unsafe.Sizeof(*set2))))
						}()
						return set2
					}())))) != int32(0) {
						return BOOL((int32(0)))
					}
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(set1))) < int64(uintptr(unsafe.Pointer(set_end))))])) != 0 {
						break
					}
				}
			}
			if *((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &list[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(int32(0)))) {
				return BOOL((int32(1)))
			}
			continue
		} else {
			var leftop pcre_uint32
			var rightop pcre_uint32
			leftop = *base_list
			rightop = *&list[0]
			accepted = BOOL((int32(0)))
			if (leftop == pcre_uint32((uint32(OP_PROP)))) || (leftop == pcre_uint32((uint32(OP_NOTPROP)))) {
				if rightop == pcre_uint32((uint32(OP_EOD))) {
					accepted = BOOL((int32(1)))
				} else if (rightop == pcre_uint32((uint32(OP_PROP)))) || (rightop == pcre_uint32((uint32(OP_NOTPROP)))) {
					var n int32
					var p *pcre_uint8
					var same BOOL = BOOL((map[bool]int32{false: 0, true: 1}[(leftop == rightop)]))
					var lisprop BOOL = BOOL((map[bool]int32{false: 0, true: 1}[(leftop == pcre_uint32((uint32(OP_PROP))))]))
					var risprop BOOL = BOOL((map[bool]int32{false: 0, true: 1}[(rightop == pcre_uint32((uint32(OP_PROP))))]))
					var bothprop BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((int32((lisprop)) != 0) && (int32((risprop)) != 0))]))
					n = int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &propposstab[*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(2))*unsafe.Sizeof(*base_list))))][0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &list[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}())))))
					switch n {
					case int32(0):
						{
						}
					case int32(1):
						{
							accepted = bothprop
						}
					case int32(2):
						{
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list)))) == *((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &list[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}()))) != (int32((same)) != 0))]))
						}
					case int32(3):
						{
							accepted = NotBOOL(BOOL(same))
						}
					case int32(4):
						{
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((risprop)) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list))))][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &list[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))))) == int32((same))))]))
						}
					case int32(5):
						{
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((lisprop)) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &list[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
								}()))][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list))))))))*unsafe.Sizeof(*tempVar))
							}()))))) == int32((same))))]))
						}
					case int32(6):
						fallthrough
					case int32(7):
						fallthrough
					case int32(8):
						{
							p = &posspropstab[(n - int32(6))][0]
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((risprop)) != 0) && (lisprop == BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &list[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}())) != pcre_uint32((uint32(uint8((*p)))))) && (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &list[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}())) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))))))) && ((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &list[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}())) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p)))))))))) || (int32((NotBOOL(BOOL(lisprop)))) != 0)))]))))]))
						}
					case int32(9):
						fallthrough
					case int32(10):
						fallthrough
					case int32(11):
						{
							p = &posspropstab[(n - int32(9))][0]
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((lisprop)) != 0) && (risprop == BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list)))) != pcre_uint32((uint32(uint8((*p)))))) && (*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list)))) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))))))) && ((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list)))) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p)))))))))) || (int32((NotBOOL(BOOL(risprop)))) != 0)))]))))]))
						}
					case int32(12):
						fallthrough
					case int32(13):
						fallthrough
					case int32(14):
						{
							p = &posspropstab[(n - int32(12))][0]
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((risprop)) != 0) && (lisprop == BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*p][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &list[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))))) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &list[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))))) != 0)) && ((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &list[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}())) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p)))))))))) || (int32((NotBOOL(BOOL(lisprop)))) != 0)))]))))]))
						}
					case int32(15):
						fallthrough
					case int32(16):
						fallthrough
					case int32(17):
						{
							p = &posspropstab[(n - int32(15))][0]
							accepted = BOOL((map[bool]int32{false: 0, true: 1}[((int32((lisprop)) != 0) && (risprop == BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*p][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list))))))))*unsafe.Sizeof(*tempVar))
							}()))))) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &catposstab[*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))][0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list))))))))*unsafe.Sizeof(*tempVar))
							}()))))) != 0)) && ((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(base_list)) + (uintptr)(int32(3))*unsafe.Sizeof(*base_list)))) != pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p)))))))))) || (int32((NotBOOL(BOOL(risprop)))) != 0)))]))))]))
							break
						}
					}
				}
			} else {
				accepted = BOOL((map[bool]int32{false: 0, true: 1}[(((((leftop >= pcre_uint32((uint32(OP_NOT_DIGIT)))) && (leftop <= pcre_uint32((uint32(OP_EXTUNI))))) && (rightop >= pcre_uint32((uint32(OP_NOT_DIGIT))))) && (rightop <= pcre_uint32((uint32(OP_DOLLM))))) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &autoposstab[(leftop - pcre_uint32((uint32(OP_NOT_DIGIT))))][0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((rightop-pcre_uint32((uint32(OP_NOT_DIGIT)))))))*unsafe.Sizeof(*tempVar))
				}()))))) != 0))]))
			}
			if int32((NotBOOL(BOOL(accepted)))) != 0 {
				return BOOL((int32(0)))
			}
			if *((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &list[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) == pcre_uint32((uint32(int32(0)))) {
				return BOOL((int32(1)))
			}
			continue
		}
		for {
			chr = *chr_ptr
			switch pcre_uint32(*list_ptr) {
			case pcre_uint32(OP_CHAR):
				{
					ochr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))
					for {
						if chr == *ochr_ptr {
							return BOOL((int32(0)))
						}
						ochr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ochr_ptr)) + (uintptr)(1)*unsafe.Sizeof(*ochr_ptr))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(*ochr_ptr != pcre_uint32((uint32(4294967295))))])) != 0 {
							break
						}
					}
				}
			case pcre_uint32(OP_NOT):
				{
					ochr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))
					for {
						if chr == *ochr_ptr {
							break
						}
						ochr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ochr_ptr)) + (uintptr)(1)*unsafe.Sizeof(*ochr_ptr))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(*ochr_ptr != pcre_uint32((uint32(4294967295))))])) != 0 {
							break
						}
					}
					if *ochr_ptr == pcre_uint32((uint32(4294967295))) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_DIGIT):
				{
					if (chr < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(4)) != int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_NOT_DIGIT):
				{
					if (chr > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(4)) == int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_WHITESPACE):
				{
					if (chr < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(1)) != int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_NOT_WHITESPACE):
				{
					if (chr > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(1)) == int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_WORDCHAR):
				{
					if (chr < pcre_uint32((uint32(int32(255))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(16)) != int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_NOT_WORDCHAR):
				{
					if (chr > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((chr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(16)) == int32(0)) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_HSPACE):
				{
					switch pcre_uint32(chr) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
							return BOOL((int32(0)))
						}
					default:
						{
							break
						}
					}
				}
			case pcre_uint32(OP_NOT_HSPACE):
				{
					switch pcre_uint32(chr) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
						}
					default:
						{
							return BOOL((int32(0)))
						}
					}
				}
			case pcre_uint32(OP_ANYNL):
				fallthrough
			case pcre_uint32(OP_VSPACE):
				{
					switch pcre_uint32(chr) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							return BOOL((int32(0)))
						}
					default:
						{
							break
						}
					}
				}
			case pcre_uint32(OP_NOT_VSPACE):
				{
					switch pcre_uint32(chr) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
						}
					default:
						{
							return BOOL((int32(0)))
						}
					}
				}
			case pcre_uint32(OP_DOLL):
				fallthrough
			case pcre_uint32(OP_EODN):
				{
					switch pcre_uint32(chr) {
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							return BOOL((int32(0)))
						}
					}
				}
			case pcre_uint32(OP_EOD):
				{
				}
			case pcre_uint32(OP_PROP):
				fallthrough
			case pcre_uint32(OP_NOTPROP):
				{
					if int32((NotBOOL(check_char_prop(pcre_uint32(chr), uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr)))))), uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*list_ptr)))))), BOOL((map[bool]int32{false: 0, true: 1}[(*list_ptr == pcre_uint32((uint32(OP_NOTPROP))))])))))) != 0 {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_NCLASS):
				{
					if chr > pcre_uint32((uint32(int32(255)))) {
						return BOOL((int32(0)))
					}
				}
				fallthrough
			case pcre_uint32(OP_CLASS):
				{
					if chr > pcre_uint32((uint32(int32(255)))) {
						break
					}
					class_bitset = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := func() *pcre_uchar {
							if int64(uintptr(unsafe.Pointer(list_ptr))) == int64(uintptr(unsafe.Pointer(&list[0]))) {
								return code
							} else {
								return base_end
							}
						}()
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))))))*unsafe.Sizeof(*tempVar))
					}()))))
					if (int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(class_bitset)) + (uintptr)(int32(uint32((chr>>uint64(int32(3))))))*unsafe.Sizeof(*class_bitset))))))) & (int32(1) << uint64(uint32((chr & pcre_uint32((uint32(int32(7))))))))) != int32(0) {
						return BOOL((int32(0)))
					}
				}
			case pcre_uint32(OP_XCLASS):
				{
					if int32((_pcre_xclass(pcre_uint32(chr), ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := func() *pcre_uchar {
								if int64(uintptr(unsafe.Pointer(list_ptr))) == int64(uintptr(unsafe.Pointer(&list[0]))) {
									return code
								} else {
									return base_end
								}
							}()
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(list_ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*list_ptr))))))))*unsafe.Sizeof(*tempVar))
						}()))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}())), BOOL(utf)))) != 0 {
						return BOOL((int32(0)))
					}
				}
			default:
				{
					return BOOL((int32(0)))
				}
			}
			chr_ptr = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(chr_ptr)) + (uintptr)(1)*unsafe.Sizeof(*chr_ptr))))
			if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(*chr_ptr != pcre_uint32((uint32(4294967295))))])) != 0 {
				break
			}
		}
		if *((*pcre_uint32)(func() unsafe.Pointer {
			tempVar := &list[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
		}())) == pcre_uint32((uint32(int32(0)))) {
			return BOOL((int32(1)))
		}
	}
	return
}

// auto_possessify - transpiled function from  /root/Documents/pcre/pcre_compile.c:3659
/*************************************************
*    Scan compiled regex for auto-possession     *
*************************************************/ //
/* Replaces single character iterations with their possessive alternatives
if appropriate. This function modifies the compiled opcode!

Arguments:
  code        points to start of the byte code
  utf         TRUE in UTF-8 / UTF-16 / UTF-32 mode
  cd          static compile data

Returns:      nothing
*/ //
/* When a pattern with bad UTF-8 encoding is compiled with NO_UTF_CHECK,
it may compile without complaining, but may get into a loop here if the code
pointer points to a bad value. This is, of course a documentated possibility,
when NO_UTF_CHECK is set, so it isn't a bug, but we can detect this case and
just give up on this optimization. */ //
/* end must not be NULL. */ //
/* Add in the fixed length from the table */ //
/* In UTF-8 mode, opcodes that are followed by a character may be followed by
a multi-byte character. The length in the table is a minimum, so we have to
arrange to skip the extra bytes. */ //
//
func auto_possessify(code *pcre_uchar, utf BOOL, cd *compile_data) {
	var c pcre_uchar
	var end *pcre_uchar
	var repeat_opcode *pcre_uchar
	var list []pcre_uint32 = make([]pcre_uint32, 8, 8)
	var rec_limit int32
	for {
		c = *code
		if int32(uint8((c))) >= OP_TABLE_LENGTH {
			return
		}
		if (int32(uint8((c))) >= OP_STAR) && (int32(uint8((c))) <= OP_TYPEPOSUPTO) {
			c -= pcre_uchar((uint8((int32(uint8((get_repeat_base(pcre_uchar(c))))) - OP_STAR))))
			end = func() *pcre_uchar {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((c))) <= OP_MINUPTO)]) != 0 {
					return get_chr_property_list(code, BOOL(utf), (*cd).fcc, &list[0])
				} else {
					return nil
				}
			}()
			*((*pcre_uint32)(func() unsafe.Pointer {
				tempVar := &list[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) = pcre_uint32((uint32(map[bool]int32{false: 0, true: 1}[((((int32(uint8((c))) == OP_STAR) || (int32(uint8((c))) == OP_PLUS)) || (int32(uint8((c))) == OP_QUERY)) || (int32(uint8((c))) == OP_UPTO))])))
			rec_limit = int32(1000)
			if (end != nil) && (int32((compare_opcodes(end, BOOL(utf), cd, &list[0], end, &rec_limit))) != 0) {
				switch int32(uint8((pcre_uchar(c)))) {
				case OP_STAR:
					{
						*code += pcre_uchar((uint8((OP_POSSTAR - OP_STAR))))
					}
				case OP_MINSTAR:
					{
						*code += pcre_uchar((uint8((OP_POSSTAR - OP_MINSTAR))))
					}
				case OP_PLUS:
					{
						*code += pcre_uchar((uint8((OP_POSPLUS - OP_PLUS))))
					}
				case OP_MINPLUS:
					{
						*code += pcre_uchar((uint8((OP_POSPLUS - OP_MINPLUS))))
					}
				case OP_QUERY:
					{
						*code += pcre_uchar((uint8((OP_POSQUERY - OP_QUERY))))
					}
				case OP_MINQUERY:
					{
						*code += pcre_uchar((uint8((OP_POSQUERY - OP_MINQUERY))))
					}
				case OP_UPTO:
					{
						*code += pcre_uchar((uint8((OP_POSUPTO - OP_UPTO))))
					}
				case OP_MINUPTO:
					{
						*code += pcre_uchar((uint8((OP_POSUPTO - OP_MINUPTO))))
						break
					}
				}
			}
			c = *code
		} else if ((int32(uint8((c))) == OP_CLASS) || (int32(uint8((c))) == OP_NCLASS)) || (int32(uint8((c))) == OP_XCLASS) {
			if int32(uint8((c))) == OP_XCLASS {
				repeat_opcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
			} else {
				repeat_opcode = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*tempVar))
				}()))
			}
			c = *repeat_opcode
			if (int32(uint8((c))) >= OP_CRSTAR) && (int32(uint8((c))) <= OP_CRMINRANGE) {
				end = get_chr_property_list(code, BOOL(utf), (*cd).fcc, &list[0])
				*((*pcre_uint32)(func() unsafe.Pointer {
					tempVar := &list[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
				}())) = pcre_uint32((uint32(map[bool]int32{false: 0, true: 1}[((int32(uint8((c))) & int32(1)) == int32(0))])))
				rec_limit = int32(1000)
				if int32((compare_opcodes(end, BOOL(utf), cd, &list[0], end, &rec_limit))) != 0 {
					switch int32(uint8((pcre_uchar(c)))) {
					case OP_CRSTAR:
						fallthrough
					case OP_CRMINSTAR:
						{
							*repeat_opcode = pcre_uchar((uint8(OP_CRPOSSTAR)))
						}
					case OP_CRPLUS:
						fallthrough
					case OP_CRMINPLUS:
						{
							*repeat_opcode = pcre_uchar((uint8(OP_CRPOSPLUS)))
						}
					case OP_CRQUERY:
						fallthrough
					case OP_CRMINQUERY:
						{
							*repeat_opcode = pcre_uchar((uint8(OP_CRPOSQUERY)))
						}
					case OP_CRRANGE:
						fallthrough
					case OP_CRMINRANGE:
						{
							*repeat_opcode = pcre_uchar((uint8(OP_CRPOSRANGE)))
							break
						}
					}
				}
			}
			c = *code
		}
		switch int32(uint8((pcre_uchar(c)))) {
		case OP_END:
			{
				return
			}
		case OP_TYPESTAR:
			fallthrough
		case OP_TYPEMINSTAR:
			fallthrough
		case OP_TYPEPLUS:
			fallthrough
		case OP_TYPEMINPLUS:
			fallthrough
		case OP_TYPEQUERY:
			fallthrough
		case OP_TYPEMINQUERY:
			fallthrough
		case OP_TYPEPOSSTAR:
			fallthrough
		case OP_TYPEPOSPLUS:
			fallthrough
		case OP_TYPEPOSQUERY:
			{
				if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				}
			}
		case OP_TYPEUPTO:
			fallthrough
		case OP_TYPEMINUPTO:
			fallthrough
		case OP_TYPEEXACT:
			fallthrough
		case OP_TYPEPOSUPTO:
			{
				if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))))) == OP_NOTPROP) {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				}
			}
		case OP_XCLASS:
			{
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
			}
		case OP_MARK:
			fallthrough
		case OP_PRUNE_ARG:
			fallthrough
		case OP_SKIP_ARG:
			fallthrough
		case OP_THEN_ARG:
			{
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*code))))
				break
			}
		}
		code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &_pcre_OP_lengths[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((c))))*unsafe.Sizeof(*tempVar))
		}()))))))*unsafe.Sizeof(*code))))
		if int32((BOOL(utf))) != 0 {
			switch int32(uint8((pcre_uchar(c)))) {
			case OP_CHAR:
				fallthrough
			case OP_CHARI:
				fallthrough
			case OP_NOT:
				fallthrough
			case OP_NOTI:
				fallthrough
			case OP_STAR:
				fallthrough
			case OP_MINSTAR:
				fallthrough
			case OP_PLUS:
				fallthrough
			case OP_MINPLUS:
				fallthrough
			case OP_QUERY:
				fallthrough
			case OP_MINQUERY:
				fallthrough
			case OP_UPTO:
				fallthrough
			case OP_MINUPTO:
				fallthrough
			case OP_EXACT:
				fallthrough
			case OP_POSSTAR:
				fallthrough
			case OP_POSPLUS:
				fallthrough
			case OP_POSQUERY:
				fallthrough
			case OP_POSUPTO:
				fallthrough
			case OP_STARI:
				fallthrough
			case OP_MINSTARI:
				fallthrough
			case OP_PLUSI:
				fallthrough
			case OP_MINPLUSI:
				fallthrough
			case OP_QUERYI:
				fallthrough
			case OP_MINQUERYI:
				fallthrough
			case OP_UPTOI:
				fallthrough
			case OP_MINUPTOI:
				fallthrough
			case OP_EXACTI:
				fallthrough
			case OP_POSSTARI:
				fallthrough
			case OP_POSPLUSI:
				fallthrough
			case OP_POSQUERYI:
				fallthrough
			case OP_POSUPTOI:
				fallthrough
			case OP_NOTSTAR:
				fallthrough
			case OP_NOTMINSTAR:
				fallthrough
			case OP_NOTPLUS:
				fallthrough
			case OP_NOTMINPLUS:
				fallthrough
			case OP_NOTQUERY:
				fallthrough
			case OP_NOTMINQUERY:
				fallthrough
			case OP_NOTUPTO:
				fallthrough
			case OP_NOTMINUPTO:
				fallthrough
			case OP_NOTEXACT:
				fallthrough
			case OP_NOTPOSSTAR:
				fallthrough
			case OP_NOTPOSPLUS:
				fallthrough
			case OP_NOTPOSQUERY:
				fallthrough
			case OP_NOTPOSUPTO:
				fallthrough
			case OP_NOTSTARI:
				fallthrough
			case OP_NOTMINSTARI:
				fallthrough
			case OP_NOTPLUSI:
				fallthrough
			case OP_NOTMINPLUSI:
				fallthrough
			case OP_NOTQUERYI:
				fallthrough
			case OP_NOTMINQUERYI:
				fallthrough
			case OP_NOTUPTOI:
				fallthrough
			case OP_NOTMINUPTOI:
				fallthrough
			case OP_NOTEXACTI:
				fallthrough
			case OP_NOTPOSSTARI:
				fallthrough
			case OP_NOTPOSPLUSI:
				fallthrough
			case OP_NOTPOSQUERYI:
				fallthrough
			case OP_NOTPOSUPTOI:
				{
					if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code))))))) >= int32(192))]) != 0 {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_utf8_table4[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*code))))
					}
					break
				}
			}
		}
	}
}

// check_posix_syntax - transpiled function from  /root/Documents/pcre/pcre_compile.c:3933
/*************************************************
*           Check for POSIX class syntax         *
*************************************************/ //
/* This function is called when the sequence "[:" or "[." or "[=" is
encountered in a character class. It checks whether this is followed by a
sequence of characters terminated by a matching ":]" or ".]" or "=]". If we
reach an unescaped ']' without the special preceding character, return FALSE.

Originally, this function only recognized a sequence of letters between the
terminators, but it seems that Perl recognizes any sequence of characters,
though of course unknown POSIX names are subsequently rejected. Perl gives an
"Unknown POSIX class" error for [:f\oo:] for example, where previously PCRE
didn't consider this to be a POSIX class. Likewise for [:1234:].

The problem in trying to be exactly like Perl is in the handling of escapes. We
have to be sure that [abc[:x\]pqr] is *not* treated as containing a POSIX
class, but [abc[:x\]pqr:]] is (so that an error can be generated). The code
below handles the special cases \\ and \], but does not try to do any other
escape processing. This makes it different from Perl for cases such as
[:l\ower:] where Perl recognizes it as the POSIX class "lower" but PCRE does
not recognize "l\ower". This is a lesser evil than not diagnosing bad classes
when Perl does, I think.

A user pointed out that PCRE was rejecting [:a[:digit:]] whereas Perl was not.
It seems that the appearance of a nested POSIX class supersedes an apparent
external class. For example, [:a[:digit:]b:] matches "a", "b", ":", or
a digit.

In Perl, unescaped square brackets may also appear as part of class names. For
example, [:a[:abc]b:] gives unknown POSIX class "[:abc]b:]". However, for
[:a[:abc]b][b:] it gives unknown POSIX class "[:abc]b][b:]", which does not
seem right at all. PCRE does not allow closing square brackets in POSIX class
names.

Arguments:
  ptr      pointer to the initial [
  endptr   where to return the end pointer

Returns:   TRUE or FALSE
*/ //
/* Don't combine these lines; the Solaris cc */ //
/* compiler warns about "non-constant" initializer. */ //
//
func check_posix_syntax(ptr *pcre_uchar, endptr **pcre_uchar) BOOL {
	var terminator pcre_uchar
	terminator = *func() *pcre_uchar {
		ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
		return ptr
	}()
	for ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr)))); int32(uint8((*ptr))) != int32('\x00'); ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr)))) {
		if (int32(uint8((*ptr))) == int32('\\')) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(']')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\\'))) {
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
		} else if ((int32(uint8((*ptr))) == int32('[')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(uint8((terminator))))) || (int32(uint8((*ptr))) == int32(']')) {
			return BOOL((int32(0)))
		} else if (int32(uint8((*ptr))) == int32(uint8((terminator)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(']')) {
			*endptr = ptr
			return BOOL((int32(1)))
		}
	}
	return BOOL((int32(0)))
}

// check_posix_name - transpiled function from  /root/Documents/pcre/pcre_compile.c:3972
/*************************************************
*          Check POSIX class name                *
*************************************************/ //
/* This function is called to check the name given in a POSIX-style class entry
such as [:alnum:].

Arguments:
  ptr        points to the first letter
  len        the length of the name

Returns:     a value representing the name, or -1 if unknown
*/ //
//
func check_posix_name(ptr *pcre_uchar, len int32) int32 {
	var pn *byte = &posix_names[0]
	var yield int32 = int32(0)
	for int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := &posix_name_lengths[0]
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(yield)*unsafe.Sizeof(*tempVar))
	}()))))) != int32(0) {
		if (len == int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &posix_name_lengths[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(yield)*unsafe.Sizeof(*tempVar))
		}())))))) && (noarch.Strncmp((*byte)(unsafe.Pointer((ptr))), (pn), int32((uint32(len)))) == int32(0)) {
			return yield
		}
		pn = ((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(pn)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &posix_name_lengths[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(yield)*unsafe.Sizeof(*tempVar))
		}())))))+int32(1)))*unsafe.Sizeof(*pn))))
		yield += 1
	}
	return -int32(1)
}

// adjust_recurse - transpiled function from  /root/Documents/pcre/pcre_compile.c:4020
/*************************************************
*    Adjust OP_RECURSE items in repeated group   *
*************************************************/ //
/* OP_RECURSE items contain an offset from the start of the regex to the group
that is referenced. This means that groups can be replicated for fixed
repetition simply by copying (because the recursion is allowed to refer to
earlier groups that are outside the current group). However, when a group is
optional (i.e. the minimum quantifier is zero), OP_BRAZERO or OP_SKIPZERO is
inserted before it, after it has been compiled. This means that any OP_RECURSE
items within it that refer to the group itself or any contained groups have to
have their offsets adjusted. That one of the jobs of this function. Before it
is called, the partially compiled regex must be temporarily terminated with
OP_END.

This function has been extended to cope with forward references for recursions
and subroutine calls. It must check the list of such references for the
group we are dealing with. If it finds that one of the recursions in the
current group is on this list, it does not adjust the value in the reference
(which is a group number). After the group has been scanned, all the offsets in
the forward reference list for the group are adjusted.

Arguments:
  group      points to the start of the group
  adjust     the amount by which the group is to be moved
  utf        TRUE in UTF-8 / UTF-16 / UTF-32 mode
  cd         contains pointers to tables etc.
  save_hwm_offset   the hwm forward reference offset at the start of the group

Returns:     nothing
*/ //
/* If we have not found this recursion on the forward reference list, adjust
the recursion's offset if it's after the start of this group. */ //
/* Now adjust all forward reference offsets for the group. */ //
//
func adjust_recurse(group *pcre_uchar, adjust int32, utf BOOL, cd *compile_data, save_hwm_offset size_t) {
	var offset int32
	var hc *pcre_uchar
	var ptr *pcre_uchar = group
	for (func() *pcre_uchar {
		tempVar := find_recurse(ptr, BOOL(utf))
		ptr = tempVar
		return tempVar
	}()) != nil {
		for hc = ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*cd).start_workspace
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((save_hwm_offset))))*unsafe.Sizeof(*tempVar))
		}())); int64(uintptr(unsafe.Pointer(hc))) < int64(uintptr(unsafe.Pointer((*cd).hwm))); hc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)(int32(2))*unsafe.Sizeof(*hc)))) {
			offset = ((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc)))))))))
			if int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*cd).start_code
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
			}()))))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) {
				break
			}
		}
		if int64(uintptr(unsafe.Pointer(hc))) >= int64(uintptr(unsafe.Pointer((*cd).hwm))) {
			offset = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ptr))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ptr)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ptr))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ptr)))))))))
			if int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*cd).start_code
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
			}()))))) >= int64(uintptr(unsafe.Pointer(group))) {
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr)))) = pcre_uchar((uint8(((offset + adjust) >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*ptr)))) = pcre_uchar((uint8(((offset + adjust) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*ptr))))
				}()
			}
		}
		ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ptr))))
	}
	for hc = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*cd).start_workspace
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((save_hwm_offset))))*unsafe.Sizeof(*tempVar))
	}())); int64(uintptr(unsafe.Pointer(hc))) < int64(uintptr(unsafe.Pointer((*cd).hwm))); hc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)(int32(2))*unsafe.Sizeof(*hc)))) {
		offset = ((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc)))))))))
		func() pcre_uchar {
			*hc = pcre_uchar((uint8(((offset + adjust) >> uint64(int32(8))))))
			return *hc
		}()
		func() pcre_uchar {
			*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*hc)))) = pcre_uchar((uint8(((offset + adjust) & int32(255)))))
			return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*hc))))
		}()
	}
}

// auto_callout - transpiled function from  /root/Documents/pcre/pcre_compile.c:4076
/*************************************************
*        Insert an automatic callout point       *
*************************************************/ //
/* This function is called when the PCRE_AUTO_CALLOUT option is set, to insert
callout points before each pattern item.

Arguments:
  code           current code pointer
  ptr            current pattern pointer
  cd             pointers to tables etc

Returns:         new code pointer
*/ //
/* Pattern offset */ //
/* Default length */ //
//
func auto_callout(code *pcre_uchar, ptr *pcre_uchar, cd *compile_data) *pcre_uchar {
	*func() *pcre_uchar {
		defer func() {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
		}()
		return code
	}() = pcre_uchar((uint8(OP_CALLOUT)))
	*func() *pcre_uchar {
		defer func() {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
		}()
		return code
	}() = pcre_uchar(int32(255))
	func() pcre_uchar {
		*code = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*cd).start_pattern)))))) >> uint64(int32(8))))))
		return *code
	}()
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*cd).start_pattern)))))) & int32(255)))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
	}()
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) >> uint64(int32(8))))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
	}()
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) & int32(255)))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code))))
	}()
	return ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)*int32(2)))*unsafe.Sizeof(*code))))
}

// complete_callout - transpiled function from  /root/Documents/pcre/pcre_compile.c:4104
/*************************************************
*         Complete a callout item                *
*************************************************/ //
/* A callout item contains the length of the next item in the pattern, which
we can't fill in till after we have reached the relevant point. This is used
for both automatic and manual callouts.

Arguments:
  previous_callout   points to previous callout item
  ptr                current pattern pointer
  cd                 pointers to tables etc

Returns:             nothing
*/ //
//
func complete_callout(previous_callout *pcre_uchar, ptr *pcre_uchar, cd *compile_data) {
	var length int32 = (int32(((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*cd).start_pattern)))) - int64(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((previous_callout))) + (uintptr)(int32(2))*unsafe.Sizeof(*(previous_callout)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((previous_callout))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(previous_callout)))))))))))))
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous_callout)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*previous_callout)))) = pcre_uchar((uint8((length >> uint64(int32(8))))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous_callout)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*previous_callout))))
	}()
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous_callout)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*previous_callout)))) = pcre_uchar((uint8((length & int32(255)))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous_callout)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*previous_callout))))
	}()
}

// get_othercase_range - transpiled function from  /root/Documents/pcre/pcre_compile.c:4136
/*************************************************
*           Get othercase range                  *
*************************************************/ //
/* This function is passed the start and end of a class range, in UTF-8 mode
with UCP support. It searches up the characters, looking for ranges of
characters in the "other" case. Each call returns the next one, updating the
start address. A character with multiple other cases is returned on its own
with a special return value.

Arguments:
  cptr        points to starting character value; updated
  d           end value
  ocptr       where to put start of othercase range
  odptr       where to put end of othercase range

Yield:        -1 when no more
               0 when a range is returned
              >0 the CASESET offset for char with multiple other cases
                in this case, ocptr contains the original
*/ //
/* Find the first character that has an other case. If it has multiple other
cases, return its case offset value. */ //
/* Character that has the set */ //
/* Rest of input range */ //
/* Reached end of range */ //
/* Found a character that has a single other case. Search for the end of the
range, which is either the end of the input range, or a character that has zero
or more than one other cases. */ //
/* End of othercase range */ //
/* Rest of input range */ //
//
func get_othercase_range(cptr *pcre_uint32, d pcre_uint32, ocptr *pcre_uint32, odptr *pcre_uint32) int32 {
	var c pcre_uint32
	var othercase pcre_uint32
	var next pcre_uint32
	var co uint32
	for c = *cptr; c <= d; c++ {
		if (func() uint32 {
			tempVar := uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_records[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
					}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*tempVar))
			}()))).caseset))))
			co = tempVar
			return tempVar
		}()) != uint32(int32(0)) {
			*ocptr = func() pcre_uint32 {
				defer func() {
					c += 1
				}()
				return c
			}()
			*cptr = c
			return int32(co)
		}
		if (func() pcre_uint32 {
			tempVar := pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_records[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
					}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*tempVar))
			}()))).other_case))))))
			othercase = tempVar
			return tempVar
		}()) != c {
			break
		}
	}
	if c > d {
		return -int32(1)
	}
	*ocptr = othercase
	next = (othercase + pcre_uint32((uint32(int32(1)))))
	for c += 1; c <= d; c++ {
		if ((func() uint32 {
			tempVar := uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_records[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
					}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*tempVar))
			}()))).caseset))))
			co = tempVar
			return tempVar
		}()) != uint32(int32(0))) || (pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
			tempVar := &_pcre_ucd_records[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_stage2[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage1[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
				}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*tempVar))
		}()))).other_case)))))) != next) {
			break
		}
		next += 1
	}
	*odptr = (next - pcre_uint32((uint32(int32(1)))))
	*cptr = c
	return int32(0)
}

// add_to_class - transpiled function from  /root/Documents/pcre/pcre_compile.c:4201
/*************************************************
*        Add a character or range to a class     *
*************************************************/ //
/* This function packages up the logic of adding a character or range of
characters to a class. The character values in the arguments will be within the
valid values for the current mode (8-bit, 16-bit, UTF, etc). This function is
mutually recursive with the function immediately below.

Arguments:
  classbits     the bit map for characters < 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cd            contains pointers to tables etc.
  start         start of range character
  end           end of range character

Returns:        the number of < 256 characters added
                the pointer to extra data is updated
*/ //
/* If caseless matching is required, scan the range and process alternate
cases. In Unicode, there are 8-bit characters that have alternate cases that
are greater than 255 and vice-versa. Sometimes we can just extend the original
range. */ //
/* Remove for recursive calls */ //
/* Handle a single character that has more than one other case. */ //
/* Do nothing if the other case range is within the original range. */ //
/* Extend the original range if there is overlap, noting that if oc < c, we
   can't have od > end because a subrange is always shorter than the basic
   range. Otherwise, use a recursive call to add the additional range. */ //
/* Extend downwards */ //
/* Extend upwards */ //
/* Not UTF-mode, or no UCP */ //
/* Now handle the original range. Adjust the final value according to the bit
length - this means that the same lists of (e.g.) horizontal spaces can be used
in all cases. */ //
/* Use the bitmap for characters < 256. Otherwise use extra data.*/ //
/* Regardless of start, c will always be <= 255. */ //
/* All UTFs use the same flag bit */ //
/* Without UTF support, character values are constrained by the bit length,
and can only be > 256 for 16-bit and 32-bit libraries. */ //
/* Updata extra data pointer */ //
/* Number of 8-bit characters */ //
//
func add_to_class(classbits *pcre_uint8, uchardptr **pcre_uchar, options int32, cd *compile_data, start pcre_uint32, end pcre_uint32) int32 {
	var c pcre_uint32
	var classbits_end pcre_uint32 = pcre_uint32((func() uint32 {
		if end <= pcre_uint32((uint32(int32(255)))) {
			return uint32((pcre_uint32(end)))
		} else {
			return uint32(int32(255))
		}
	}()))
	var n8 int32 = int32(0)
	if (options & int32(1)) != int32(0) {
		if (options & int32(2048)) != int32(0) {
			var rc int32
			var oc pcre_uint32
			var od pcre_uint32
			options &= ^int32(1)
			c = start
			for (func() int32 {
				tempVar := get_othercase_range(&c, pcre_uint32(end), &oc, &od)
				rc = tempVar
				return tempVar
			}()) >= int32(0) {
				if rc > int32(0) {
					n8 += add_list_to_class(classbits, uchardptr, options, cd, ((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_caseless_sets[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(rc)*unsafe.Sizeof(*tempVar))
					}())), uint32((pcre_uint32(oc))))
				} else if (oc >= start) && (od <= end) {
					continue
				} else if (oc < start) && (od >= (start - pcre_uint32((uint32(int32(1)))))) {
					start = oc
				} else if (od > end) && (oc <= (end + pcre_uint32((uint32(int32(1)))))) {
					end = od
					if end > classbits_end {
						classbits_end = pcre_uint32((func() uint32 {
							if end <= pcre_uint32((uint32(int32(255)))) {
								return uint32((pcre_uint32(end)))
							} else {
								return uint32(int32(255))
							}
						}()))
					}
				} else {
					n8 += add_to_class(classbits, uchardptr, options, cd, pcre_uint32(oc), pcre_uint32(od))
				}
			}
		} else {
			for c = start; c <= classbits_end; c++ {
				*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(classbits)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := (*cd).fcc
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
				}())))))/int32(8)))*unsafe.Sizeof(*classbits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := (*cd).fcc
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
				}()))))) & int32(7)))))))
				n8 += 1
			}
		}
	}
	if (options & int32(2048)) == int32(0) {
		if end > pcre_uint32((uint32(int32(255)))) {
			end = pcre_uint32(int32(255))
		}
	}
	for c = start; c <= classbits_end; c++ {
		*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(classbits)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*classbits)))) |= pcre_uint8((uint8((int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7)))))))))))
		n8 += 1
	}
	if start <= pcre_uint32((uint32(int32(255)))) {
		start = pcre_uint32((uint32((int32(255) + int32(1)))))
	}
	if end >= start {
		var uchardata *pcre_uchar = *uchardptr
		if (options & int32(2048)) != int32(0) {
			if start < end {
				*func() *pcre_uchar {
					defer func() {
						uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(uchardata)) + (uintptr)(1)*unsafe.Sizeof(*uchardata))))
					}()
					return uchardata
				}() = pcre_uchar(int32(2))
				uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(start), uchardata)))*unsafe.Sizeof(*uchardata))))
				uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(end), uchardata)))*unsafe.Sizeof(*uchardata))))
			} else if start == end {
				*func() *pcre_uchar {
					defer func() {
						uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(uchardata)) + (uintptr)(1)*unsafe.Sizeof(*uchardata))))
					}()
					return uchardata
				}() = pcre_uchar(int32(1))
				uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(start), uchardata)))*unsafe.Sizeof(*uchardata))))
			}
		} else {
		}
		*uchardptr = uchardata
	}
	return n8
}

// add_list_to_class - transpiled function from  /root/Documents/pcre/pcre_compile.c:4365
/*************************************************
*        Add a list of characters to a class     *
*************************************************/ //
/* This function is used for adding a list of case-equivalent characters to a
class, and also for adding a list of horizontal or vertical whitespace. If the
list is in order (which it should be), ranges of characters are detected and
handled appropriately. This function is mutually recursive with the function
above.

Arguments:
  classbits     the bit map for characters < 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cd            contains pointers to tables etc.
  p             points to row of 32-bit values, terminated by NOTACHAR
  except        character to omit; this is used when adding lists of
                  case-equivalent characters to avoid including the one we
                  already know about

Returns:        the number of < 256 characters added
                the pointer to extra data is updated
*/ //
//
func add_list_to_class(classbits *pcre_uint8, uchardptr **pcre_uchar, options int32, cd *compile_data, p *pcre_uint32, except uint32) int32 {
	var n8 int32 = int32(0)
	for *p < pcre_uint32((uint32(4294967295))) {
		var n int32 = int32(0)
		if *p != pcre_uint32((except)) {
			for *((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((n+int32(1)))*unsafe.Sizeof(*p)))) == ((*p + pcre_uint32((uint32(n)))) + pcre_uint32((uint32(int32(1))))) {
				n += 1
			}
			n8 += add_to_class(classbits, uchardptr, options, cd, pcre_uint32(*p), pcre_uint32(*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(n)*unsafe.Sizeof(*p))))))
		}
		p = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((n+int32(1)))*unsafe.Sizeof(*p))))
	}
	return n8
}

// add_not_list_to_class - transpiled function from  /root/Documents/pcre/pcre_compile.c:4403
/*************************************************
*    Add characters not in a list to a class     *
*************************************************/ //
/* This function is used for adding the complement of a list of horizontal or
vertical whitespace to a class. The list must be in order.

Arguments:
  classbits     the bit map for characters < 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cd            contains pointers to tables etc.
  p             points to row of 32-bit values, terminated by NOTACHAR

Returns:        the number of < 256 characters added
                the pointer to extra data is updated
*/ //
//
func add_not_list_to_class(classbits *pcre_uint8, uchardptr **pcre_uchar, options int32, cd *compile_data, p *pcre_uint32) int32 {
	var utf BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))]))
	var n8 int32 = int32(0)
	if *p > pcre_uint32((uint32(int32(0)))) {
		n8 += add_to_class(classbits, uchardptr, options, cd, pcre_uint32(int32(0)), (*p - pcre_uint32((uint32(int32(1))))))
	}
	for *p < pcre_uint32((uint32(4294967295))) {
		for *((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p)))) == (*p + pcre_uint32((uint32(int32(1))))) {
			p = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
		}
		n8 += add_to_class(classbits, uchardptr, options, cd, (*p + pcre_uint32((uint32(int32(1))))), pcre_uint32((func() uint32 {
			if (map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p)))) == pcre_uint32((uint32(4294967295))))]) != 0 {
				return (func() uint32 {
					if int32((BOOL(utf))) != 0 {
						return uint32(1114111)
					} else {
						return uint32(4294967295)
					}
				}())
			} else {
				return uint32((*((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p)))) - pcre_uint32((uint32(int32(1))))))
			}
		}())))
		p = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
	}
	return n8
}

// compile_branch - transpiled function from  /root/Documents/pcre/pcre_compile.c:4452
/*************************************************
*           Compile one branch                   *
*************************************************/ //
/* Scan the pattern, compiling it into the a vector. If the options are
changed during the branch, the pointer is used to change the external options
bits. This function is used during the pre-compile phase when we are trying
to find out the amount of memory needed, as well as during the real compile
phase. The value of lengthptr distinguishes the two phases.

Arguments:
  optionsptr        pointer to the option bits
  codeptr           points to the pointer to the current code point
  ptrptr            points to the current pattern pointer
  errorcodeptr      points to error code variable
  firstcharptr      place to put the first required character
  firstcharflagsptr place to put the first character flags, or a negative number
  reqcharptr        place to put the last required character
  reqcharflagsptr   place to put the last required character flags, or a negative number
  bcptr             points to current branch chain
  cond_depth        conditional nesting depth
  cd                contains pointers to tables etc.
  lengthptr         NULL during the real compile phase
                    points to length accumulator during pre-compile phase

Returns:            TRUE on success
                    FALSE, with *errorcodeptr set non-zero on error
*/ //
/* To please picky compilers */ //
/* May change dynamically */ //
/* We can fish out the UTF-8 setting once and for all into a BOOL, but we
must not do this for other options (e.g. PCRE_EXTENDED) because they may change
dynamically as we process the pattern. */ //
/* PCRE_UTF[16|32] have the same value as PCRE_UTF8. */ //
/* Helper variables for OP_XCLASS opcode (for characters > 255). We define
class_uchardata always so that it can be passed to add_to_class() always,
though it will not be used in non-UTF 8-bit cases. This avoids having to supply
alternative calls for the different cases. */ //
/* Set up the default and non-default settings for greediness */ //
/* Initialize no first byte, no required byte. REQ_UNSET means "no char
matching encountered yet". It gets changed to REQ_NONE if we hit something that
matches a non-fixed char first char; reqchar just remains unset if we never
find one.

When we hit a repeat whose minimum is zero, we may have to adjust these values
to take the zero repeat into account. This is implemented by setting them to
zerofirstbyte and zeroreqchar when such a repeat is encountered. The individual
item types that can be repeated set these backoff variables appropriately. */ //
/* The variable req_caseopt contains either the REQ_CASELESS value
or zero, according to the current setting of the caseless flag. The
REQ_CASELESS leaves the lower 28 bit empty. It is added into the
firstchar or reqchar variables to record the case status of the
value. This is used only for ASCII characters. */ //
/* Switch on next character until the end of the branch */ //
/* Come here to restart the loop without advancing the pointer. */ //
/* Get next character in the pattern */ //
/* If we are at the end of a nested substitution, revert to the outer level
string. Nesting only happens one level deep. */ //
/* If we are in the pre-compile phase, accumulate the length used for the
previous cycle of this loop. */ //
/* Check for overrun */ //
/* There is at least one situation where code goes backwards: this is the
   case of a zero quantifier after a class (e.g. [ab]{0}). At compile time,
   the class is simply eliminated. However, it is created first, so we have to
   allow memory for it. Therefore, don't ever reduce the length at this point.
*/ //
/* Paranoid check for integer overflow */ //
/* If "previous" is set and it is not at the start of the work space, move
   it back to there, in order to avoid filling up the work space. Otherwise,
   if "previous" is NULL, reset the current code pointer to the start. */ //
/* Remember where this code item starts so we can pick up the length
   next time round. */ //
/* In the real compile phase, just check the workspace used by the forward
reference list. */ //
/* If in \Q...\E, check for the end; if not, we have a literal. Otherwise an
isolated \E is ignored. */ //
/* Don't attempt in pre-compile phase */ //
/* Check for the start of a \Q...\E sequence. We must do this here rather
   than later in case it is immediately followed by \E, which turns it into a
   "do nothing" sequence. */ //
/* In extended mode, skip white space and comments. */ //
/* For non-fixed-length newline cases, */ //
/* IS_NEWLINE sets cd->nllen. */ //
/* If we skipped any characters, restart the loop. Otherwise, we didn't see
   a comment. */ //
/* Skip over (?# comments. We need to do this here because we want to know if
the next thing is a quantifier, and these comments may come between an item
and its quantifier. */ //
/* See if the next thing is a quantifier. */ //
/* Fill in length of a previous callout, except when the next thing is a
quantifier or when processing a property substitution string in UCP mode. */ //
/* Don't attempt in pre-compile phase */ //
/* Create auto callout, except for quantifiers, or while processing property
strings that are substituted for \w etc in UCP mode. */ //
/* Process the next pattern item. */ //
/* ===================================================================*/ //
/* The branch terminates at string end */ //
/* or | or ) */ //
/* To include callout length */ //
/* ===================================================================*/ //
/* Handle single-character metacharacters. In multiline mode, ^ disables
   the setting of any following char as a first character. */ //
/* There can never be a first char if '.' is first, whatever happens about
   repeats. The value of reqchar doesn't change either. */ //
/* ===================================================================*/ //
/* Character classes. If the included characters are all < 256, we build a
   32-byte bitmap of the permitted characters, except in the special case
   where there is only one such character. For negated classes, we build the
   map as usual, then invert it at the end. However, we use a different opcode
   so that data characters > 255 can be handled correctly.

   If the class contains characters outside the 0-255 range, a different
   opcode is compiled. It may optionally have a bit map for characters < 256,
   but those above are are explicitly listed afterwards. A flag byte tells
   whether the bitmap is present, and whether this is a negated class or not.

   In JavaScript compatibility mode, an isolated ']' causes an error. In
   default (Perl) mode, it is treated as a data character. */ //
/* In another (POSIX) regex library, the ugly syntax [[:<:]] and [[:>:]] is
   used for "start of word" and "end of word". As these are otherwise illegal
   sequences, we don't break anything by recognizing them. They are replaced
   by \b(?=\w) and \b(?<=\w) respectively. Sequences like [a[:<:]] are
   erroneous and are handled by the normal code below. */ //
/* Handle a real character class. */ //
/* PCRE supports POSIX class stuff inside a class. Perl gives an error if
   they are encountered at the top level, so we'll do that too. */ //
/* If the first character is '^', set the negation flag and skip it. Also,
   if the first few characters (either before or after ^) are \Q\E or \E we
   skip them too. This makes for compatibility with Perl. */ //
/* Empty classes are allowed in JavaScript compatibility mode. Otherwise,
   an initial ']' is taken as a data character -- the code below handles
   that. In JS mode, [] must always fail, so generate OP_FAIL, whereas
   [^] must match any character, so generate OP_ALLANY. */ //
/* If a class contains a negative special such as \S, we need to flip the
   negation flag at the end, so that support for characters > 255 works
   correctly (they are all included in the class). */ //
/* Extended class (xclass) will be used when characters > 255
   might match. */ //
/* For XCLASS items */ //
/* Save the start */ //
/* For optimization purposes, we track some properties of the class:
   class_has_8bitchar will be non-zero if the class contains at least one <
   256 character; class_one_char will be 1 if the class contains just one
   character; xclass_has_prop will be TRUE if unicode property checks
   are present in the class. */ //
/* Initialize the 32-char bit map to all zeros. We build the map in a
   temporary bit of memory, in case the class contains fewer than two
   8-bit characters because in that case the compiled code doesn't use the bit
   map. */ //
/* Process characters until ] is reached. By writing this as a "do" it
   means that an initial ] is taken as a data character. At the start of the
   loop, c contains the first byte of the character. */ //
/* Braces are required because the */ //
/* macro generates multiple statements */ //
/* In the pre-compile phase, accumulate the length of any extra
   data and reset the pointer. This is so that very large classes that
   contain a zillion > 255 characters no longer overwrite the work space
   (which is on the stack). We have to remember that there was XCLASS data,
   however. */ //
/* Inside \Q...\E everything is literal except \E */ //
/* If we are at \E */ //
/* Reset literal state */ //
/* Skip the 'E' */ //
/* Carry on with next */ //
/* Could be range if \E follows */ //
/* Handle POSIX class names. Perl allows a negation extension of the
   form [:^name:]. A square bracket that doesn't match the syntax is
   treated as a literal. We also recognize the POSIX constructions
   [.ch.] and [=ch=] ("collating elements") and fault them, as Perl
   5.6 and 5.8 do. */ //
/* Note negative special */ //
/* If matching is caseless, upper and lower are converted to
   alpha. This relies on the fact that the class table starts with
   alpha, lower, upper as the first 3 entries. */ //
/* When PCRE_UCP is set, some of the POSIX classes are converted to
   different escape sequences that use Unicode properties \p or \P. Others
   that are not available via \p or \P generate XCL_PROP/XCL_NOTPROP
   directly. */ //
/* The posix_substitutes table specifies which POSIX classes can be
   converted to \p or \P items. */ //
/* There are three other classes that generate special property calls
   that are recognized only in an XCLASS. */ //
/* Fall through */ //
/* Fall through */ //
/* For the other POSIX classes (ascii, cntrl, xdigit) we are going
   to fall through to the non-UCP case and build a bit map for
   characters with code points less than 256. If we are in a negated
   POSIX class, characters with code points greater than 255 must
   either all match or all not match. In the special case where we
   have not yet generated any xclass data, and this is the final item
   in the overall class, we need do nothing: later on, the opcode
   OP_NCLASS will be used to indicate that characters greater than 255
   are acceptable. If we have already seen an xclass item or one may
   follow (we have to assume that it might if this is not the end of
   the class), explicitly list all wide codepoints, which will then
   either not match or match, depending on whether the class is or is
   not negated. */ //
/* In the non-UCP case, or when UCP makes no difference, we build the
   bit map for the POSIX class in a chunk of local store because we may be
   adding and subtracting from it, and we don't want to subtract bits that
   may be in the main map already. At the end we or the result into the
   bit map that is being built. */ //
/* Copy in the first table (always present) */ //
/* If there is a second table, add or remove it as required. */ //
/* Now see if we need to remove any special characters. An option
   value of 1 removes vertical space and 2 removes underscore. */ //
/* Add the POSIX table or its complement into the main table that is
   being built and we are done. */ //
/* Every class contains at least one < 256 character. */ //
/* Every class contains at least two characters. */ //
/* End of POSIX syntax handling */ //
/* Backslash may introduce a single character, or it may introduce one
   of the specials, which just set a flag. The sequence \b is a special
   case. Inside a class (and only there) it is treated as backspace. We
   assume that other escapes have more than one character in them, so
   speculatively set both class_has_8bitchar and class_one_char bigger
   than one. Unrecognized escapes fall through and are either treated
   as literal characters (by default), or are faulted if
   PCRE_EXTRA is set. */ //
/* \b is backspace in a class */ //
/* \N is not supported in a class */ //
/* Handle start of quoted string */ //
/* avoid empty string */ //
/* Ignore orphan \E */ //
/* Every class contains at least two < 256 characters. */ //
/* Every class contains at least two characters. */ //
/* These are the values given for \d etc */ //
/* when PCRE_UCP is set. We replace the */ //
/* escape sequence with an appropriate \p */ //
/* or \P to test Unicode properties instead */ //
/* of the default ASCII testing. */ //
/* Just before substitute */ //
/* Undo! */ //
/* Perl 5.004 onwards omitted VT from \s, but restored it at Perl
   5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
   previously set by something earlier in the character class.
   Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
   we could just adjust the appropriate bit. From PCRE 8.34 we no
   longer treat \s and \S specially. */ //
/* The rest apply in both UCP and non-UCP cases. */ //
/* Undo! */ //
/* Unrecognized escapes are faulted if PCRE is running in its
   strict mode. By default, for compatibility with Perl, they are
   treated as literals. */ //
/* Undo the speculative increase. */ //
/* Undo the speculative increase. */ //
/* Get the final character and fall through */ //
/* Fall through if the escape just defined a single character (c >= 0).
   This may be greater than 256. */ //
/* End of backslash handling */ //
/* A character may be followed by '-' to form a range. However, Perl does
   not permit ']' to be the end of the range. A '-' character at the end is
   treated as a literal. Perl ignores orphaned \E sequences entirely. The
   code for handling \Q and \E is messy. */ //
/* Remember if \r or \n were explicitly used */ //
/* Check for range */ //
/* If we hit \Q (not followed by \E) at this point, go into escaped
   mode. */ //
/* Minus (hyphen) at the end of a class is treated as a literal, so put
   back the pointer and jump to handle the character that preceded it. */ //
/* Otherwise, we have a potential range; pick up the next character */ //
/* Braces are required because the */ //
/* macro generates multiple statements */ //
/* Not UTF-8 mode */ //
/* The second part of a range can be a single-character escape
   sequence, but not any of the other escapes. Perl treats a hyphen as a
   literal in such circumstances. However, in Perl's warning mode, a
   warning is given, so PCRE now faults it as it is almost certainly a
   mistake on the user's part. */ //
/* 0 means a character was put into d; \b is backspace; any other
   special causes an error. */ //
/* A hyphen followed by a POSIX class is treated in the same way. */ //
/* Check that the two values are in the correct order. Optimize
   one-character ranges. */ //
/* A few lines below */ //
/* We have found a character range, so single character optimizations
   cannot be done anymore. Any value greater than 1 indicates that there
   is more than one character. */ //
/* Remember an explicit \r or \n, and add the range to the class. */ //
/* Go get the next char in the class */ //
/* Handle a single character - we can get here for a normal non-escape
   char, or after \ that introduces a single character or for an apparent
   range that isn't. Only the value 1 matters for class_one_char, so don't
   increase it if it is already 2 or more ... just in case there's a class
   with a zillion characters in it. */ //
/* If xclass_has_prop is false and class_one_char is 1, we have the first
   single character in the class, and there have been no prior ranges, or
   XCLASS items generated by escapes. If this is the final character in the
   class, we can optimize by turning the item into a 1-character OP_CHAR[I]
   if it's positive, or OP_NOT[I] if it's negative. In the positive case, it
   can cause firstchar to be set. Otherwise, there can be no first char if
   this item is first, whatever repeat count may follow. In the case of
   reqchar, save the previous value for reinstating. */ //
/* For caseless UTF-8 mode when UCP support is available, check
   whether this character has more than one other case. If so, generate
   a special OP_NOTPROP item instead of OP_NOTI. */ //
/* Char has only one other case, or UCP not available */ //
/* We are finished with this character class */ //
/* For a single, positive character, get the value into mcbuffer, and
   then we can handle this with the normal one-character code. */ //
/* End of 1-char optimization */ //
/* There is more than one character in the class, or an XCLASS item
   has been generated. Add this character to the class. */ //
/* Loop until ']' reached. This "while" is the end of the "do" far above.
   If we are at the end of an internal nested string, revert to the outer
   string. */ //
/* Check for missing terminating ']' */ //
/* We will need an XCLASS if data has been placed in class_uchardata. In
   the second phase this is a sufficient test. However, in the pre-compile
   phase, class_uchardata gets emptied to prevent workspace overflow, so it
   only if the very last character in the class needs XCLASS will it contain
   anything at this point. For this reason, xclass gets set TRUE above when
   uchar_classdata is emptied, and that's why this code is the way it is here
   instead of just doing a test on class_uchardata below. */ //
/* If this is the first thing in the branch, there can be no first char
   setting, whatever the repeat count. Any reqchar setting must remain
   unchanged after any kind of repeat. */ //
/* If there are characters with values > 255, we have to compile an
   extended class, with its own opcode, unless there was a negated special
   such as \S in the class, and PCRE_UCP is not set, because in that case all
   characters > 255 are in the class, so any that were explicitly given as
   well can be ignored. If (when there are explicit characters > 255 that must
   be listed) there are no characters < 256, we can omit the bitmap in the
   actual compiled code. */ //
/* For non-UCP wide characters, in a non-negative class containing \S or
   similar (should_flip_negation is set), all characters greater than 255
   must be in the class. */ //
/* Will always be utf in the 8-bit library */ //
/* Can only happen for the 16-bit & 32-bit libraries */ //
/* Marks the end of extra data */ //
/* If the map is required, move up the extra data to make room for it;
   otherwise just move the code pointer to the end of the extra data. */ //
/* Now fill in the complete length of the item */ //
/* End of class handling */ //
/* Even though any XCLASS list is now discarded, we must allow for
   its memory. */ //
/* If there are no characters > 255, or they are all to be included or
   excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the
   whole class was negated and whether there were negative specials such as \S
   (non-UCP) in the class. Then copy the 32-byte map into the code vector,
   negating it if necessary. */ //
/* Save time in the pre-compile phase */ //
/* ===================================================================*/ //
/* Various kinds of repeat; '{' is not necessarily a quantifier, but this
   has been tested above. */ //
/* Adjust for zero repeat */ //
/* Ditto */ //
/* Remember whether this is a variable length repeat */ //
/* Default single-char op codes */ //
/* Default not possessive quantifier */ //
/* Save start of previous item, in case we have to move it up in order to
   insert something before it. */ //
/* Before checking for a possessive quantifier, we must skip over
   whitespace and comments in extended mode because Perl allows white space at
   this point. */ //
/* For non-fixed-length newline cases, */ //
/* IS_NEWLINE sets cd->nllen. */ //
/* Loop for comment characters */ //
/* Loop for multiple comments */ //
/* Character before the next significant one. */ //
/* We also need to skip over (?# comments, which are not dependent on
   extended mode. */ //
/* If the next character is '+', we have a possessive quantifier. This
   implies greediness, whatever the setting of the PCRE_UNGREEDY option.
   If the next character is '?' this is a minimizing repeat, by default,
   but if PCRE_UNGREEDY is set, it works the other way round. We change the
   repeat type to the non-default. */ //
/* Force greedy */ //
/* If previous was a recursion call, wrap it in atomic brackets so that
   previous becomes the atomic group. All recursions were so wrapped in the
   past, but it no longer happens for non-repeated recursions. In fact, the
   repeated ones could be re-implemented independently so as not to need this,
   but for the moment we rely on the code for repeating groups. */ //
/* When actually compiling, we need to check whether this was a forward
   reference, and if so, adjust the offset. */ //
/* Now handle repetition for the different types of item. */ //
/* If previous was a character or negated character match, abolish the item
   and generate a repeat item instead. If a char item has a minimum of more
   than one, ensure that it is set in reqchar - it might not be if a sequence
   such as x{3} is the first thing in a branch because the x will have gone
   into firstchar instead.  */ //
/* Make compiler happy. */ //
/* Deal with UTF characters that take up more than one character. It's
   easier to write this out separately than try to macrify it. Use c to
   hold the length of the character in bytes, plus UTF_LENGTH to flag that
   it's a length rather than a small character. */ //
/* Length of UTF-8 character */ //
/* Save the char */ //
/* Flag c as a length */ //
/* Handle the case of a single charater - either with no UTF support, or
   with UTF disabled, or for a single character UTF character. */ //
/* Code shared with single character types */ //
/* If previous was a character type match (\d or similar), abolish it and
   create a suitable repeat item. The code is shared with single-character
   repeats by setting op_type to add a suitable offset into repeat_type. Note
   the the Unicode property types will be present only when SUPPORT_UCP is
   defined, but we don't wrap the little bits of code here because it just
   makes it horribly messy. */ //
/* Use type opcodes */ //
/* Usually overwrite previous item */ //
/* If the maximum is zero then the minimum must also be zero; Perl allows
   this case, so we do too - by simply omitting the item altogether. */ //
/* Combine the op_type with the repeat_type */ //
/* A minimum of zero is handled either as the special case * or ?, or as
   an UPTO, with the maximum given. */ //
/* A repeat minimum of 1 is optimized into some special cases. If the
   maximum is unlimited, we use OP_PLUS. Otherwise, the original item is
   left in place and, if the maximum is greater than 1, we use OP_UPTO with
   one less than the maximum. */ //
/* leave previous item in place */ //
/* The case {n,n} is just an EXACT, while the general case {n,m} is
   handled as an EXACT followed by an UPTO. */ //
/* NB EXACT doesn't have repeat_type */ //
/* If the maximum is unlimited, insert an OP_STAR. Before doing so,
   we have to insert the character for the previous code. For a repeated
   Unicode property match, there are two extra bytes that define the
   required property. In UTF-8 mode, long characters have their length in
   c, with the UTF_LENGTH bit as a flag. */ //
/* Else insert an UPTO if the max is greater than the min, again
   preceded by the character, for the previously inserted code. If the
   UPTO is just for 1 instance, we can use QUERY instead. */ //
/* The character or character type itself comes last in all cases. */ //
/* For a repeated Unicode property match, there are two extra bytes that
   define the required property. */ //
/* If previous was a character class or a back reference, we put the repeat
   stuff after it, but just skip the item if the repeat was {0,0}. */ //
/* 2-byte encoding for max */ //
/* If previous was a bracket group, we may have to replicate it in certain
   cases. Note that at this point we can encounter only the "basic" bracket
   opcodes such as BRA and CBRA, as this is the place where they get converted
   into the more special varieties such as BRAPOS and SBRA. A test for >=
   OP_ASSERT and <= OP_COND includes ASSERT, ASSERT_NOT, ASSERTBACK,
   ASSERTBACK_NOT, ONCE, ONCE_NC, BRA, BRAPOS, CBRA, CBRAPOS, and COND.
   Originally, PCRE did not allow repetition of assertions, but now it does,
   for Perl compatibility. */ //
/* Repeating a DEFINE group is pointless, but Perl allows the syntax, so
   we just ignore the repeat. */ //
/* There is no sense in actually repeating assertions. The only potential
   use of repetition is in cases when the assertion is optional. Therefore,
   if the minimum is greater than zero, just ignore the repeat. If the
   maximum is not zero or one, set it to 1. */ //
/* Assertion */ //
/* The case of a zero minimum is special because of the need to stick
   OP_BRAZERO in front of it, and because the group appears once in the
   data, whereas in other cases it appears the minimum number of times. For
   this reason, it is simplest to treat this case separately, as otherwise
   the code gets far too messy. There are several special subcases when the
   minimum is zero. */ //
/* If the maximum is also zero, we used to just omit the group from the
   output altogether, like this:

   ** if (repeat_max == 0)
   **   {
   **   code = previous;
   **   goto END_REPEAT;
   **   }

   However, that fails when a group or a subgroup within it is referenced
   as a subroutine from elsewhere in the pattern, so now we stick in
   OP_SKIPZERO in front of it so that it is skipped on execution. As we
   don't have a list of which groups are referenced, we cannot do this
   selectively.

   If the maximum is 1 or unlimited, we just have to stick in the BRAZERO
   and do no more at this point. However, we do need to adjust any
   OP_RECURSE calls inside the group that refer to the group itself or any
   internal or forward referenced group, because the offset is from the
   start of the whole regex. Temporarily terminate the pattern while doing
   this. */ //
/* Covers 0, 1, and unlimited */ //
/* Save for possessive optimizing */ //
/* If the maximum is greater than 1 and limited, we have to replicate
   in a nested fashion, sticking OP_BRAZERO before each set of brackets.
   The first one has to be handled carefully because it's the original
   copy, which has to be moved up. The remainder can be handled by code
   that is common with the non-zero minimum case below. We have to
   adjust the value or repeat_max, since one less copy is required. Once
   again, we may have to adjust any OP_RECURSE calls inside the group. */ //
/* We chain together the bracket offset fields that have to be
   filled in later when the ends of the brackets are reached. */ //
/* If the minimum is greater than zero, replicate the group as many
   times as necessary, and adjust the maximum to the number of subsequent
   copies that we need. If we set a first char from the group, and didn't
   set a required char, copy the latter from the former. If there are any
   forward reference subroutine calls in the group, there will be entries on
   the workspace list; replicate these with an appropriate increment. */ //
/* In the pre-compile phase, we don't actually do the replication. We
   just adjust the length as if we had. Do some paranoid checks for
   potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
   integer type when available, otherwise double. */ //
/* This is compiling for real. If there is a set first byte for
   the group, and we have not yet set a "required byte", set it. Make
   sure there is enough workspace for copying forward references before
   doing the copy. */ //
/* This code is common to both the zero and non-zero minimum cases. If
   the maximum is limited, it replicates the group in a nested fashion,
   remembering the bracket starts on a stack. In the case of a zero minimum,
   the first one was set up above. In all cases the repeat_max now specifies
   the number of additional copies needed. Again, we must remember to
   replicate entries on the forward reference list. */ //
/* In the pre-compile phase, we don't actually do the replication. We
   just adjust the length as if we had. For each repetition we must add 1
   to the length for BRAZERO and for all but the last repetition we must
   add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some
   paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type is
   a 64-bit integer type when available, otherwise double. */ //
/* Last one doesn't nest */ //
/* This is compiling for real */ //
/* All but the final copy start a new nesting, maintaining the
   chain of brackets outstanding. */ //
/* Ensure there is enough workspace for forward references before
   copying them. */ //
/* Now chain through the pending brackets, and fill in their length
   fields (which are holding the chain links pro tem). */ //
/* If the maximum is unlimited, set a repeater in the final copy. For
   ONCE brackets, that's all we need to do. However, possessively repeated
   ONCE brackets can be converted into non-capturing brackets, as the
   behaviour of (?:xx)++ is the same as (?>xx)++ and this saves having to
   deal with possessive ONCEs specially.

   Otherwise, when we are doing the actual compile phase, check to see
   whether this group is one that could match an empty string. If so,
   convert the initial operator to the S form (e.g. OP_BRA -> OP_SBRA) so
   that runtime checking can be done. [This check is also applied to ONCE
   groups at runtime, but in a different way.]

   Then, if the quantifier was possessive and the bracket is not a
   conditional, we convert the BRA code to the POS form, and the KET code to
   KETRPOS. (It turns out to be convenient at runtime to detect this kind of
   subpattern at both the start and at the end.) The use of special opcodes
   makes it possible to reduce greatly the stack usage in pcre_exec(). If
   the group is preceded by OP_BRAZERO, convert this to OP_BRAPOSZERO.

   Then, if the minimum number of matches is 1 or 0, cancel the possessive
   flag so that the default action below, of wrapping everything inside
   atomic brackets, does not happen. When the minimum is greater than 1,
   there will be earlier copies of the group, and so we still have to wrap
   the whole thing. */ //
/* Convert possessive ONCE brackets to non-capturing */ //
/* For non-possessive ONCE brackets, all we need to do is to
   set the KET. */ //
/* Handle non-ONCE brackets and possessive ONCEs (which have been
   converted to non-capturing above). */ //
/* In the compile phase, check for empty string matching. */ //
/* A conditional group with only one branch has an implicit empty
   alternative branch. */ //
/* Handle possessive quantifiers. */ //
/* For COND brackets, we wrap the whole thing in a possessively
   repeated non-capturing bracket, because we have not invented POS
   versions of the COND opcodes. Because we are moving code along, we
   must ensure that any pending recursive references are updated. */ //
/* For non-COND brackets, we modify the BRA code and use KETRPOS. */ //
/* Switch to xxxPOS opcodes */ //
/* If the minimum is zero, mark it as possessive, then unset the
   possessive flag when the minimum is 0 or 1. */ //
/* Non-possessive quantifier */ //
/* If previous is OP_FAIL, it was generated by an empty class [] in
   JavaScript mode. The other ways in which OP_FAIL can be generated, that is
   by (*FAIL) or (?!) set previous to NULL, which gives a "nothing to repeat"
   error above. We can just ignore the repeat in JS case. */ //
/* Else there's some kind of shambles */ //
/* If the character following a repeat is '+', possessive_quantifier is
   TRUE. For some opcodes, there are special alternative opcodes for this
   case. For anything else, we wrap the entire repeated item inside OP_ONCE
   brackets. Logically, the '+' notation is just syntactic sugar, taken from
   Sun's Java package, but the special opcodes can optimize it.

   Some (but not all) possessively repeated subpatterns have already been
   completely handled in the code just above. For them, possessive_quantifier
   is always FALSE at this stage. Note that the repeated item starts at
   tempcode, not at previous, which might be the first part of a string whose
   (former) last char we repeated. */ //
/* Possessifying an EXACT quantifier has no effect, so we can ignore it.
   However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},
   {5,}, or {5,10}). We skip over an EXACT item; if the length of what
   remains is greater than zero, there's a further opcode that can be
   handled. If not, do nothing, leaving the EXACT alone. */ //
/* CHAR opcodes are used for exacts whose count is 1. */ //
/* For the class opcodes, the repeat operator appears at the end;
   adjust tempcode to point to it. */ //
/* If tempcode is equal to code (which points to the end of the repeated
   item), it means we have skipped an EXACT item but there is no following
   QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In
   all other cases, tempcode will be pointing to the repeat opcode, and will
   be less than code, so the value of len will be greater than 0. */ //
/* There is a table for possessifying opcodes, all of which are less
   than OP_CALLOUT. A zero entry means there is no possessified version.
*/ //
/* For opcode without a special possessified version, wrap the item in
   ONCE brackets. Because we are moving code along, we must ensure that any
   pending recursive references are updated. */ //
/* In all case we no longer have a previous item. We also set the
   "follows varying string" flag for subsequently encountered reqchars if
   it isn't already set and we have just passed a varying length item. */ //
/* ===================================================================*/ //
/* Start of nested parenthesized sub-expression, or comment or lookahead or
   lookbehind or option setting or condition or all the other extended
   parenthesis forms.  */ //
/* Now deal with various "verbs" that can be introduced by '*'. */ //
/* It appears that Perl allows any characters whatsoever, other than
   a closing parenthesis, to appear in arguments, so we no longer insist on
   letters, digits, and underscores. */ //
/* Scan the table of verb names */ //
/* Check for open captures before ACCEPT and convert it to
   ASSERT_ACCEPT if in an assertion. */ //
/* Do not set firstchar after *ACCEPT */ //
/* Handle other cases with/without an argument */ //
/* Argument is mandatory */ //
/* Argument is forbidden */ //
/* In pass 1 just add in the length */ //
/* to avoid potential workspace */ //
/* overflow. */ //
/* Found verb, exit loop */ //
/* Successfully handled a verb */ //
/* Verb not recognized */ //
/* Initialize for "real" parentheses */ //
/* Deal with the extended parentheses; all are introduced by '?', and the
   appearance of any of them means that this is not a capturing group. */ //
/* ------------------------------------------------------------ */ //
/* Reset capture count for each branch */ //
/* Record (?| encountered */ //
/* Fall through */ //
/* ------------------------------------------------------------ */ //
/* Non-capturing bracket */ //
/* ------------------------------------------------------------ */ //
/* Conditional group */ //
/* A condition can be an assertion, a number (referring to a numbered
   group's having been set), a name (referring to a named group), or 'R',
   referring to recursion. R<digits> and R&name are also permitted for
   recursion tests.

   There are ways of testing a named group: (?(name)) is used by Python;
   Perl 5.10 onwards uses (?(<name>) or (?('name')).

   There is one unfortunate ambiguity, caused by history. 'R' can be the
   recursive thing or the name 'R' (and similarly for 'R' followed by
   digits). We look for a name first; if not found, we try the other case.

   For compatibility with auto-callouts, we allow a callout to be
   specified before a condition that is an assertion. First, check for the
   syntax of a callout; if found, adjust the temporary pointer that is
   used to check for an assertion condition. That's all that is needed! */ //
/* tempptr should now be pointing to the opening parenthesis of the
   assertion condition. */ //
/* For conditions that are assertions, check the syntax, and then exit
   the switch. This will take control down to where bracketed groups,
   including assertions, are processed. */ //
/* Other conditions use OP_CREF/OP_DNCREF/OP_RREF/OP_DNRREF, and all
   need to skip at least 1+IMM2_SIZE bytes at the start of the group. */ //
/* => not a number */ //
/* => not a name; must set to avoid warning */ //
/* Always set to avoid warning */ //
/* Always set to avoid warning */ //
/* Check for a test for recursion in a named group. */ //
/* Change the type of test */ //
/* Check for a test for a named group's having been set, using the Perl
   syntax (?(<name>) or (?('name'), and also allow for the original PCRE
   syntax of (?(name) or for (?(+n), (?(-n), and just (?(n). */ //
/* Handle a number */ //
/* Integer overflow */ //
/* Otherwise we expect to read a name; anything else is an error. When
   a name is one of a number of duplicates, a different opcode is used and
   it needs more memory. Unfortunately we cannot tell whether a name is a
   duplicate in the first pass, so we have to allow for more memory. */ //
/* Assertion expected */ //
/* Check the terminator */ //
/* Error offset */ //
/* Malformed number or name */ //
/* Do no further checking in the pre-compile phase. */ //
/* In the real compile we do the work of looking for the actual
   reference. If refsign is not negative, it means we have a number in
   recno. */ //
/* Otherwise look for the name. */ //
/* Found the named subpattern. If the name is duplicated, add one to
   the opcode to change CREF/RREF into DNCREF/DNRREF and insert
   appropriate data values. Otherwise, just insert the unique subpattern
   number. */ //
/* Number from first found */ //
/* Not a duplicated name */ //
/* If terminator == CHAR_NULL it means that the name followed directly
   after the opening parenthesis [e.g. (?(abc)...] and in this case there
   are some further alternatives to try. For the cases where terminator !=
   CHAR_NULL [things like (?(<name>... or (?('name')... or (?(R&name)... ]
   we have now checked all the possibilities, so give an error. */ //
/* Check for (?(R) for recursion. Allow digits after R to specify a
   specific group number. */ //
/* Integer overflow */ //
/* Change test type */ //
/* Similarly, check for the (?(DEFINE) "condition", which is always
   false. */ //
/* Reference to an unidentified subpattern. */ //
/* ------------------------------------------------------------ */ //
/* Positive lookahead */ //
/* Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
   thing to do, but Perl allows all assertions to be quantified, and when
   they contain capturing parentheses there may be a potential use for
   this feature. Not that that applies to a quantified (?!) but we allow
   it for uniformity. */ //
/* ------------------------------------------------------------ */ //
/* Negative lookahead */ //
/* ------------------------------------------------------------ */ //
/* Lookbehind or named define */ //
/* Positive lookbehind */ //
/* Negative lookbehind */ //
/* Could be name define, else bad */ //
/* Correct offset for error */ //
/* ------------------------------------------------------------ */ //
/* One-time brackets */ //
/* ------------------------------------------------------------ */ //
/* Callout - may be followed by digits; */ //
/* Save for later completion */ //
/* Skip one item before completing */ //
/* Pattern offset */ //
/* Default length */ //
/* ------------------------------------------------------------ */ //
/* Python-style named subpattern handling */ //
/* Reference or recursion */ //
/* Test for Python-style defn */ //
/* Fall through to handle (?P< as (?< is handled */ //
/* ------------------------------------------------------------ */ //
/* Come here from (?< handling */ //
/* Group name must start with non-digit */ //
/* In the pre-compile phase, do a syntax check, remember the longest
   name, and then remember the group in a vector, expanding it if
   necessary. Duplicates for the same number are skipped; other duplicates
   are checked for validity. In the actual compile, there is nothing to
   do. */ //
/* Scan the list to check for duplicates. For duplicate names, if the
   number is the same, break the loop, which causes the name to be
   discarded; otherwise, if DUPNAMES is not set, give an error.
   If it is set, allow the name with a different number, but continue
   scanning in case this is a duplicate with the same number. For
   non-duplicate names, give an error if the number is duplicated. */ //
/* Duplicate names exist */ //
/* Not a duplicate with same number */ //
/* Increase the list size if necessary */ //
/* Move past > or ' in both passes. */ //
/* ------------------------------------------------------------ */ //
/* Perl recursion/subroutine syntax */ //
/* Fall through */ //
/* We come here from the Python syntax above that handles both
   references (?P=name) and recursion (?P>name), as well as falling
   through from the Perl recursion syntax (?&name). We also come here from
   the Perl \k<name> or \k'name' back reference syntax and the \k{name}
   .NET syntax, and the Oniguruma \g<...> and \g'...' subroutine syntax. */ //
/* Group name must start with non-digit */ //
/* In the pre-compile phase, do a syntax check. We used to just set
   a dummy reference number, because it was not used in the first pass.
   However, with the change of recursive back references to be atomic,
   we have to look for the number so that this state can be identified, as
   otherwise the incorrect length is computed. If it's not a backwards
   reference, the dummy number will do. */ //
/* Count named back references. */ //
/* We have to allow for a named reference to a duplicated name (this
   cannot be determined until the second pass). This needs an extra
   16-bit data item. */ //
/* If this is a forward reference and we are within a (?|...) group,
   the reference may end up as the number of a group which we are
   currently inside, that is, it could be a recursive reference. In the
   real compile this will be picked up and the reference wrapped with
   OP_ONCE to make it atomic, so we must space in case this occurs. */ //
/* In fact, this can happen for a non-forward reference because
   another group with the same number might be created later. This
   issue is fixed "properly" in PCRE2. As PCRE1 is now in maintenance
   only mode, we finesse the bug by allowing more memory always. */ //
/* It is even worse than that. The current reference may be to an
   existing named group with a different number (so apparently not
   recursive) but which later on is also attached to a group with the
   current number. This can only happen if $(| has been previous
   encountered. In that case, we allow yet more memory, just in case.
   (Again, this is fixed "properly" in PCRE2. */ //
/* Otherwise, check for recursion here. The name table does not exist
   in the first pass; instead we must scan the list of names encountered
   so far in order to get the number. If the name is not found, leave
   the value of recno as 0 for a forward reference. */ //
/* This patch (removing "else") fixes a problem when a reference is
   to multiple identically named nested groups from within the nest.
   Once again, it is not the "proper" fix, and it results in an
   over-allocation of memory. */ //
/* else */ //
/* In the real compile, search the name table. We check the name
   first, and then check that we have reached the end of the name in the
   table. That way, if the name is longer than any in the table, the
   comparison will fail without reading beyond the table entry. */ //
/* In both phases, for recursions, we can now go to the code than
   handles numerical recursion. */ //
/* In the second pass we must see if the name is duplicated. If so, we
   generate a different opcode. */ //
/* Process each potentially referenced group. */ //
/* Check to see if this back reference is recursive, that it, it
   is inside the group that it references. A flag is set so that the
   group can be made atomic. */ //
/* End of back ref handling */ //
/* First pass, or a non-duplicated name. */ //
/* ------------------------------------------------------------ */ //
/* Recursion, same as (?0) */ //
/* ------------------------------------------------------------ */ //
/* Recursion or subroutine */ //
/* Come here from the \g<...> and \g'...' code (Oniguruma
   compatibility). However, the syntax has been checked to ensure that
   the ... are a (signed) number, so that neither ERR63 nor ERR29 will
   be called on this path, nor with the jump to OTHER_CHAR_AFTER_QUERY
   ever be taken. */ //
/* Integer overflow */ //
/* Come here from code above that handles a named recursion */ //
/* When we are actually compiling, find the bracket that is being
   referenced. Temporarily end the regex in case it doesn't exist before
   this point. If we end up with a forward reference, first check that
   the bracket does occur later so we can give the error (and position)
   now. Then remember this forward reference in the workspace so it can
   be filled in at the end. */ //
/* Forward reference */ //
/* Fudge the value of "called" so that when it is inserted as an
   offset below, what it actually inserted is the reference number
   of the group. Then remember the forward reference. */ //
/* If not a forward reference, and the subpattern is still open,
   this is a recursive call. We check to see if this is a left
   recursion that could loop for ever, and diagnose that case. We
   must not, however, do this check if we are in a conditional
   subpattern because the condition might be testing for recursion in
   a pattern such as /(?(R)a+|(?R)b)/, which is perfectly valid.
   Forever loops are also detected at runtime, so those that occur in
   conditional subpatterns will be picked up then. */ //
/* Insert the recursion/subroutine item. It does not have a set first
   character (relevant if it is repeated, because it will then be
   wrapped with ONCE brackets). */ //
/* Can't determine a first byte now */ //
/* ------------------------------------------------------------ */ //
/* Other characters: check option setting */ //
/* Record that it changed in the external options */ //
/* Correct the offset */ //
/* Set up the changed option bits, but don't change anything yet. */ //
/* If the options ended with ')' this is not the start of a nested
   group with option changes, so the options change at this level.
   If we are not at the pattern start, reset the greedy defaults and the
   case value for firstchar and reqchar. */ //
/* Change options at this level, and pass them back for use
   in subsequent branches. */ //
/* This item can't be repeated */ //
/* It is complete */ //
/* If the options ended with ':' we are heading into a nested group
   with possible change of options. Such groups are non-capturing and are
   not assertions of any kind. All we need to do is skip over the ':';
   the newoptions value is handled below. */ //
/* End of switch for character following (? */ //
/* End of (? handling */ //
/* Opening parenthesis not followed by '*' or '?'. If PCRE_NO_AUTO_CAPTURE
   is set, all unadorned brackets become non-capturing and behave like (?:...)
   brackets. */ //
/* Else we have a capturing group. */ //
/* Process nested bracketed regex. First check for parentheses nested too
   deeply. */ //
/* All assertions used not to be repeatable, but this was changed for Perl
   compatibility. All kinds can now be repeated except for assertions that are
   conditions (Perl also forbids these to be repeated). We copy code into a
   non-register variable (tempcode) in order to be able to pass its address
   because some compilers complain otherwise. At the start of a conditional
   group whose condition is an assertion, cd->iscondassert is set. We unset it
   here so as to allow assertions later in the group to be quantified. */ //
/* Save value before bracket */ //
/* Save value before bracket */ //
/* Initialize for pre-compile phase */ //
/* The complete new option state */ //
/* Where to put code (updated) */ //
/* Input pointer (updated) */ //
/* Where to put an error message */ //
/* TRUE if back assert */ //
/* True if (?| group */ //
/* Skip over bracket number */ //
/* Depth of condition subpatterns */ //
/* For possible first char */ //
/* For possible last char */ //
/* Current branch chain */ //
/* Tables block */ //
/* Actual compile phase */ //
/* Pre-compile phase */ //
/* If this was an atomic group and there are no capturing groups within it,
   generate OP_ONCE_NC instead of OP_ONCE. */ //
/* At the end of compiling, code is still pointing to the start of the
   group, while tempcode has been updated to point past the end of the group.
   The pattern pointer (ptr) is on the bracket.

   If this is a conditional bracket, check that there are no more than
   two branches in the group, or just one if it's a DEFINE group. We do this
   in the real compile phase, not in the pre-pass, where the whole group may
   not be available. */ //
/* A DEFINE group is never obeyed inline (the "condition" is always
   false). It must have only one branch. */ //
/* Just a flag to suppress char handling below */ //
/* A "normal" conditional group. If there is just one branch, we must not
   make use of its firstchar or reqchar, because this is equivalent to an
   empty second branch. */ //
/* Error if hit end of pattern */ //
/* In the pre-compile phase, update the length by the length of the group,
   less the brackets at either end. Then reduce the compiled code to just a
   set of non-capturing brackets so that it doesn't use much memory if it is
   duplicated by a quantifier.*/ //
/* This already contains bravalue */ //
/* No need to waste time with special character handling */ //
/* Otherwise update the main code pointer to the end of the group. */ //
/* For a DEFINE group, required and first character settings are not
   relevant. */ //
/* Handle updating of the required and first characters for other types of
   group. Update for normal brackets of all kinds, and conditions with two
   branches (see code above). If the bracket is followed by a quantifier with
   zero repeat, we have to back off. Hence the definition of zeroreqchar and
   zerofirstchar outside the main loop so that they can be accessed for the
   back off. */ //
/* If we have not yet set a firstchar in this branch, take it from the
   subpattern, remembering that it was set here so that a repeat of more
   than one can replicate it as reqchar if necessary. If the subpattern has
   no firstchar, set "none" for the whole branch. In both cases, a zero
   repeat forces firstchar to "none". */ //
/* If firstchar was previously set, convert the subpattern's firstchar
   into reqchar if there wasn't one, using the vary flag that was in
   existence beforehand. */ //
/* If the subpattern set a required byte (or set a first byte that isn't
   really the first byte - see above), set it. */ //
/* For a forward assertion, we take the reqchar, if set, provided that the
   group has also set a first char. This can be helpful if the pattern that
   follows the assertion doesn't set a different char. For example, it's
   useful for /(?=abcde).+/. We can't set firstchar for an assertion, however
   because it leads to incorrect effect for patterns such as /(?=a)a.+/ when
   the "real" "a" would then become a reqchar instead of a firstchar. This is
   overcome by a scan at the end if there's no firstchar, looking for an
   asserted first char. */ //
/* End of processing '(' */ //
/* ===================================================================*/ //
/* Handle metasequences introduced by \. For ones like \d, the ESC_ values
   are arranged to be the negation of the corresponding OP_values in the
   default case when PCRE_UCP is not set. For the back references, the values
   are negative the reference number. Only back references and those types
   that consume a character may be repeated. We can test for values between
   ESC_b and ESC_Z for the latter; this may have to change if any new ones are
   ever created. */ //
/* The escape coded a single character */ //
/* For metasequences that actually match a character, we disable the
   setting of a first character if it hasn't already been set. */ //
/* Set values to reset to if this is followed by a zero repeat. */ //
/* \g<name> or \g'name' is a subroutine call by name and \g<n> or \g'n'
   is a subroutine call by number (Oniguruma syntax). In fact, the value
   ESC_g is returned only for these cases. So we don't need to check for <
   or ' if the value is ESC_g. For the Perl syntax \g{n} the value is
   -n, and for the Perl syntax \g{name} the result is ESC_k (as
   that is a synonym for a named back reference). */ //
/* Normally this is set when '(' is read */ //
/* These two statements stop the compiler for warning about possibly
   unset variables caused by the jump to HANDLE_NUMERICAL_RECURSION. In
   fact, because we do the check for a number below, the paths that
   would actually be in error are never taken. */ //
/* If it's not a signed or unsigned number, treat it as a name. */ //
/* Signed or unsigned number (cf = ptr[1]) is known to be plus or minus
   or a digit. */ //
/* \k<name> or \k'name' is a back reference by name (Perl syntax).
   We also support \k{name} (.NET syntax).  */ //
/* Back references are handled specially; must disable firstchar if
   not set to cope with cases like (?=(\w+))\1: which would otherwise set
   ':' later. */ //
/* Come here from named backref handling when the reference is to a
   single group (i.e. not to a duplicated name. */ //
/* Check to see if this back reference is recursive, that it, it
   is inside the group that it references. A flag is set so that the
   group can be made atomic. */ //
/* So are Unicode property matches, if supported. */ //
/* For the rest (including \X when Unicode properties are supported), we
   can obtain the OP value by negating the escape value in the default
   situation when PCRE_UCP is not set. When it *is* set, we substitute
   Unicode property tests. Note that \b and \B do a one-character
   lookbehind, and \A also behaves as if it does. */ //
/* Where to resume */ //
/* Just before substitute */ //
/* In non-UTF-8 mode, we turn \C into OP_ALLANY instead of OP_ANYBYTE
   so that it works in DFA mode and in lookbehinds. */ //
/* We have a data character whose value is in c. In UTF-8 mode it may have
   a value > 127. We set its representation in the length/buffer, and then
   handle it as a data character. */ //
/* ===================================================================*/ //
/* Handle a literal character. It is guaranteed not to be whitespace or #
   when the extended flag is set. If we are in a UTF mode, it may be a
   multi-unit literal character. */ //
/* At this point we have the character's bytes in mcbuffer, and the length
   in mclength. When not in UTF-8 mode, the length is always 1. */ //
/* For caseless UTF-8 mode when UCP support is available, check whether
   this character has more than one other case. If so, generate a special
   OP_PROP item instead of OP_CHARI. */ //
/* Caseful matches, or not one of the multicase characters. */ //
/* Remember if \r or \n were seen */ //
/* Set the first and required bytes appropriately. If no previous first
   byte, set it from this character, but revert to none on a zero repeat.
   Otherwise, leave the firstchar value alone, and don't change it on a zero
   repeat. */ //
/* If the character is more than one byte long, we can set firstchar
   only if it is not to be matched caselessly. */ //
/* firstchar was previously set; we can set reqchar only if the length is
   1 or the matching is caseful. */ //
/* End of literal character handling */ //
/* end of big loop */ //
/* Control never reaches here by falling through, only by a goto for all the
error states. Pass back the position in the pattern so that it can be displayed
to the user for diagnosing the error. */ //
//
func compile_branch(optionsptr *int32, codeptr **pcre_uchar, ptrptr **pcre_uchar, errorcodeptr *int32, firstcharptr *pcre_uint32, firstcharflagsptr *pcre_int32, reqcharptr *pcre_uint32, reqcharflagsptr *pcre_int32, bcptr *branch_chain, cond_depth int32, cd *compile_data, lengthptr *int32) BOOL {
	var repeat_type int32
	var op_type int32
	var repeat_min int32 = int32(0)
	var repeat_max int32 = int32(0)
	var bravalue int32 = int32(0)
	var greedy_default int32
	var greedy_non_default int32
	var firstchar pcre_uint32
	var reqchar pcre_uint32
	var firstcharflags pcre_int32
	var reqcharflags pcre_int32
	var zeroreqchar pcre_uint32
	var zerofirstchar pcre_uint32
	var zeroreqcharflags pcre_int32
	var zerofirstcharflags pcre_int32
	var req_caseopt pcre_int32
	var reqvary pcre_int32
	var tempreqvary pcre_int32
	var options int32 = *optionsptr
	var after_manual_callout int32 = int32(0)
	var length_prevgroup int32 = int32(0)
	var c pcre_uint32
	var escape int32
	var code *pcre_uchar = *codeptr
	var last_code *pcre_uchar = code
	var orig_code *pcre_uchar = code
	var tempcode *pcre_uchar
	var inescq BOOL = BOOL((int32(0)))
	var groupsetfirstchar BOOL = BOOL((int32(0)))
	var ptr *pcre_uchar = *ptrptr
	var tempptr *pcre_uchar
	var nestptr *pcre_uchar = nil
	var previous *pcre_uchar = nil
	var previous_callout *pcre_uchar = nil
	var item_hwm_offset size_t = size_t(int32(0))
	var classbits []pcre_uint8 = make([]pcre_uint8, 32, 32)
	var utf BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))]))
	var utf_chars []pcre_uchar = make([]pcre_uchar, 6, 6)
	var class_uchardata *pcre_uchar
	var xclass BOOL
	var class_uchardata_base *pcre_uchar
	greedy_default = map[bool]int32{false: 0, true: 1}[((options & int32(512)) != int32(0))]
	greedy_non_default = (greedy_default ^ int32(1))
	zeroreqchar = pcre_uint32(int32(0))
	zerofirstchar = zeroreqchar
	reqchar = zerofirstchar
	firstchar = reqchar
	zeroreqcharflags = pcre_int32((-int32(2)))
	zerofirstcharflags = zeroreqcharflags
	reqcharflags = zerofirstcharflags
	firstcharflags = reqcharflags
	req_caseopt = pcre_int32((func() int32 {
		if (map[bool]int32{false: 0, true: 1}[((options & int32(1)) != int32(0))]) != 0 {
			return (int32(1) << uint64(int32(0)))
		} else {
			return int32(0)
		}
	}()))
	for ; ; ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr)))) {
		var negate_class BOOL
		var should_flip_negation BOOL
		var possessive_quantifier BOOL
		var is_quantifier BOOL
		var is_recurse BOOL
		var reset_bracount BOOL
		var class_has_8bitchar int32
		var class_one_char int32
		var xclass_has_prop BOOL
		var newoptions int32
		var recno int32
		var refsign int32
		var skipbytes int32
		var subreqchar pcre_uint32
		var subfirstchar pcre_uint32
		var subreqcharflags pcre_int32
		var subfirstcharflags pcre_int32
		var terminator int32
		var mclength uint32
		var tempbracount uint32
		var ec pcre_uint32
		var mcbuffer []pcre_uchar = make([]pcre_uchar, 8, 8)
		var goto_HANDLE int
		const HANDLE_RECURSION = 1
		const HANDLE_NUMERICAL_RECURSION = 2
		var goto_HANDLE_REFERENCE bool
		var goto_NAMED_REF_OR_RECURSE bool
	REDO_LOOP:
		;
		c = pcre_uint32((uint32(uint8((*ptr)))))
		if (c == pcre_uint32((uint32('\x00')))) && (nestptr != nil) {
			ptr = nestptr
			nestptr = nil
			c = pcre_uint32((uint32(uint8((*ptr)))))
		}
		if lengthptr != nil {
			if int64(uintptr(unsafe.Pointer(code))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*cd).start_workspace
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
				}()))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(100))*unsafe.Sizeof(*tempVar))
			}()))))) {
				*errorcodeptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(code))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*cd).start_workspace
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
					}()))))))]) != 0 {
						return ERR52
					} else {
						return ERR87
					}
				}()
				goto FAILED
			}
			if int64(uintptr(unsafe.Pointer(code))) < int64(uintptr(unsafe.Pointer(last_code))) {
				code = last_code
			}
			if ((int32(2147483647) - int32(20)) - *lengthptr) < int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_code))))) {
				*errorcodeptr = ERR20
				goto FAILED
			}
			*lengthptr += (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_code))))))
			if previous != nil {
				if int64(uintptr(unsafe.Pointer(previous))) > int64(uintptr(unsafe.Pointer(orig_code))) {
					noarch.Memcpy(unsafe.Pointer(orig_code), unsafe.Pointer(previous), int32(uint32((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(previous)))))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(int32((int64(uintptr(unsafe.Pointer(previous)))-int64(uintptr(unsafe.Pointer(orig_code))))))*unsafe.Sizeof(*code))))
					previous = orig_code
				}
			} else {
				code = orig_code
			}
			last_code = code
		} else if int64(uintptr(unsafe.Pointer((*cd).hwm))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*cd).start_workspace
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
		}()))))) {
			*errorcodeptr = ERR52
			goto FAILED
		}
		if c != pcre_uint32((uint32('\x00'))) {
			if (c == pcre_uint32((uint32('\\')))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
				inescq = BOOL((int32(0)))
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				continue
			} else if int32((BOOL(inescq))) != 0 {
				if previous_callout != nil {
					if lengthptr == nil {
						complete_callout(previous_callout, ptr, cd)
					}
					previous_callout = nil
				}
				if (options & int32(16384)) != int32(0) {
					previous_callout = code
					code = auto_callout(code, ptr, cd)
				}
				goto NORMAL_CHAR
			}
			if (c == pcre_uint32((uint32('\\')))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('Q')) {
				inescq = BOOL((int32(1)))
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				continue
			}
		}
		if (options & int32(8)) != int32(0) {
			var wscptr *pcre_uchar = ptr
			for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*cd).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(1)) != int32(0)) {
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					return ptr
				}())))))
			}
			if c == pcre_uint32((uint32('#'))) {
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				for int32(uint8((*ptr))) != int32('\x00') {
					if (func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*cd).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*cd).end_pattern)))) && (int32((_pcre_is_newline((ptr), (*cd).nltype, (*cd).end_pattern, &((*cd).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).end_pattern
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*cd).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*cd).nl[0]))))) && (((*cd).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*cd).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}()) != 0 {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)((*cd).nllen)*unsafe.Sizeof(*ptr))))
						break
					}
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					if int32((BOOL(utf))) != 0 {
						for (int32(uint8((*ptr))) & int32(192)) == int32(128) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
					}
				}
			}
			if int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer(wscptr))) {
				goto REDO_LOOP
			}
		}
		if ((c == pcre_uint32((uint32('(')))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('?'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('#')) {
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))
			for (int32(uint8((*ptr))) != int32('\x00')) && (int32(uint8((*ptr))) != int32(')')) {
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
			}
			if int32(uint8((*ptr))) == int32('\x00') {
				*errorcodeptr = ERR18
				goto FAILED
			}
			continue
		}
		is_quantifier = BOOL((map[bool]int32{false: 0, true: 1}[((((c == pcre_uint32((uint32('*')))) || (c == pcre_uint32((uint32('+'))))) || (c == pcre_uint32((uint32('?'))))) || ((c == pcre_uint32((uint32('{')))) && (int32((is_counted_repeat(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != 0)))]))
		if (((int32((NotBOOL(BOOL(is_quantifier)))) != 0) && (previous_callout != nil)) && (nestptr == nil)) && (func() int32 {
			defer func() {
				after_manual_callout -= 1
			}()
			return after_manual_callout
		}() <= int32(0)) {
			if lengthptr == nil {
				complete_callout(previous_callout, ptr, cd)
			}
			previous_callout = nil
		}
		if (((options & int32(16384)) != int32(0)) && (int32((NotBOOL(BOOL(is_quantifier)))) != 0)) && (nestptr == nil) {
			previous_callout = code
			code = auto_callout(code, ptr, cd)
		}
		switch pcre_uint32(c) {
		case pcre_uint32('\x00'):
			goto SW_GENERATED_LABEL_128
		case pcre_uint32('|'):
			goto SW_GENERATED_LABEL_129
		case pcre_uint32(')'):
			goto SW_GENERATED_LABEL_130
		case pcre_uint32('^'):
			goto SW_GENERATED_LABEL_131
		case pcre_uint32('$'):
			goto SW_GENERATED_LABEL_132
		case pcre_uint32('.'):
			goto SW_GENERATED_LABEL_133
		case pcre_uint32(']'):
			goto SW_GENERATED_LABEL_134
		case pcre_uint32('['):
			goto SW_GENERATED_LABEL_135
		case pcre_uint32('{'):
			goto SW_GENERATED_LABEL_136
		case pcre_uint32('*'):
			goto SW_GENERATED_LABEL_137
		case pcre_uint32('+'):
			goto SW_GENERATED_LABEL_138
		case pcre_uint32('?'):
			goto SW_GENERATED_LABEL_139
		case pcre_uint32('('):
			goto SW_GENERATED_LABEL_140
		case pcre_uint32('\\'):
			goto SW_GENERATED_LABEL_141
		default:
			goto SW_GENERATED_LABEL_142
		}
		goto SW_GENERATED_LABEL_127
	SW_GENERATED_LABEL_128:
		;
	SW_GENERATED_LABEL_129:
		;
	SW_GENERATED_LABEL_130:
		{
			*firstcharptr = firstchar
			*firstcharflagsptr = firstcharflags
			*reqcharptr = reqchar
			*reqcharflagsptr = reqcharflags
			*codeptr = code
			*ptrptr = ptr
			if lengthptr != nil {
				if ((int32(2147483647) - int32(20)) - *lengthptr) < int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_code))))) {
					*errorcodeptr = ERR20
					goto FAILED
				}
				*lengthptr += (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_code))))))
			}
			return BOOL((int32(1)))
		}
		goto SW_GENERATED_LABEL_127
	SW_GENERATED_LABEL_131:
		{
			previous = nil
			if (options & int32(2)) != int32(0) {
				if firstcharflags == pcre_int32((-int32(2))) {
					firstcharflags = pcre_int32((-int32(1)))
					zerofirstcharflags = firstcharflags
				}
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = pcre_uchar((uint8(OP_CIRCM)))
			} else {
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = pcre_uchar((uint8(OP_CIRC)))
			}
		}
		goto SW_GENERATED_LABEL_127
	SW_GENERATED_LABEL_132:
		{
			previous = nil
			*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}() = pcre_uchar((uint8(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((options & int32(2)) != int32(0))]) != 0 {
					return OP_DOLLM
				} else {
					return OP_DOLL
				}
			}())))
		}
		goto SW_GENERATED_LABEL_127
	SW_GENERATED_LABEL_133:
		{
			if firstcharflags == pcre_int32((-int32(2))) {
				firstcharflags = pcre_int32((-int32(1)))
			}
			zerofirstchar = firstchar
			zerofirstcharflags = firstcharflags
			zeroreqchar = reqchar
			zeroreqcharflags = reqcharflags
			previous = code
			item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
			*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}() = pcre_uchar((uint8(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((options & int32(4)) != int32(0))]) != 0 {
					return OP_ALLANY
				} else {
					return OP_ANY
				}
			}())))
		}
		goto SW_GENERATED_LABEL_127
	SW_GENERATED_LABEL_134:
		{
			if (pcre_uint32((*cd).external_options) & pcre_uint32((uint32(int32(33554432))))) != pcre_uint32((uint32(int32(0)))) {
				*errorcodeptr = ERR64
				goto FAILED
			}
			goto NORMAL_CHAR
		}
	SW_GENERATED_LABEL_135:
		{
			if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr))+(uintptr)(int32(1))*unsafe.Sizeof(*ptr)))))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("[:<:]]\x00"), 1, 1))))[0], int32(uint32((int32(6))))) == int32(0) {
				nestptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(7))*unsafe.Sizeof(*ptr))))
				ptr = &sub_start_of_word[0]
				goto REDO_LOOP
			}
			if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr))+(uintptr)(int32(1))*unsafe.Sizeof(*ptr)))))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("[:>:]]\x00"), 1, 1))))[0], int32(uint32((int32(6))))) == int32(0) {
				nestptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(7))*unsafe.Sizeof(*ptr))))
				ptr = &sub_end_of_word[0]
				goto REDO_LOOP
			}
			previous = code
			item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
			if (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(':')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('.'))) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('='))) && (int32((check_posix_syntax(ptr, &tempptr))) != 0) {
				*errorcodeptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(':'))]) != 0 {
						return ERR13
					} else {
						return ERR31
					}
				}()
				goto FAILED
			}
			negate_class = BOOL((int32(0)))
			for {
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					return ptr
				}())))))
				if c == pcre_uint32((uint32('\\'))) {
					if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('E') {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr))+(uintptr)(int32(1))*unsafe.Sizeof(*ptr)))))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("Q\\E\x00"), 1, 1))))[0], int32(uint32((int32(3))))) == int32(0) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))
					} else {
						break
					}
				} else if (int32((NotBOOL(BOOL(negate_class)))) != 0) && (c == pcre_uint32((uint32('^')))) {
					negate_class = BOOL((int32(1)))
				} else {
					break
				}
			}
			if (c == pcre_uint32((uint32(']')))) && ((pcre_uint32((*cd).external_options) & pcre_uint32((uint32(int32(33554432))))) != pcre_uint32((uint32(int32(0))))) {
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = pcre_uchar((uint8(func() int32 {
					if int32((BOOL(negate_class))) != 0 {
						return OP_ALLANY
					} else {
						return OP_FAIL
					}
				}())))
				if firstcharflags == pcre_int32((-int32(2))) {
					firstcharflags = pcre_int32((-int32(1)))
				}
				zerofirstchar = firstchar
				zerofirstcharflags = firstcharflags
				goto SW_GENERATED_LABEL_127
			}
			should_flip_negation = BOOL((int32(0)))
			xclass = BOOL((int32(0)))
			class_uchardata = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
			class_uchardata_base = class_uchardata
			class_has_8bitchar = int32(0)
			class_one_char = int32(0)
			xclass_has_prop = BOOL((int32(0)))
			noarch.Memset(unsafe.Pointer(&classbits[0]), int32(0), int32((uint32(int32(32)) * 1)))
			if c != pcre_uint32((uint32('\x00'))) {
				for {
					var oldptr *pcre_uchar
					if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
						c = pcre_uint32((uint32(uint8((*ptr)))))
						if c >= pcre_uint32((uint32(int32(192)))) {
							if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
							} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))
							} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))
							} else {
								c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))
							}
						}
					}
					if int64(uintptr(unsafe.Pointer(class_uchardata))) > int64(uintptr(unsafe.Pointer(class_uchardata_base))) {
						xclass = BOOL((int32(1)))
					}
					if (lengthptr != nil) && (int64(uintptr(unsafe.Pointer(class_uchardata))) > int64(uintptr(unsafe.Pointer(class_uchardata_base)))) {
						*lengthptr += (int32((int64(uintptr(unsafe.Pointer(class_uchardata))) - int64(uintptr(unsafe.Pointer(class_uchardata_base))))))
						class_uchardata = class_uchardata_base
					}
					if int32((BOOL(inescq))) != 0 {
						if (c == pcre_uint32((uint32('\\')))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
							inescq = BOOL((int32(0)))
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							goto DO_WHILE_COND_LABEL_100
						}
						goto CHECK_RANGE
					}
					if ((c == pcre_uint32((uint32('[')))) && (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(':')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('.'))) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('=')))) && (int32((check_posix_syntax(ptr, &tempptr))) != 0) {
						var local_negate BOOL = BOOL((int32(0)))
						var posix_class int32
						var taboffset int32
						var tabopt int32
						var cbits *pcre_uint8 = (*cd).cbits
						var pbits []pcre_uint8 = make([]pcre_uint8, 32, 32)
						if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32(':') {
							*errorcodeptr = ERR31
							goto FAILED
						}
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						if int32(uint8((*ptr))) == int32('^') {
							local_negate = BOOL((int32(1)))
							should_flip_negation = BOOL((int32(1)))
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
						posix_class = check_posix_name(ptr, (int32((int64(uintptr(unsafe.Pointer(tempptr))) - int64(uintptr(unsafe.Pointer(ptr)))))))
						if posix_class < int32(0) {
							*errorcodeptr = ERR30
							goto FAILED
						}
						if ((options & int32(1)) != int32(0)) && (posix_class <= int32(2)) {
							posix_class = int32(0)
						}
						if (options & int32(536870912)) != int32(0) {
							var ptype uint32 = uint32(int32(0))
							var pc int32 = int32((uint32(posix_class) + func() uint32 {
								if int32((BOOL((local_negate)))) != 0 {
									return ((224 / 8) / uint32(int32(2)))
								} else {
									return uint32(int32(0))
								}
							}()))
							if *((**pcre_uchar)(func() unsafe.Pointer {
								tempVar := &posix_substitutes[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(pc)*unsafe.Sizeof(*tempVar))
							}())) != nil {
								nestptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempptr))))
								ptr = ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := *((**pcre_uchar)(func() unsafe.Pointer {
										tempVar := &posix_substitutes[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(pc)*unsafe.Sizeof(*tempVar))
									}()))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))
								goto DO_WHILE_COND_LABEL_100
							} else {
								switch posix_class {
								case int32(8):
									{
										ptype = uint32(int32(11))
									}
									fallthrough
								case int32(9):
									{
										if ptype == uint32(int32(0)) {
											ptype = uint32(int32(12))
										}
									}
									fallthrough
								case int32(10):
									{
										if ptype == uint32(int32(0)) {
											ptype = uint32(int32(13))
										}
										*func() *pcre_uchar {
											defer func() {
												class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
											}()
											return class_uchardata
										}() = pcre_uchar((uint8(func() int32 {
											if int32((BOOL(local_negate))) != 0 {
												return int32(4)
											} else {
												return int32(3)
											}
										}())))
										*func() *pcre_uchar {
											defer func() {
												class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
											}()
											return class_uchardata
										}() = pcre_uchar((uint8(ptype)))
										*func() *pcre_uchar {
											defer func() {
												class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
											}()
											return class_uchardata
										}() = pcre_uchar(int32(0))
										xclass_has_prop = BOOL((int32(1)))
										ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempptr))))
										goto DO_WHILE_COND_LABEL_100
									}
									fallthrough
								default:
									{
										if (int32((local_negate)) != 0) && ((int32((xclass)) != 0) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempptr))))))) != int32(']'))) {
											*func() *pcre_uchar {
												defer func() {
													class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
												}()
												return class_uchardata
											}() = pcre_uchar(int32(2))
											class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(int32(256)), class_uchardata)))*unsafe.Sizeof(*class_uchardata))))
											class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(int32(1114111)), class_uchardata)))*unsafe.Sizeof(*class_uchardata))))
										}
										break
									}
								}
							}
						}
						posix_class *= int32(3)
						noarch.Memcpy(unsafe.Pointer(&pbits[0]), unsafe.Pointer(((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(*((*int32)(func() unsafe.Pointer {
							tempVar := &posix_class_maps[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(posix_class)*unsafe.Sizeof(*tempVar))
						}())))*unsafe.Sizeof(*cbits))))), int32((uint32(int32(32)) * 1)))
						taboffset = *((*int32)(func() unsafe.Pointer {
							tempVar := &posix_class_maps[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((posix_class+int32(1)))*unsafe.Sizeof(*tempVar))
						}()))
						tabopt = *((*int32)(func() unsafe.Pointer {
							tempVar := &posix_class_maps[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((posix_class+int32(2)))*unsafe.Sizeof(*tempVar))
						}()))
						if taboffset >= int32(0) {
							if tabopt >= int32(0) {
								for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
									*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &pbits[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
									}())) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(taboffset)))))))*unsafe.Sizeof(*cbits))))))))))
								}
							} else {
								for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
									*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &pbits[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
									}())) &= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(taboffset)))))))*unsafe.Sizeof(*cbits)))))))))))
								}
							}
						}
						if tabopt < int32(0) {
							tabopt = -tabopt
						}
						if tabopt == int32(1) {
							*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &pbits[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}())) &= pcre_uint8((^uint8(int32(60))))
						} else if tabopt == int32(2) {
							*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &pbits[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(11))*unsafe.Sizeof(*tempVar))
							}())) &= pcre_uint8((uint8(int32(127))))
						}
						if int32((BOOL(local_negate))) != 0 {
							for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
								*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &classbits[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}())) |= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &pbits[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}())))))))))
							}
						} else {
							for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
								*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &classbits[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}())) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &pbits[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))))))
							}
						}
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempptr))))
						class_has_8bitchar = int32(1)
						class_one_char = int32(2)
						goto DO_WHILE_COND_LABEL_100
					}
					if c == pcre_uint32((uint32('\\'))) {
						escape = check_escape(&ptr, &ec, errorcodeptr, int32((*cd).bracount), options, BOOL((int32(1))))
						if *errorcodeptr != int32(0) {
							goto FAILED
						}
						if escape == int32(0) {
							c = ec
						} else if escape == ESC_b {
							c = pcre_uint32((uint32('\b')))
						} else if escape == ESC_N {
							*errorcodeptr = ERR71
							goto FAILED
						} else if escape == ESC_Q {
							if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\\')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
							} else {
								inescq = BOOL((int32(1)))
							}
							goto DO_WHILE_COND_LABEL_100
						} else if escape == ESC_E {
							goto DO_WHILE_COND_LABEL_100
						} else {
							var cbits *pcre_uint8 = (*cd).cbits
							class_has_8bitchar += 1
							class_one_char += int32(2)
							switch escape {
							case ESC_du:
								fallthrough
							case ESC_DU:
								fallthrough
							case ESC_wu:
								fallthrough
							case ESC_WU:
								fallthrough
							case ESC_su:
								fallthrough
							case ESC_SU:
								{
									nestptr = ptr
									ptr = ((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := *((**pcre_uchar)(func() unsafe.Pointer {
											tempVar := &substitutes[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((escape-ESC_DU))*unsafe.Sizeof(*tempVar))
										}()))
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
									}()))
									class_has_8bitchar -= 1
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_d:
								{
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(64))))))))*unsafe.Sizeof(*cbits))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_D:
								{
									should_flip_negation = BOOL((int32(1)))
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(64))))))))*unsafe.Sizeof(*cbits)))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_w:
								{
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(160))))))))*unsafe.Sizeof(*cbits))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_W:
								{
									should_flip_negation = BOOL((int32(1)))
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(160))))))))*unsafe.Sizeof(*cbits)))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_s:
								{
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(0))))))))*unsafe.Sizeof(*cbits))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_S:
								{
									should_flip_negation = BOOL((int32(1)))
									for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
										*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &classbits[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
										}())) |= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(cbits)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(int32(0))))))))*unsafe.Sizeof(*cbits)))))))))))
									}
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_h:
								{
									_ = add_list_to_class(&classbits[0], &class_uchardata, options, cd, &_pcre_hspace_list[0], uint32(4294967295))
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_H:
								{
									_ = add_not_list_to_class(&classbits[0], &class_uchardata, options, cd, &_pcre_hspace_list[0])
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_v:
								{
									_ = add_list_to_class(&classbits[0], &class_uchardata, options, cd, &_pcre_vspace_list[0], uint32(4294967295))
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_V:
								{
									_ = add_not_list_to_class(&classbits[0], &class_uchardata, options, cd, &_pcre_vspace_list[0])
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							case ESC_p:
								fallthrough
							case ESC_P:
								{
									var negated BOOL
									var ptype uint32 = uint32(int32(0))
									var pdata uint32 = uint32(int32(0))
									if int32((NotBOOL(get_ucp(&ptr, &negated, &ptype, &pdata, errorcodeptr)))) != 0 {
										goto FAILED
									}
									*func() *pcre_uchar {
										defer func() {
											class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
										}()
										return class_uchardata
									}() = pcre_uchar((uint8(func() int32 {
										if (map[bool]int32{false: 0, true: 1}[((escape == ESC_p) != (int32((negated)) != 0))]) != 0 {
											return int32(3)
										} else {
											return int32(4)
										}
									}())))
									*func() *pcre_uchar {
										defer func() {
											class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
										}()
										return class_uchardata
									}() = pcre_uchar((uint8(ptype)))
									*func() *pcre_uchar {
										defer func() {
											class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
										}()
										return class_uchardata
									}() = pcre_uchar((uint8(pdata)))
									xclass_has_prop = BOOL((int32(1)))
									class_has_8bitchar -= 1
									goto DO_WHILE_COND_LABEL_100
								}
								fallthrough
							default:
								{
									if (options & int32(64)) != int32(0) {
										*errorcodeptr = ERR7
										goto FAILED
									}
									class_has_8bitchar -= 1
									class_one_char -= int32(2)
									c = pcre_uint32((uint32(uint8((*ptr)))))
									break
								}
							}
						}
						escape = int32(0)
					}
				CHECK_RANGE:
					;
					for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\\')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
						inescq = BOOL((int32(0)))
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
					}
					oldptr = ptr
					if (c == pcre_uint32((uint32('\r')))) || (c == pcre_uint32((uint32('\n')))) {
						(*cd).external_flags |= pcre_uint32((uint32(int32(2048))))
					}
					if (int32((NotBOOL(BOOL(inescq)))) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('-')) {
						var d pcre_uint32
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						for (int32(uint8((*ptr))) == int32('\\')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						}
						for (int32(uint8((*ptr))) == int32('\\')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('Q')) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
							if (int32(uint8((*ptr))) == int32('\\')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('E')) {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
								continue
							}
							inescq = BOOL((int32(1)))
							break
						}
						if (int32(uint8((*ptr))) == int32('\x00')) || ((int32((NotBOOL(BOOL(inescq)))) != 0) && (int32(uint8((*ptr))) == int32(']'))) {
							ptr = oldptr
							goto CLASS_SINGLE_CHARACTER
						}
						if int32((BOOL(utf))) != 0 {
							d = pcre_uint32((uint32(uint8((*ptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))
								}
							}
						} else {
							d = pcre_uint32((uint32(uint8((*ptr)))))
						}
						if int32((NotBOOL(BOOL(inescq)))) != 0 {
							if d == pcre_uint32((uint32('\\'))) {
								var descape int32
								descape = check_escape(&ptr, &d, errorcodeptr, int32((*cd).bracount), options, BOOL((int32(1))))
								if *errorcodeptr != int32(0) {
									goto FAILED
								}
								if descape != int32(0) {
									if descape == ESC_b {
										d = pcre_uint32((uint32('\b')))
									} else {
										*errorcodeptr = ERR83
										goto FAILED
									}
								}
							} else if ((d == pcre_uint32((uint32('[')))) && (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(':')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('.'))) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('=')))) && (int32((check_posix_syntax(ptr, &tempptr))) != 0) {
								*errorcodeptr = ERR83
								goto FAILED
							}
						}
						if d < c {
							*errorcodeptr = ERR8
							goto FAILED
						}
						if d == c {
							goto CLASS_SINGLE_CHARACTER
						}
						class_one_char = int32(2)
						if (d == pcre_uint32((uint32('\r')))) || (d == pcre_uint32((uint32('\n')))) {
							(*cd).external_flags |= pcre_uint32((uint32(int32(2048))))
						}
						class_has_8bitchar += add_to_class(&classbits[0], &class_uchardata, options, cd, pcre_uint32(c), pcre_uint32(d))
						goto DO_WHILE_COND_LABEL_100
					}
				CLASS_SINGLE_CHARACTER:
					;
					if class_one_char < int32(2) {
						class_one_char += 1
					}
					if (((int32((NotBOOL(BOOL(inescq)))) != 0) && (int32((NotBOOL(BOOL(xclass_has_prop)))) != 0)) && (class_one_char == int32(1))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(']')) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						zeroreqchar = reqchar
						zeroreqcharflags = reqcharflags
						if int32((BOOL(negate_class))) != 0 {
							var d int32
							if firstcharflags == pcre_int32((-int32(2))) {
								firstcharflags = pcre_int32((-int32(1)))
							}
							zerofirstchar = firstchar
							zerofirstcharflags = firstcharflags
							if ((int32((utf)) != 0) && ((options & int32(1)) != int32(0))) && ((func() int32 {
								tempVar := int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).caseset))))
								d = tempVar
								return tempVar
							}()) != int32(0)) {
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(OP_NOTPROP)))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar(int32(9))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(d)))
							} else {
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(func() int32 {
									if (map[bool]int32{false: 0, true: 1}[((options & int32(1)) != int32(0))]) != 0 {
										return OP_NOTI
									} else {
										return OP_NOT
									}
								}())))
								if (int32((utf)) != 0) && (c > pcre_uint32((uint32(int32(127))))) {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(c), code)))*unsafe.Sizeof(*code))))
								} else {
									*func() *pcre_uchar {
										defer func() {
											code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
										}()
										return code
									}() = pcre_uchar((uint8(uint32((c)))))
								}
							}
							goto END_CLASS
						}
						if (int32((utf)) != 0) && (c > pcre_uint32((uint32(int32(127))))) {
							mclength = _pcre_ord2utf(pcre_uint32(c), &mcbuffer[0])
						} else {
							*&mcbuffer[0] = pcre_uchar((uint8(uint32((c)))))
							mclength = uint32(int32(1))
						}
						goto ONE_CHAR
					}
					class_has_8bitchar += add_to_class(&classbits[0], &class_uchardata, options, cd, pcre_uint32(c), pcre_uint32(c))
				DO_WHILE_COND_LABEL_100:
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((((func() pcre_uint32 {
						tempVar := pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							return ptr
						}())))))
						c = tempVar
						return tempVar
					}()) != pcre_uint32((uint32('\x00')))) || ((nestptr != nil) && (func() pcre_uint32 {
						ptr = nestptr
						nestptr = nil
						return (func() pcre_uint32 {
							c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								return ptr
							}())))))
							return c
						}())
					}() != pcre_uint32((uint32('\x00')))))) && ((c != pcre_uint32((uint32(']')))) || (int32((inescq)) != 0)))])) != 0 {
						break
					}
				}
			}
			if c == pcre_uint32((uint32('\x00'))) {
				*errorcodeptr = ERR6
				goto FAILED
			}
			if int64(uintptr(unsafe.Pointer(class_uchardata))) > int64(uintptr(unsafe.Pointer(class_uchardata_base))) {
				xclass = BOOL((int32(1)))
			}
			if firstcharflags == pcre_int32((-int32(2))) {
				firstcharflags = pcre_int32((-int32(1)))
			}
			zerofirstchar = firstchar
			zerofirstcharflags = firstcharflags
			zeroreqchar = reqchar
			zeroreqcharflags = reqcharflags
			if (int32((xclass)) != 0) && (((int32((xclass_has_prop)) != 0) || (int32((NotBOOL(BOOL(should_flip_negation)))) != 0)) || ((options & int32(536870912)) != int32(0))) {
				if (((int32((utf)) != 0) && (int32((should_flip_negation)) != 0)) && (int32((NotBOOL(BOOL(negate_class)))) != 0)) && ((options & int32(536870912)) == int32(0)) {
					*func() *pcre_uchar {
						defer func() {
							class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
						}()
						return class_uchardata
					}() = pcre_uchar(int32(2))
					if int32((BOOL(utf))) != 0 {
						class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(int32(256)), class_uchardata)))*unsafe.Sizeof(*class_uchardata))))
						class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(int32(_pcre_ord2utf(pcre_uint32(int32(1114111)), class_uchardata)))*unsafe.Sizeof(*class_uchardata))))
					} else {
					}
				}
				*func() *pcre_uchar {
					defer func() {
						class_uchardata = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(1)*unsafe.Sizeof(*class_uchardata))))
					}()
					return class_uchardata
				}() = pcre_uchar(int32(0))
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = pcre_uchar((uint8(OP_XCLASS)))
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				*code = pcre_uchar((uint8(func() int32 {
					if int32((BOOL(negate_class))) != 0 {
						return int32(1)
					} else {
						return int32(0)
					}
				}())))
				if int32((BOOL(xclass_has_prop))) != 0 {
					*code |= pcre_uchar((uint8(int32(4))))
				}
				if class_has_8bitchar > int32(0) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() |= pcre_uchar((uint8(int32(2))))
					noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*code))))), unsafe.Pointer(code), int32(uint32((int32((int64(uintptr(unsafe.Pointer(class_uchardata))) - int64(uintptr(unsafe.Pointer(code)))))))))
					if (int32((negate_class)) != 0) && (int32((NotBOOL(BOOL(xclass_has_prop)))) != 0) {
						for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
							*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &classbits[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
							}())) = pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &classbits[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
							}())))))))))
						}
					}
					noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(&classbits[0]), int32(uint32(int32(32))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(class_uchardata)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*class_uchardata))))
				} else {
					code = class_uchardata
				}
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(previous)))))) >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(previous)))))) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*previous))))
				}()
				goto SW_GENERATED_LABEL_127
			}
			if lengthptr != nil {
				*lengthptr += (int32((int64(uintptr(unsafe.Pointer(class_uchardata))) - int64(uintptr(unsafe.Pointer(class_uchardata_base))))))
			}
			*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}() = pcre_uchar((uint8(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(negate_class == should_flip_negation)]) != 0 {
					return OP_CLASS
				} else {
					return OP_NCLASS
				}
			}())))
			if lengthptr == nil {
				if int32((BOOL(negate_class))) != 0 {
					for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
						*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &classbits[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
						}())) = pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &classbits[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
						}())))))))))
					}
				}
				noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(&classbits[0]), int32(uint32(int32(32))))
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*code))))
		}
	END_CLASS:
		{
			goto SW_GENERATED_LABEL_127
		}
	SW_GENERATED_LABEL_136:
		{
			if int32((NotBOOL(BOOL(is_quantifier)))) != 0 {
				goto NORMAL_CHAR
			}
			ptr = read_repeat_counts(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr)))), &repeat_min, &repeat_max, errorcodeptr)
			if *errorcodeptr != int32(0) {
				goto FAILED
			}
			goto REPEAT
		}
	SW_GENERATED_LABEL_137:
		{
			repeat_min = int32(0)
			repeat_max = -int32(1)
			goto REPEAT
		}
	SW_GENERATED_LABEL_138:
		{
			repeat_min = int32(1)
			repeat_max = -int32(1)
			goto REPEAT
		}
	SW_GENERATED_LABEL_139:
		{
			repeat_min = int32(0)
			repeat_max = int32(1)
		}
	REPEAT:
		{
			var goto_OUTPUT_SINGLE_REPEAT bool
			if previous == nil {
				*errorcodeptr = ERR9
				goto FAILED
			}
			if repeat_min == int32(0) {
				firstchar = zerofirstchar
				firstcharflags = zerofirstcharflags
				reqchar = zeroreqchar
				reqcharflags = zeroreqcharflags
			}
			reqvary = pcre_int32((func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(repeat_min == repeat_max)]) != 0 {
					return int32(0)
				} else {
					return (int32(1) << uint64(int32(1)))
				}
			}()))
			op_type = int32(0)
			possessive_quantifier = BOOL((int32(0)))
			tempcode = previous
			if (options & int32(8)) != int32(0) {
				var p *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))
				for {
					for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*p))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(1)) != int32(0)) {
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}
					if int32(uint8((*p))) != int32('#') {
						break
					}
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					for int32(uint8((*p))) != int32('\x00') {
						if (func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((*cd).nltype != int32(0))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer((*cd).end_pattern)))) && (int32((_pcre_is_newline((p), (*cd).nltype, (*cd).end_pattern, &((*cd).nllen), BOOL(utf)))) != 0))])
							} else {
								return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(p))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).end_pattern
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*cd).nllen)*unsafe.Sizeof(*tempVar))
								}())))))) && (int32(uint8((*p))) == int32(uint8((*&(*cd).nl[0]))))) && (((*cd).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*p))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := &(*cd).nl[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))))))))])
							}
						}()) != 0 {
							p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((*cd).nllen)*unsafe.Sizeof(*p))))
							break
						}
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
						if int32((BOOL(utf))) != 0 {
							for (int32(uint8((*p))) & int32(192)) == int32(128) {
								p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
							}
						}
					}
				}
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - (uintptr)(int32(1))*unsafe.Sizeof(*p))))
			}
			if ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('(')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('?'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) == int32('#')) {
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))
				for (int32(uint8((*ptr))) != int32('\x00')) && (int32(uint8((*ptr))) != int32(')')) {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
				if int32(uint8((*ptr))) == int32('\x00') {
					*errorcodeptr = ERR18
					goto FAILED
				}
			}
			if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('+') {
				repeat_type = int32(0)
				possessive_quantifier = BOOL((int32(1)))
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
			} else if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('?') {
				repeat_type = greedy_non_default
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
			} else {
				repeat_type = greedy_default
			}
			if int32(uint8((*previous))) == OP_RECURSE {
				noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))), unsafe.Pointer(previous), int32(uint32((int32(1) + int32(2)))))
				*previous = pcre_uchar((uint8(OP_ONCE)))
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32(2) + (int32(2) * int32(2))) >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32(2) + (int32(2) * int32(2))) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*previous))))
				}()
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(2)+(int32(2)*int32(2))))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(OP_KET)))
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(3)+(int32(2)*int32(2))))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32(2) + (int32(2) * int32(2))) >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(3)+(int32(2)*int32(2))))*unsafe.Sizeof(*previous))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(((int32(3)+(int32(2)*int32(2)))+int32(1)))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8(((int32(2) + (int32(2) * int32(2))) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(((int32(3)+(int32(2)*int32(2)))+int32(1)))*unsafe.Sizeof(*previous))))
				}()
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+(int32(2)*int32(2))))*unsafe.Sizeof(*code))))
				length_prevgroup = (int32(3) + (int32(3) * int32(2)))
				if (lengthptr == nil) && (int64(uintptr(unsafe.Pointer((*cd).hwm))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*cd).start_workspace
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())))))) {
					var offset int32 = ((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*cd).hwm)
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(2)*unsafe.Sizeof(*tempVar))
					}()))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*cd).hwm)
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(1)*unsafe.Sizeof(*tempVar))
					}()))))))
					if offset == int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous))))))) - int64(uintptr(unsafe.Pointer((*cd).start_code))))) {
						func() pcre_uchar {
							*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).hwm
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(2)*unsafe.Sizeof(*tempVar))
							}())) = pcre_uchar((uint8((((offset + int32(1)) + int32(2)) >> uint64(int32(8))))))
							return *((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).hwm
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(2)*unsafe.Sizeof(*tempVar))
							}()))
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).hwm
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(1)*unsafe.Sizeof(*tempVar))
							}())) = pcre_uchar((uint8((((offset + int32(1)) + int32(2)) & int32(255)))))
							return *((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).hwm
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(1)*unsafe.Sizeof(*tempVar))
							}()))
						}()
					}
				}
			}
		OUTPUT_SINGLE_REPEAT_CONTAINER:
			if !goto_OUTPUT_SINGLE_REPEAT && ((((int32(uint8((*previous))) == OP_CHAR) || (int32(uint8((*previous))) == OP_CHARI)) || (int32(uint8((*previous))) == OP_NOT)) || (int32(uint8((*previous))) == OP_NOTI)) {
				switch int32(uint8((pcre_uchar(*previous)))) {
				default:
					fallthrough
				case OP_CHAR:
					{
						op_type = (OP_STAR - OP_STAR)
					}
				case OP_CHARI:
					{
						op_type = (OP_STARI - OP_STAR)
					}
				case OP_NOT:
					{
						op_type = (OP_NOTSTAR - OP_STAR)
					}
				case OP_NOTI:
					{
						op_type = (OP_NOTSTARI - OP_STAR)
						break
					}
				}
				if (int32((utf)) != 0) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code))))))) & int32(192)) == int32(128)) {
					var lastchar *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(int32(1))*unsafe.Sizeof(*code))))
					for (int32(uint8((*lastchar))) & int32(192)) == int32(128) {
						lastchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastchar)) - (uintptr)(1)*unsafe.Sizeof(*lastchar))))
					}
					c = pcre_uint32((uint32((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(lastchar)))))))))
					noarch.Memcpy(unsafe.Pointer(&utf_chars[0]), unsafe.Pointer(lastchar), int32(uint32((pcre_uint32((c))))))
					c |= pcre_uint32((uint32(268435456)))
				} else {
					c = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))))
					if (int32(uint8((*previous))) <= OP_CHARI) && (repeat_min > int32(1)) {
						reqchar = c
						reqcharflags = (req_caseopt | pcre_int32(((*cd).req_varyopt)))
					}
				}
				goto_OUTPUT_SINGLE_REPEAT = true
				goto OUTPUT_SINGLE_REPEAT_CONTAINER
			} else if goto_OUTPUT_SINGLE_REPEAT || int32(uint8((*previous))) < OP_EODN {
				var oldcode *pcre_uchar
				var prop_type int32
				var prop_value int32
				if goto_OUTPUT_SINGLE_REPEAT {
					goto_OUTPUT_SINGLE_REPEAT = false
					goto OUTPUT_SINGLE_REPEAT
				}
				op_type = (OP_TYPESTAR - OP_STAR)
				c = pcre_uint32((uint32(uint8((*previous)))))
			OUTPUT_SINGLE_REPEAT:
				;
				if (int32(uint8((*previous))) == OP_PROP) || (int32(uint8((*previous))) == OP_NOTPROP) {
					prop_type = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous)))))))
					prop_value = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(2))*unsafe.Sizeof(*previous)))))))
				} else {
					prop_value = -int32(1)
					prop_type = prop_value
				}
				oldcode = code
				code = previous
				if repeat_max == int32(0) {
					goto END_REPEAT
				}
				repeat_type += op_type
				if repeat_min == int32(0) {
					if repeat_max == -int32(1) {
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_STAR + repeat_type))))
					} else if repeat_max == int32(1) {
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_QUERY + repeat_type))))
					} else {
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_UPTO + repeat_type))))
						*code = pcre_uchar((uint8((repeat_max >> uint64(int32(8))))))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((repeat_max & int32(255)))))
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				} else if repeat_min == int32(1) {
					if repeat_max == -int32(1) {
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_PLUS + repeat_type))))
					} else {
						code = oldcode
						if repeat_max == int32(1) {
							goto END_REPEAT
						}
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_UPTO + repeat_type))))
						*code = pcre_uchar((uint8(((repeat_max - int32(1)) >> uint64(int32(8))))))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((repeat_max - int32(1)) & int32(255)))))
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					}
				} else {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8((OP_EXACT + op_type))))
					*code = pcre_uchar((uint8((repeat_min >> uint64(int32(8))))))
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((repeat_min & int32(255)))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					if repeat_max < int32(0) {
						if (int32((utf)) != 0) && ((int32(uint32((c))) & 268435456) != int32(0)) {
							noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(&utf_chars[0]), int32((uint32((c & pcre_uint32((uint32(int32(7)))))))))
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint32((c&pcre_uint32((uint32(int32(7))))))))*unsafe.Sizeof(*code))))
						} else {
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8(uint32((c)))))
							if prop_type >= int32(0) {
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(prop_type)))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(prop_value)))
							}
						}
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8((OP_STAR + repeat_type))))
					} else if repeat_max != repeat_min {
						if (int32((utf)) != 0) && ((int32(uint32((c))) & 268435456) != int32(0)) {
							noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(&utf_chars[0]), int32((uint32((c & pcre_uint32((uint32(int32(7)))))))))
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint32((c&pcre_uint32((uint32(int32(7))))))))*unsafe.Sizeof(*code))))
						} else {
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8(uint32((c)))))
						}
						if prop_type >= int32(0) {
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8(prop_type)))
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8(prop_value)))
						}
						repeat_max -= repeat_min
						if repeat_max == int32(1) {
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8((OP_QUERY + repeat_type))))
						} else {
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8((OP_UPTO + repeat_type))))
							*code = pcre_uchar((uint8((repeat_max >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((repeat_max & int32(255)))))
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
						}
					}
				}
				if (int32((utf)) != 0) && ((int32(uint32((c))) & 268435456) != int32(0)) {
					noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(&utf_chars[0]), int32((uint32((c & pcre_uint32((uint32(int32(7)))))))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint32((c&pcre_uint32((uint32(int32(7))))))))*unsafe.Sizeof(*code))))
				} else {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(uint32((c)))))
				}
				if prop_type >= int32(0) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(prop_type)))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(prop_value)))
				}
			} else if ((((((int32(uint8((*previous))) == OP_CLASS) || (int32(uint8((*previous))) == OP_NCLASS)) || (int32(uint8((*previous))) == OP_XCLASS)) || (int32(uint8((*previous))) == OP_REF)) || (int32(uint8((*previous))) == OP_REFI)) || (int32(uint8((*previous))) == OP_DNREF)) || (int32(uint8((*previous))) == OP_DNREFI) {
				if repeat_max == int32(0) {
					code = previous
					goto END_REPEAT
				}
				if (repeat_min == int32(0)) && (repeat_max == -int32(1)) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8((OP_CRSTAR + repeat_type))))
				} else if (repeat_min == int32(1)) && (repeat_max == -int32(1)) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8((OP_CRPLUS + repeat_type))))
				} else if (repeat_min == int32(0)) && (repeat_max == int32(1)) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8((OP_CRQUERY + repeat_type))))
				} else {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8((OP_CRRANGE + repeat_type))))
					*code = pcre_uchar((uint8((repeat_min >> uint64(int32(8))))))
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((repeat_min & int32(255)))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					if repeat_max == -int32(1) {
						repeat_max = int32(0)
					}
					*code = pcre_uchar((uint8((repeat_max >> uint64(int32(8))))))
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((repeat_max & int32(255)))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				}
			} else if (int32(uint8((*previous))) >= OP_ASSERT) && (int32(uint8((*previous))) <= OP_COND) {
				var i int32
				var len int32 = (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(previous))))))
				var base_hwm_offset size_t = item_hwm_offset
				var bralink *pcre_uchar = nil
				var brazeroptr *pcre_uchar = nil
				if (int32(uint8((*previous))) == OP_COND) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*previous))))))) == OP_DEF) {
					goto END_REPEAT
				}
				if int32(uint8((*previous))) < OP_ONCE {
					if repeat_min > int32(0) {
						goto END_REPEAT
					}
					if (repeat_max < int32(0)) || (repeat_max > int32(1)) {
						repeat_max = int32(1)
					}
				}
				if repeat_min == int32(0) {
					if repeat_max <= int32(1) {
						*code = pcre_uchar((uint8(OP_END)))
						adjust_recurse(previous, int32(1), BOOL(utf), cd, size_t(item_hwm_offset))
						noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(1))*unsafe.Sizeof(*previous))))), unsafe.Pointer(previous), int32(uint32((len))))
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						if repeat_max == int32(0) {
							*func() *pcre_uchar {
								defer func() {
									previous = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(1)*unsafe.Sizeof(*previous))))
								}()
								return previous
							}() = pcre_uchar((uint8(OP_SKIPZERO)))
							goto END_REPEAT
						}
						brazeroptr = previous
						*func() *pcre_uchar {
							defer func() {
								previous = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(1)*unsafe.Sizeof(*previous))))
							}()
							return previous
						}() = pcre_uchar((uint8((OP_BRAZERO + repeat_type))))
					} else {
						var offset int32
						*code = pcre_uchar((uint8(OP_END)))
						adjust_recurse(previous, (int32(2) + int32(2)), BOOL(utf), cd, size_t(item_hwm_offset))
						noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(2))*unsafe.Sizeof(*previous))))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))), unsafe.Pointer(previous), int32(uint32((len))))
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code))))
						*func() *pcre_uchar {
							defer func() {
								previous = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(1)*unsafe.Sizeof(*previous))))
							}()
							return previous
						}() = pcre_uchar((uint8((OP_BRAZERO + repeat_type))))
						*func() *pcre_uchar {
							defer func() {
								previous = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(1)*unsafe.Sizeof(*previous))))
							}()
							return previous
						}() = pcre_uchar((uint8(OP_BRA)))
						offset = func() int32 {
							if (map[bool]int32{false: 0, true: 1}[(bralink == nil)]) != 0 {
								return int32(0)
							} else {
								return (int32((int64(uintptr(unsafe.Pointer(previous))) - int64(uintptr(unsafe.Pointer(bralink))))))
							}
						}()
						bralink = previous
						func() pcre_uchar {
							*previous = pcre_uchar((uint8((offset >> uint64(int32(8))))))
							return *previous
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*previous)))) = pcre_uchar((uint8((offset & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*previous))))
						}()
						previous = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(previous)) + (uintptr)(int32(2))*unsafe.Sizeof(*previous))))
					}
					repeat_max -= 1
				} else {
					if repeat_min > int32(1) {
						if lengthptr != nil {
							var delta int32 = ((repeat_min - int32(1)) * length_prevgroup)
							if ((int64_t((repeat_min - int32(1))) * int64_t(length_prevgroup)) > int64_t(int32(2147483647))) || (((int32(2147483647) - int32(20)) - *lengthptr) < delta) {
								*errorcodeptr = ERR20
								goto FAILED
							}
							*lengthptr += delta
						} else {
							if (int32((groupsetfirstchar)) != 0) && (reqcharflags < pcre_int32((int32(0)))) {
								reqchar = firstchar
								reqcharflags = firstcharflags
							}
							for i = int32(1); i < repeat_min; i++ {
								var hc *pcre_uchar
								var this_hwm_offset size_t = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
								noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(previous), int32(uint32((len))))
								for int64(uintptr(unsafe.Pointer((*cd).hwm))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*cd).start_workspace
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
										}()))
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(100))*unsafe.Sizeof(*tempVar))
									}()))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((this_hwm_offset-base_hwm_offset))))*unsafe.Sizeof(*tempVar))
								}()))))) {
									*errorcodeptr = expand_workspace(cd)
									if *errorcodeptr != int32(0) {
										goto FAILED
									}
								}
								for hc = ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).start_workspace
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((base_hwm_offset))))*unsafe.Sizeof(*tempVar))
								}())); int64(uintptr(unsafe.Pointer(hc))) < int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).start_workspace
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((this_hwm_offset))))*unsafe.Sizeof(*tempVar))
								}()))))); hc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)(int32(2))*unsafe.Sizeof(*hc)))) {
									func() pcre_uchar {
										*(*cd).hwm = pcre_uchar((uint8(((((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc))))))))) + len) >> uint64(int32(8))))))
										return *(*cd).hwm
									}()
									func() pcre_uchar {
										*((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*cd).hwm
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
										}())) = pcre_uchar((uint8(((((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc))))))))) + len) & int32(255)))))
										return *((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*cd).hwm
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
										}()))
									}()
									(*cd).hwm = ((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*cd).hwm
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
									}()))
								}
								base_hwm_offset = this_hwm_offset
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(len)*unsafe.Sizeof(*code))))
							}
						}
					}
					if repeat_max > int32(0) {
						repeat_max -= repeat_min
					}
				}
				if repeat_max >= int32(0) {
					if (lengthptr != nil) && (repeat_max > int32(0)) {
						var delta int32 = (((repeat_max * (((length_prevgroup + int32(1)) + int32(2)) + (int32(2) * int32(2)))) - int32(2)) - (int32(2) * int32(2)))
						if ((int64_t(repeat_max) * int64_t((((length_prevgroup + int32(1)) + int32(2)) + (int32(2) * int32(2))))) > int64_t(int32(2147483647))) || (((int32(2147483647) - int32(20)) - *lengthptr) < delta) {
							*errorcodeptr = ERR20
							goto FAILED
						}
						*lengthptr += delta
					} else {
						for i = (repeat_max - int32(1)); i >= int32(0); i-- {
							var hc *pcre_uchar
							var this_hwm_offset size_t = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8((OP_BRAZERO + repeat_type))))
							if i != int32(0) {
								var offset int32
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(OP_BRA)))
								offset = func() int32 {
									if (map[bool]int32{false: 0, true: 1}[(bralink == nil)]) != 0 {
										return int32(0)
									} else {
										return (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(bralink))))))
									}
								}()
								bralink = code
								func() pcre_uchar {
									*code = pcre_uchar((uint8((offset >> uint64(int32(8))))))
									return *code
								}()
								func() pcre_uchar {
									*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((offset & int32(255)))))
									return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
								}()
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
							}
							noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(previous), int32(uint32((len))))
							for int64(uintptr(unsafe.Pointer((*cd).hwm))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*cd).start_workspace
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
									}()))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(100))*unsafe.Sizeof(*tempVar))
								}()))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(uint32((this_hwm_offset-base_hwm_offset))))*unsafe.Sizeof(*tempVar))
							}()))))) {
								*errorcodeptr = expand_workspace(cd)
								if *errorcodeptr != int32(0) {
									goto FAILED
								}
							}
							for hc = ((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).start_workspace
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((base_hwm_offset))))*unsafe.Sizeof(*tempVar))
							}())); int64(uintptr(unsafe.Pointer(hc))) < int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).start_workspace
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((this_hwm_offset))))*unsafe.Sizeof(*tempVar))
							}()))))); hc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(hc)) + (uintptr)(int32(2))*unsafe.Sizeof(*hc)))) {
								func() pcre_uchar {
									*(*cd).hwm = pcre_uchar((uint8((((((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc))))))))) + len) + func() int32 {
										if (map[bool]int32{false: 0, true: 1}[(i != int32(0))]) != 0 {
											return (int32(2) + int32(2))
										} else {
											return int32(1)
										}
									}()) >> uint64(int32(8))))))
									return *(*cd).hwm
								}()
								func() pcre_uchar {
									*((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*cd).hwm
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
									}())) = pcre_uchar((uint8((((((int32(uint8((*(hc)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((hc))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(hc))))))))) + len) + func() int32 {
										if (map[bool]int32{false: 0, true: 1}[(i != int32(0))]) != 0 {
											return (int32(2) + int32(2))
										} else {
											return int32(1)
										}
									}()) & int32(255)))))
									return *((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*cd).hwm
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
									}()))
								}()
								(*cd).hwm = ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).hwm
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
								}()))
							}
							base_hwm_offset = this_hwm_offset
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(len)*unsafe.Sizeof(*code))))
						}
					}
					for bralink != nil {
						var oldlinkoffset int32
						var offset int32 = (int32(((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(bralink)))) + int64(int32(1)))))
						var bra *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(offset)*unsafe.Sizeof(*code))))
						oldlinkoffset = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((bra))) + (uintptr)(int32(1))*unsafe.Sizeof(*(bra)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((bra))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(bra)))))))))
						bralink = func() *pcre_uchar {
							if (map[bool]int32{false: 0, true: 1}[(oldlinkoffset == int32(0))]) != 0 {
								return nil
							} else {
								return ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bralink)) - (uintptr)(oldlinkoffset)*unsafe.Sizeof(*bralink))))
							}
						}()
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8(OP_KET)))
						func() pcre_uchar {
							*code = pcre_uchar((uint8((offset >> uint64(int32(8))))))
							return *code
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((offset & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
						}()
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bra)) + (uintptr)(int32(1))*unsafe.Sizeof(*bra)))) = pcre_uchar((uint8((offset >> uint64(int32(8))))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bra)) + (uintptr)(int32(1))*unsafe.Sizeof(*bra))))
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bra)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*bra)))) = pcre_uchar((uint8((offset & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bra)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*bra))))
						}()
					}
				} else {
					var ketcode *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(int32(1))*unsafe.Sizeof(*code))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}()))
					var bracode *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ketcode)) - (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ketcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ketcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ketcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ketcode))))))))))*unsafe.Sizeof(*ketcode))))
					if ((int32(uint8((*bracode))) == OP_ONCE) || (int32(uint8((*bracode))) == OP_ONCE_NC)) && (int32((possessive_quantifier)) != 0) {
						*bracode = pcre_uchar((uint8(OP_BRA)))
					}
					if (int32(uint8((*bracode))) == OP_ONCE) || (int32(uint8((*bracode))) == OP_ONCE_NC) {
						*ketcode = pcre_uchar((uint8((OP_KETRMAX + repeat_type))))
					} else {
						if lengthptr == nil {
							var scode *pcre_uchar = bracode
							for {
								if int32((could_be_empty_branch(scode, ketcode, BOOL(utf), cd, nil))) != 0 {
									*bracode += pcre_uchar((uint8((OP_SBRA - OP_BRA))))
									break
								}
								scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))))*unsafe.Sizeof(*scode))))
								if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*scode))) == OP_ALT)])) != 0 {
									break
								}
							}
						}
						if (int32(uint8((*bracode))) == OP_COND) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((bracode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(bracode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((bracode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(bracode))))))))))*unsafe.Sizeof(*bracode))))))) != OP_ALT) {
							*bracode = pcre_uchar((uint8(OP_SCOND)))
						}
						if int32((BOOL(possessive_quantifier))) != 0 {
							if (int32(uint8((*bracode))) == OP_COND) || (int32(uint8((*bracode))) == OP_SCOND) {
								var nlen int32 = (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(bracode))))))
								*code = pcre_uchar((uint8(OP_END)))
								adjust_recurse(bracode, (int32(1) + int32(2)), BOOL(utf), cd, size_t(item_hwm_offset))
								noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)(int32(1))*unsafe.Sizeof(*bracode))))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
								}()))), unsafe.Pointer(bracode), int32(uint32((nlen))))
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
								nlen += (int32(1) + int32(2))
								*bracode = pcre_uchar((uint8(func() int32 {
									if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*bracode))) == OP_COND)]) != 0 {
										return OP_BRAPOS
									} else {
										return OP_SBRAPOS
									}
								}())))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(OP_KETRPOS)))
								func() pcre_uchar {
									*code = pcre_uchar((uint8((nlen >> uint64(int32(8))))))
									return *code
								}()
								func() pcre_uchar {
									*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((nlen & int32(255)))))
									return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
								}()
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
								func() pcre_uchar {
									*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)(int32(1))*unsafe.Sizeof(*bracode)))) = pcre_uchar((uint8((nlen >> uint64(int32(8))))))
									return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)(int32(1))*unsafe.Sizeof(*bracode))))
								}()
								func() pcre_uchar {
									*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*bracode)))) = pcre_uchar((uint8((nlen & int32(255)))))
									return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(bracode)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*bracode))))
								}()
							} else {
								*bracode += pcre_uchar((uint8(int32(1))))
								*ketcode = pcre_uchar((uint8(OP_KETRPOS)))
							}
							if brazeroptr != nil {
								*brazeroptr = pcre_uchar((uint8(OP_BRAPOSZERO)))
							}
							if repeat_min < int32(2) {
								possessive_quantifier = BOOL((int32(0)))
							}
						} else {
							*ketcode = pcre_uchar((uint8((OP_KETRMAX + repeat_type))))
						}
					}
				}
			} else if int32(uint8((*previous))) == OP_FAIL {
				goto END_REPEAT
			} else {
				*errorcodeptr = ERR11
				goto FAILED
			}
			if int32((BOOL(possessive_quantifier))) != 0 {
				var len int32
				switch int32(uint8((pcre_uchar(*tempcode)))) {
				case OP_TYPEEXACT:
					{
						tempcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_OP_lengths[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*tempcode))))*unsafe.Sizeof(*tempVar))
						}())))))+func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tempcode))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tempcode))))))) == OP_NOTPROP))]) != 0 {
								return int32(2)
							} else {
								return int32(0)
							}
						}()))*unsafe.Sizeof(*tempcode))))
					}
				case OP_CHAR:
					fallthrough
				case OP_CHARI:
					fallthrough
				case OP_NOT:
					fallthrough
				case OP_NOTI:
					fallthrough
				case OP_EXACT:
					fallthrough
				case OP_EXACTI:
					fallthrough
				case OP_NOTEXACT:
					fallthrough
				case OP_NOTEXACTI:
					{
						tempcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_OP_lengths[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*tempcode))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempcode))))
						if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) - (uintptr)(1)*unsafe.Sizeof(*tempcode))))))) >= int32(192)) {
							tempcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_utf8_table4[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) - (uintptr)(1)*unsafe.Sizeof(*tempcode)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempcode))))
						}
					}
				case OP_CLASS:
					fallthrough
				case OP_NCLASS:
					{
						tempcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32((uint32(int32(1))+(uint32(int32(32))/1))))*unsafe.Sizeof(*tempcode))))
					}
				case OP_XCLASS:
					{
						tempcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tempcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tempcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tempcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tempcode))))))))))*unsafe.Sizeof(*tempcode))))
						break
					}
				}
				len = (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(tempcode))))))
				if len > int32(0) {
					var repcode uint32 = uint32(uint8((*tempcode)))
					if (repcode < uint32(OP_CALLOUT)) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &opcode_possessify[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(repcode))*unsafe.Sizeof(*tempVar))
					}()))))) > int32(0)) {
						*tempcode = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &opcode_possessify[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(repcode))*unsafe.Sizeof(*tempVar))
						}()))))))
					} else {
						*code = pcre_uchar((uint8(OP_END)))
						adjust_recurse(tempcode, (int32(1) + int32(2)), BOOL(utf), cd, size_t(item_hwm_offset))
						noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempcode))))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))), unsafe.Pointer(tempcode), int32(uint32((len))))
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
						len += (int32(1) + int32(2))
						*tempcode = pcre_uchar((uint8(OP_ONCE)))
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8(OP_KET)))
						func() pcre_uchar {
							*code = pcre_uchar((uint8((len >> uint64(int32(8))))))
							return *code
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((len & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
						}()
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempcode)))) = pcre_uchar((uint8((len >> uint64(int32(8))))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempcode))))
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*tempcode)))) = pcre_uchar((uint8((len & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempcode)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*tempcode))))
						}()
					}
				}
			}
		}
	END_REPEAT:
		{
			previous = nil
			(*cd).req_varyopt |= int32((reqvary))
			goto SW_GENERATED_LABEL_127
		}
	NAMED_REF_OR_RECURSE_CONTAINER_OUTER:
		;
	HANDLE_RECURSION_CONTAINER_OUTER:
		;
	SW_GENERATED_LABEL_140:
		{
			var goto_NUMBERED_GROUP bool
			if goto_HANDLE != 0 {
				goto HANDLE_RECURSION_CONTAINER_MIDDLE
			}
			if goto_NAMED_REF_OR_RECURSE {
				goto NAMED_REF_OR_RECURSE_CONTAINER
			}
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
			if (int32(uint8((*ptr))) == int32('*')) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32(':')) || ((int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*cd).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(2)) != int32(0)))) {
				var i int32
				var namelen int32
				var arglen int32 = int32(0)
				var vn *byte = &verbnames[0]
				var name *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))
				var arg *pcre_uchar = nil
				previous = nil
				ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := (*cd).ctypes
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
				}()))))) & int32(2)) != int32(0)) {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
				namelen = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(name))))))
				if int32(uint8((*ptr))) == int32(':') {
					arg = func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()
					for (int32(uint8((*ptr))) != int32('\x00')) && (int32(uint8((*ptr))) != int32(')')) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					}
					arglen = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(arg))))))
					if uint32(arglen) > uint32(((1 << uint64(int32(8))) - int32(uint32(int32(1))))) {
						*errorcodeptr = ERR75
						goto FAILED
					}
				}
				if int32(uint8((*ptr))) != int32(')') {
					*errorcodeptr = ERR60
					goto FAILED
				}
				for i = int32(0); i < verbcount; i++ {
					if (namelen == (*((*verbitem)(func() unsafe.Pointer {
						tempVar := &verbs[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
					}()))).len) && (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (vn), int32(uint32((namelen)))) == int32(0)) {
						var setverb int32
						if (*((*verbitem)(func() unsafe.Pointer {
							tempVar := &verbs[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
						}()))).op == OP_ACCEPT {
							var oc *open_capitem
							if arglen != int32(0) {
								*errorcodeptr = ERR59
								goto FAILED
							}
							(*cd).had_accept = BOOL((int32(1)))
							for oc = (*cd).open_caps; oc != nil; oc = (*oc).next {
								if lengthptr != nil {
									*lengthptr += (int32(1) + int32(2))
								} else {
									*func() *pcre_uchar {
										defer func() {
											code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
										}()
										return code
									}() = pcre_uchar((uint8(OP_CLOSE)))
									*code = pcre_uchar((uint8((int32(uint16(((*oc).number))) >> uint64(int32(8))))))
									*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(uint16(((*oc).number))) & int32(255)))))
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
								}
							}
							setverb = int32(uint8((func() pcre_uchar {
								tempVar := pcre_uchar((uint8(func() int32 {
									if (map[bool]int32{false: 0, true: 1}[((*cd).assert_depth > int32(0))]) != 0 {
										return OP_ASSERT_ACCEPT
									} else {
										return OP_ACCEPT
									}
								}())))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = tempVar
								return tempVar
							}())))
							if firstcharflags == pcre_int32((-int32(2))) {
								firstcharflags = pcre_int32((-int32(1)))
							}
						} else if arglen == int32(0) {
							if (*((*verbitem)(func() unsafe.Pointer {
								tempVar := &verbs[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
							}()))).op < int32(0) {
								*errorcodeptr = ERR66
								goto FAILED
							}
							setverb = int32(uint8((func() pcre_uchar {
								tempVar := pcre_uchar((uint8((*((*verbitem)(func() unsafe.Pointer {
									tempVar := &verbs[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
								}()))).op)))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = tempVar
								return tempVar
							}())))
						} else {
							if (*((*verbitem)(func() unsafe.Pointer {
								tempVar := &verbs[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
							}()))).op_arg < int32(0) {
								*errorcodeptr = ERR59
								goto FAILED
							}
							setverb = int32(uint8((func() pcre_uchar {
								tempVar := pcre_uchar((uint8((*((*verbitem)(func() unsafe.Pointer {
									tempVar := &verbs[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
								}()))).op_arg)))
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = tempVar
								return tempVar
							}())))
							if lengthptr != nil {
								*lengthptr += arglen
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar(int32(0))
							} else {
								*func() *pcre_uchar {
									defer func() {
										code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
									}()
									return code
								}() = pcre_uchar((uint8(arglen)))
								noarch.Memcpy(unsafe.Pointer(code), unsafe.Pointer(arg), int32(uint32((arglen))))
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(arglen)*unsafe.Sizeof(*code))))
							}
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar(int32(0))
						}
						switch setverb {
						case OP_THEN:
							fallthrough
						case OP_THEN_ARG:
							{
								(*cd).external_flags |= pcre_uint32((uint32(int32(4096))))
							}
						case OP_PRUNE:
							fallthrough
						case OP_PRUNE_ARG:
							fallthrough
						case OP_SKIP:
							fallthrough
						case OP_SKIP_ARG:
							{
								(*cd).had_pruneorskip = BOOL((int32(1)))
								break
							}
						}
						break
					}
					vn = ((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(vn)) + (uintptr)(((*((*verbitem)(func() unsafe.Pointer {
						tempVar := &verbs[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
					}()))).len+int32(1)))*unsafe.Sizeof(*vn))))
				}
				if i < verbcount {
					continue
				}
				*errorcodeptr = ERR60
				goto FAILED
			}
			newoptions = options
			skipbytes = int32(0)
			bravalue = OP_CBRA
			item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
			reset_bracount = BOOL((int32(0)))
		NAMED_REF_OR_RECURSE_CONTAINER:
		HANDLE_RECURSION_CONTAINER_MIDDLE:
		NUMBERED_GROUP_CONTAINER:
			if !goto_NUMBERED_GROUP && (goto_HANDLE != 0 || goto_NAMED_REF_OR_RECURSE || int32(uint8((*ptr))) == int32('?')) {
				var i int32
				var set int32
				var unset int32
				var namelen int32
				var optset *int32
				var name *pcre_uchar
				var slot *pcre_uchar
				if goto_HANDLE != 0 {
					goto HANDLE_RECURSION_CONTAINER
				}
				if goto_NAMED_REF_OR_RECURSE {
					goto_NAMED_REF_OR_RECURSE = false
					goto NAMED_REF_OR_RECURSE
				}
				switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					return ptr
				}())))) {
				case '|':
					goto SW_GENERATED_LABEL_102
				case ':':
					goto SW_GENERATED_LABEL_103
				case '(':
					goto SW_GENERATED_LABEL_104
				case '=':
					goto SW_GENERATED_LABEL_105
				case '!':
					goto SW_GENERATED_LABEL_106
				case '<':
					goto SW_GENERATED_LABEL_107
				case '>':
					goto SW_GENERATED_LABEL_108
				case 'C':
					goto SW_GENERATED_LABEL_109
				case 'P':
					goto SW_GENERATED_LABEL_110
				case '\'':
					goto SW_GENERATED_LABEL_111
				case '&':
					goto SW_GENERATED_LABEL_112
				case 'R':
					goto SW_GENERATED_LABEL_113
				case '-':
					goto SW_GENERATED_LABEL_114
				case '+':
					goto SW_GENERATED_LABEL_115
				case '0':
					goto SW_GENERATED_LABEL_116
				case '1':
					goto SW_GENERATED_LABEL_117
				case '2':
					goto SW_GENERATED_LABEL_118
				case '3':
					goto SW_GENERATED_LABEL_119
				case '4':
					goto SW_GENERATED_LABEL_120
				case '5':
					goto SW_GENERATED_LABEL_121
				case '6':
					goto SW_GENERATED_LABEL_122
				case '7':
					goto SW_GENERATED_LABEL_123
				case '8':
					goto SW_GENERATED_LABEL_124
				case '9':
					goto SW_GENERATED_LABEL_125
				default:
					goto SW_GENERATED_LABEL_126
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_102:
				{
					reset_bracount = BOOL((int32(1)))
					(*cd).dupgroups = BOOL((int32(1)))
				}
			SW_GENERATED_LABEL_103:
				{
					bravalue = OP_BRA
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_104:
				{
					bravalue = OP_COND
					tempptr = ptr
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('?')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) == int32('C')) {
						for i = int32(3); ; i++ {
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(i)*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(i)*unsafe.Sizeof(*ptr))))))) <= int32('9')))])) != 0 {
								break
							}
						}
						if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(i)*unsafe.Sizeof(*ptr))))))) == int32(')') {
							tempptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)((i+int32(1)))*unsafe.Sizeof(*tempptr))))
						}
						if int32(uint8((*tempptr))) != int32('(') {
							*errorcodeptr = ERR28
							goto FAILED
						}
					}
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempptr))))))) == int32('?')) && (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempptr))))))) == int32('=')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempptr))))))) == int32('!'))) || ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempptr))))))) == int32('<')) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempptr))))))) == int32('=')) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tempptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempptr))))))) == int32('!'))))) {
						(*cd).iscondassert = BOOL((int32(1)))
						goto SW_GENERATED_LABEL_101
					}
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(OP_CREF)))
					skipbytes = (int32(1) + int32(2))
					refsign = -int32(1)
					namelen = -int32(1)
					name = nil
					recno = int32(0)
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					if (int32(uint8((*ptr))) == int32('R')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('&')) {
						terminator = -int32(1)
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(OP_RREF)))
					} else if int32(uint8((*ptr))) == int32('<') {
						terminator = int32('>')
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					} else if int32(uint8((*ptr))) == int32('\'') {
						terminator = int32('\'')
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					} else {
						terminator = int32('\x00')
						if (int32(uint8((*ptr))) == int32('-')) || (int32(uint8((*ptr))) == int32('+')) {
							refsign = int32(uint8((*func() *pcre_uchar {
								defer func() {
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								}()
								return ptr
							}())))
						} else if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')))]) != 0 {
							refsign = int32(0)
						}
					}
					if refsign >= int32(0) {
						for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')) {
							if recno > ((int32(2147483647) / int32(10)) - int32(1)) {
								for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')) {
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								}
								*errorcodeptr = ERR61
								goto FAILED
							}
							recno = ((recno * int32(10)) + (int32(uint8((*ptr))) - int32('0')))
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
					} else {
						if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')))]) != 0 {
							*errorcodeptr = ERR84
							goto FAILED
						}
						if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := (*cd).ctypes
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(16)) == int32(0)) {
							*errorcodeptr = ERR28
							goto FAILED
						}
						name = func() *pcre_uchar {
							defer func() {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}()
							return ptr
						}()
						for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := (*cd).ctypes
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(16)) != int32(0)) {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}
						namelen = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(name))))))
						if lengthptr != nil {
							skipbytes += int32(2)
						}
					}
					if ((terminator > int32(0)) && (int32(uint8((*func() *pcre_uchar {
						defer func() {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}()
						return ptr
					}()))) != int32(uint8((pcre_uchar(terminator)))))) || (int32(uint8((*func() *pcre_uchar {
						defer func() {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						}()
						return ptr
					}()))) != int32(')')) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))
						*errorcodeptr = ERR26
						goto FAILED
					}
					if lengthptr != nil {
						goto SW_GENERATED_LABEL_101
					}
					if refsign >= int32(0) {
						if recno <= int32(0) {
							*errorcodeptr = ERR35
							goto FAILED
						}
						if refsign != int32(0) {
							recno = int32(func() uint32 {
								if (map[bool]int32{false: 0, true: 1}[(refsign == int32('-'))]) != 0 {
									return (((*cd).bracount - uint32(recno)) + uint32(int32(1)))
								} else {
									return (uint32(recno) + (*cd).bracount)
								}
							}())
						}
						if (recno <= int32(0)) || (recno > (*cd).final_bracount) {
							*errorcodeptr = ERR15
							goto FAILED
						}
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno >> uint64(int32(8))))))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno & int32(255)))))
						if recno > (*cd).top_backref {
							(*cd).top_backref = recno
						}
						goto SW_GENERATED_LABEL_101
					}
					slot = (*cd).name_table
					for i = int32(0); i < (*cd).names_found; i++ {
						if (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot))+(uintptr)(int32(2))*unsafe.Sizeof(*slot)))))), int32(uint32((namelen)))) == int32(0)) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((int32(2)+namelen))*unsafe.Sizeof(*slot))))))) == int32(0)) {
							break
						}
						slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))
					}
					if i < (*cd).names_found {
						var offset int32 = func() int32 {
							defer func() {
								i += 1
							}()
							return i
						}()
						var count int32 = int32(1)
						recno = int32(uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot)))))))))))
						if recno > (*cd).top_backref {
							(*cd).top_backref = recno
						}
						for ; i < (*cd).names_found; i++ {
							slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))
							if (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot))+(uintptr)(int32(2))*unsafe.Sizeof(*slot)))))), int32(uint32((namelen)))) != int32(0)) || (int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)(int32(2))*unsafe.Sizeof(*slot))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(namelen)*unsafe.Sizeof(*tempVar))
							}()))))) != int32(0)) {
								break
							}
							count += 1
						}
						if count > int32(1) {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((offset >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((offset & int32(255)))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(2)+int32(2))+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((count >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((((int32(2)+int32(2))+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((count & int32(255)))))
							skipbytes += int32(2)
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) += pcre_uchar((uint8(int32(1))))
						} else {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno & int32(255)))))
						}
					} else if terminator != int32('\x00') {
						*errorcodeptr = ERR15
						goto FAILED
					} else if int32(uint8((*name))) == int32('R') {
						recno = int32(0)
						for i = int32(1); i < namelen; i++ {
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(name)) + (uintptr)(i)*unsafe.Sizeof(*name))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(name)) + (uintptr)(i)*unsafe.Sizeof(*name))))))) <= int32('9')))])) != 0 {
								*errorcodeptr = ERR15
								goto FAILED
							}
							if recno > ((int32(2147483647) / int32(10)) - int32(1)) {
								*errorcodeptr = ERR61
								goto FAILED
							}
							recno = (((recno * int32(10)) + int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(name)) + (uintptr)(i)*unsafe.Sizeof(*name)))))))) - int32('0'))
						}
						if recno == int32(0) {
							recno = int32(65535)
						}
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(OP_RREF)))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno >> uint64(int32(8))))))
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno & int32(255)))))
					} else if (namelen == int32(6)) && (noarch.Strncmp((*byte)(unsafe.Pointer((name))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("DEFINE\x00"), 1, 1))))[0], int32(uint32((int32(6))))) == int32(0)) {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(OP_DEF)))
						skipbytes = int32(1)
					} else {
						*errorcodeptr = ERR15
						goto FAILED
					}
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_105:
				{
					bravalue = OP_ASSERT
					(*cd).assert_depth += int32(1)
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_106:
				{
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					if ((((int32(uint8((*ptr))) == int32(')')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('*'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('+'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('?'))) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('{')) || (int32((NotBOOL(is_counted_repeat(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr)))))))) != 0)) {
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8(OP_FAIL)))
						previous = nil
						continue
					}
					bravalue = OP_ASSERT_NOT
					(*cd).assert_depth += int32(1)
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_107:
				{
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr)))))))) {
					case '=':
						{
							bravalue = OP_ASSERTBACK
							(*cd).assert_depth += int32(1)
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						}
					case '!':
						{
							bravalue = OP_ASSERTBACK_NOT
							(*cd).assert_depth += int32(1)
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
						}
					default:
						{
							if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*cd).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(16)) != int32(0)) {
								goto DEFINE_NAME
							}
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							*errorcodeptr = ERR24
							goto FAILED
						}
					}
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_108:
				{
					bravalue = OP_ONCE
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
				goto SW_GENERATED_LABEL_101
			SW_GENERATED_LABEL_109:
				{
					previous_callout = code
					after_manual_callout = int32(1)
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(OP_CALLOUT)))
					{
						var n int32 = int32(0)
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')) {
							n = (((n * int32(10)) + int32(uint8((*func() *pcre_uchar {
								defer func() {
									ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
								}()
								return ptr
							}())))) - int32('0'))
						}
						if int32(uint8((*ptr))) != int32(')') {
							*errorcodeptr = ERR39
							goto FAILED
						}
						if n > int32(255) {
							*errorcodeptr = ERR38
							goto FAILED
						}
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8(n)))
						func() pcre_uchar {
							*code = pcre_uchar((uint8(((int32(((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*cd).start_pattern)))) + int64(int32(1))))) >> uint64(int32(8))))))
							return *code
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32(((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*cd).start_pattern)))) + int64(int32(1))))) & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) >> uint64(int32(8))))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
						}()
						func() pcre_uchar {
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) & int32(255)))))
							return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code))))
						}()
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)*int32(2)))*unsafe.Sizeof(*code))))
					}
					previous = nil
					continue
				}
			SW_GENERATED_LABEL_110:
				{
					if (int32(uint8((*func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()))) == int32('=')) || (int32(uint8((*ptr))) == int32('>')) {
						is_recurse = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ptr))) == int32('>'))]))
						terminator = int32(')')
						goto NAMED_REF_OR_RECURSE
					} else if int32(uint8((*ptr))) != int32('<') {
						*errorcodeptr = ERR41
						goto FAILED
					}
				}
			DEFINE_NAME:
				{
				}
			SW_GENERATED_LABEL_111:
				{
					terminator = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*ptr))) == int32('<'))]) != 0 {
							return int32('>')
						} else {
							return int32('\'')
						}
					}()
					name = func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()
					if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')))]) != 0 {
						*errorcodeptr = ERR84
						goto FAILED
					}
					for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(16)) != int32(0)) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					}
					namelen = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(name))))))
					if lengthptr != nil {
						var ng *named_group
						var number pcre_uint32 = pcre_uint32(((*cd).bracount + uint32(int32(1))))
						if int32(uint8((*ptr))) != int32(uint8((pcre_uchar(terminator)))) {
							*errorcodeptr = ERR42
							goto FAILED
						}
						if (*cd).names_found >= int32(10000) {
							*errorcodeptr = ERR49
							goto FAILED
						}
						if ((namelen + int32(2)) + int32(1)) > (*cd).name_entry_size {
							(*cd).name_entry_size = ((namelen + int32(2)) + int32(1))
							if namelen > int32(32) {
								*errorcodeptr = ERR48
								goto FAILED
							}
						}
						ng = (*cd).named_groups
						for i = int32(0); i < (*cd).names_found; {
							if (namelen == (*ng).length) && (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (*byte)(unsafe.Pointer(((*ng).name))), int32(uint32((namelen)))) == int32(0)) {
								if pcre_uint32((*ng).number) == number {
									break
								}
								if (options & int32(524288)) == int32(0) {
									*errorcodeptr = ERR43
									goto FAILED
								}
								(*cd).dupnames = BOOL((int32(1)))
							} else if pcre_uint32((*ng).number) == number {
								*errorcodeptr = ERR65
								goto FAILED
							}
							i += 1
							ng = ((*named_group)(unsafe.Pointer(uintptr(unsafe.Pointer(ng)) + (uintptr)(1)*unsafe.Sizeof(*ng))))
						}
						if i >= (*cd).names_found {
							if (*cd).names_found >= (*cd).named_group_list_size {
								var newsize int32 = ((*cd).named_group_list_size * int32(2))
								var newspace *named_group = (*named_group)(pcre_malloc(size_t((uint32(newsize) * 16))))
								if newspace == nil {
									*errorcodeptr = ERR21
									goto FAILED
								}
								noarch.Memcpy(unsafe.Pointer(newspace), unsafe.Pointer((*cd).named_groups), int32((uint32((*cd).named_group_list_size) * 16)))
								if (*cd).named_group_list_size > int32(20) {
									pcre_free(unsafe.Pointer((*cd).named_groups))
								}
								(*cd).named_groups = newspace
								(*cd).named_group_list_size = newsize
							}
							(*((*named_group)(func() unsafe.Pointer {
								tempVar := (*cd).named_groups
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).names_found)*unsafe.Sizeof(*tempVar))
							}()))).name = name
							(*((*named_group)(func() unsafe.Pointer {
								tempVar := (*cd).named_groups
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).names_found)*unsafe.Sizeof(*tempVar))
							}()))).length = namelen
							(*((*named_group)(func() unsafe.Pointer {
								tempVar := (*cd).named_groups
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).names_found)*unsafe.Sizeof(*tempVar))
							}()))).number = number
							(*cd).names_found += int32(1)
						}
					}
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					goto_NUMBERED_GROUP = true
					goto NUMBERED_GROUP_CONTAINER
				}
			SW_GENERATED_LABEL_112:
				{
					terminator = int32(')')
					is_recurse = BOOL((int32(1)))
				}
			NAMED_REF_OR_RECURSE:
				{
					name = func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()
					if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')))]) != 0 {
						*errorcodeptr = ERR84
						goto FAILED
					}
					for (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ptr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(16)) != int32(0)) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					}
					namelen = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(name))))))
					if lengthptr != nil {
						var ng *named_group
						recno = int32(0)
						if namelen == int32(0) {
							*errorcodeptr = ERR62
							goto FAILED
						}
						if int32(uint8((*ptr))) != int32(uint8((pcre_uchar(terminator)))) {
							*errorcodeptr = ERR42
							goto FAILED
						}
						if namelen > int32(32) {
							*errorcodeptr = ERR48
							goto FAILED
						}
						if int32((NotBOOL(BOOL(is_recurse)))) != 0 {
							(*cd).namedrefcount += uint32(int32(1))
						}
						*lengthptr += int32(2)
						*lengthptr += (int32(4) + (int32(4) * int32(2)))
						if int32((BOOL((*cd).dupgroups))) != 0 {
							*lengthptr += (int32(4) + (int32(4) * int32(2)))
						}
						{
							ng = (*cd).named_groups
							for i = int32(0); i < (*cd).names_found; {
								if (namelen == (*ng).length) && (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (*byte)(unsafe.Pointer(((*ng).name))), int32(uint32((namelen)))) == int32(0)) {
									var oc *open_capitem
									recno = int32(uint32((pcre_uint32((*ng).number))))
									if int32((BOOL(is_recurse))) != 0 {
										break
									}
									for oc = (*cd).open_caps; oc != nil; oc = (*oc).next {
										if int32(uint16((pcre_uint16((*oc).number)))) == recno {
											(*oc).flag = pcre_uint16(int32(1))
											break
										}
									}
								}
								i += 1
								ng = ((*named_group)(unsafe.Pointer(uintptr(unsafe.Pointer(ng)) + (uintptr)(1)*unsafe.Sizeof(*ng))))
							}
						}
					} else {
						slot = (*cd).name_table
						for i = int32(0); i < (*cd).names_found; i++ {
							if (noarch.Strncmp((*byte)(unsafe.Pointer((name))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot))+(uintptr)(int32(2))*unsafe.Sizeof(*slot)))))), int32(uint32((namelen)))) == int32(0)) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((int32(2)+namelen))*unsafe.Sizeof(*slot))))))) == int32(0)) {
								break
							}
							slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))
						}
						if i < (*cd).names_found {
							recno = int32(uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot)))))))))))
						} else {
							*errorcodeptr = ERR15
							goto FAILED
						}
					}
					if int32((BOOL(is_recurse))) != 0 {
						goto_HANDLE = HANDLE_RECURSION
						goto HANDLE_RECURSION_CONTAINER
					}
					if (lengthptr == nil) && (int32((BOOL((*cd).dupnames))) != 0) {
						var count int32 = int32(1)
						var index uint32 = uint32(i)
						var cslot *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))
						for i += 1; i < (*cd).names_found; i++ {
							if noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot))+(uintptr)(int32(2))*unsafe.Sizeof(*slot)))))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cslot))+(uintptr)(int32(2))*unsafe.Sizeof(*cslot))))))) != int32(0) {
								break
							}
							count += 1
							cslot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cslot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*cslot))))
						}
						if count > int32(1) {
							if firstcharflags == pcre_int32((-int32(2))) {
								firstcharflags = pcre_int32((-int32(1)))
							}
							previous = code
							item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
							*func() *pcre_uchar {
								defer func() {
									code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
								}()
								return code
							}() = pcre_uchar((uint8(func() int32 {
								if (map[bool]int32{false: 0, true: 1}[((options & int32(1)) != int32(0))]) != 0 {
									return OP_DNREFI
								} else {
									return OP_DNREF
								}
							}())))
							*code = pcre_uchar((uint8((index >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((index & uint32(int32(255))))))
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
							*code = pcre_uchar((uint8((count >> uint64(int32(8))))))
							*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((count & int32(255)))))
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
							for ; int64(uintptr(unsafe.Pointer(slot))) < int64(uintptr(unsafe.Pointer(cslot))); slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot)))) {
								var oc *open_capitem
								recno = int32(uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot)))))))))))
								(*cd).backref_map |= uint32(func() int32 {
									if (map[bool]int32{false: 0, true: 1}[(recno < int32(32))]) != 0 {
										return (int32(1) << uint64(recno))
									} else {
										return int32(1)
									}
								}())
								if recno > (*cd).top_backref {
									(*cd).top_backref = recno
								}
								for oc = (*cd).open_caps; oc != nil; oc = (*oc).next {
									if int32(uint16((pcre_uint16((*oc).number)))) == recno {
										(*oc).flag = pcre_uint16(int32(1))
										break
									}
								}
							}
							continue
						}
					}
					goto_HANDLE_REFERENCE = true
					goto HANDLE_REFERENCE_CONTAINER_OUTER
				}
			SW_GENERATED_LABEL_113:
				{
					recno = int32(0)
					if int32(uint8((*func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()))) != int32(')') {
						*errorcodeptr = ERR29
						goto FAILED
					}
					goto_HANDLE = HANDLE_RECURSION
					goto HANDLE_RECURSION_CONTAINER
				}
			SW_GENERATED_LABEL_114:
				;
			SW_GENERATED_LABEL_115:
				;
			SW_GENERATED_LABEL_116:
				;
			SW_GENERATED_LABEL_117:
				;
			SW_GENERATED_LABEL_118:
				;
			SW_GENERATED_LABEL_119:
				;
			SW_GENERATED_LABEL_120:
				;
			SW_GENERATED_LABEL_121:
				;
			SW_GENERATED_LABEL_122:
				;
			SW_GENERATED_LABEL_123:
				;
			HANDLE_RECURSION_CONTAINER:
				;
			SW_GENERATED_LABEL_124:
				;
			SW_GENERATED_LABEL_125:
				{
					var called *pcre_uchar
					switch goto_HANDLE {
					case HANDLE_RECURSION:
						goto_HANDLE = 0
						goto HANDLE_RECURSION
					case HANDLE_NUMERICAL_RECURSION:
						goto_HANDLE = 0
						goto HANDLE_NUMERICAL_RECURSION
					}
					terminator = int32(')')
				HANDLE_NUMERICAL_RECURSION:
					;
					if (func() int32 {
						tempVar := int32(uint8((*ptr)))
						refsign = tempVar
						return tempVar
					}()) == int32('+') {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')))])) != 0 {
							*errorcodeptr = ERR63
							goto FAILED
						}
					} else if refsign == int32('-') {
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int32('0')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) <= int32('9')))])) != 0 {
							goto OTHER_CHAR_AFTER_QUERY
						}
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					}
					recno = int32(0)
					for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')) {
						if recno > ((int32(2147483647) / int32(10)) - int32(1)) {
							for (int32(uint8((*ptr))) >= int32('0')) && (int32(uint8((*ptr))) <= int32('9')) {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}
							*errorcodeptr = ERR61
							goto FAILED
						}
						recno = (((recno * int32(10)) + int32(uint8((*func() *pcre_uchar {
							defer func() {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}()
							return ptr
						}())))) - int32('0'))
					}
					if int32(uint8((*ptr))) != int32(uint8((pcre_uchar(terminator)))) {
						*errorcodeptr = ERR29
						goto FAILED
					}
					if refsign == int32('-') {
						if recno == int32(0) {
							*errorcodeptr = ERR58
							goto FAILED
						}
						recno = int32((((*cd).bracount - uint32(recno)) + uint32(int32(1))))
						if recno <= int32(0) {
							*errorcodeptr = ERR15
							goto FAILED
						}
					} else if refsign == int32('+') {
						if recno == int32(0) {
							*errorcodeptr = ERR58
							goto FAILED
						}
						recno += int32((*cd).bracount)
					}
				HANDLE_RECURSION:
					;
					previous = code
					item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
					called = (*cd).start_code
					if lengthptr == nil {
						*code = pcre_uchar((uint8(OP_END)))
						if recno != int32(0) {
							called = _pcre_find_bracket((*cd).start_code, BOOL(utf), recno)
						}
						if called == nil {
							if recno > (*cd).final_bracount {
								*errorcodeptr = ERR15
								goto FAILED
							}
							called = ((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).start_code
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(recno)*unsafe.Sizeof(*tempVar))
							}()))
							if int64(uintptr(unsafe.Pointer((*cd).hwm))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).start_workspace
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*cd).workspace_size)*unsafe.Sizeof(*tempVar))
								}()))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(100))*unsafe.Sizeof(*tempVar))
							}()))))) {
								*errorcodeptr = expand_workspace(cd)
								if *errorcodeptr != int32(0) {
									goto FAILED
								}
							}
							func() pcre_uchar {
								*(*cd).hwm = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) - int64(uintptr(unsafe.Pointer((*cd).start_code)))))) >> uint64(int32(8))))))
								return *(*cd).hwm
							}()
							func() pcre_uchar {
								*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).hwm
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
								}())) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))))) - int64(uintptr(unsafe.Pointer((*cd).start_code)))))) & int32(255)))))
								return *((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*cd).hwm
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
								}()))
							}()
							(*cd).hwm = ((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*cd).hwm
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
							}()))
						} else if ((((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((called))) + (uintptr)(int32(1))*unsafe.Sizeof(*(called)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((called))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(called))))))))) == int32(0)) && (cond_depth <= int32(0))) && (int32((could_be_empty(called, code, bcptr, BOOL(utf), cd))) != 0) {
							*errorcodeptr = ERR40
							goto FAILED
						}
					}
					*code = pcre_uchar((uint8(OP_RECURSE)))
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(called))) - int64(uintptr(unsafe.Pointer((*cd).start_code)))))) >> uint64(int32(8))))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
					}()
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(called))) - int64(uintptr(unsafe.Pointer((*cd).start_code)))))) & int32(255)))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code))))
					}()
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
					groupsetfirstchar = BOOL((int32(0)))
					if firstcharflags == pcre_int32((-int32(2))) {
						firstcharflags = pcre_int32((-int32(1)))
					}
					continue
				}
			SW_GENERATED_LABEL_126:
				;
			OTHER_CHAR_AFTER_QUERY:
				{
					unset = int32(0)
					set = unset
					optset = &set
					for (int32(uint8((*ptr))) != int32(')')) && (int32(uint8((*ptr))) != int32(':')) {
						switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
							defer func() {
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							}()
							return ptr
						}())))) {
						case '-':
							{
								optset = &unset
							}
						case 'J':
							{
								*optset |= int32(524288)
								(*cd).external_flags |= pcre_uint32((uint32(int32(1024))))
							}
						case 'i':
							{
								*optset |= int32(1)
							}
						case 'm':
							{
								*optset |= int32(2)
							}
						case 's':
							{
								*optset |= int32(4)
							}
						case 'x':
							{
								*optset |= int32(8)
							}
						case 'U':
							{
								*optset |= int32(512)
							}
						case 'X':
							{
								*optset |= int32(64)
							}
						default:
							{
								*errorcodeptr = ERR12
								ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))
								goto FAILED
							}
						}
					}
					newoptions = ((options | set) & ^unset)
					if int32(uint8((*ptr))) == int32(')') {
						greedy_default = map[bool]int32{false: 0, true: 1}[((newoptions & int32(512)) != int32(0))]
						greedy_non_default = (greedy_default ^ int32(1))
						req_caseopt = pcre_int32((func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((newoptions & int32(1)) != int32(0))]) != 0 {
								return (int32(1) << uint64(int32(0)))
							} else {
								return int32(0)
							}
						}()))
						options = newoptions
						*optionsptr = options
						previous = nil
						continue
					}
					bravalue = OP_BRA
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
				}
			SW_GENERATED_LABEL_101:
			} else if !goto_NUMBERED_GROUP && (options & int32(4096)) != int32(0) {
				bravalue = OP_BRA
			} else {
				if goto_NUMBERED_GROUP {
					goto_NUMBERED_GROUP = false
					goto NUMBERED_GROUP
				}
			NUMBERED_GROUP:
				;
				(*cd).bracount += uint32(int32(1))
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((*cd).bracount >> uint64(int32(8))))))
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((*cd).bracount & uint32(int32(255))))))
				skipbytes = int32(2)
			}
			if func() int32 {
				tempVar := &(*cd).parens_depth
				*tempVar += int32(1)
				return *tempVar
			}() > int32(250) {
				*errorcodeptr = ERR82
				goto FAILED
			}
			if ((bravalue >= OP_ASSERT) && (bravalue <= OP_ASSERTBACK_NOT)) && (int32((BOOL((*cd).iscondassert))) != 0) {
				previous = nil
				(*cd).iscondassert = BOOL((int32(0)))
			} else {
				previous = code
				item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
			}
			*code = pcre_uchar((uint8(bravalue)))
			tempcode = code
			tempreqvary = pcre_int32(((*cd).req_varyopt))
			tempbracount = (*cd).bracount
			length_prevgroup = int32(0)
			if int32((NotBOOL(compile_regex(newoptions, &tempcode, &ptr, errorcodeptr, BOOL((map[bool]int32{false: 0, true: 1}[((bravalue == OP_ASSERTBACK) || (bravalue == OP_ASSERTBACK_NOT))])), BOOL(reset_bracount), skipbytes, (cond_depth + func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(bravalue == OP_COND)]) != 0 {
					return int32(1)
				} else {
					return int32(0)
				}
			}()), &subfirstchar, &subfirstcharflags, &subreqchar, &subreqcharflags, bcptr, cd, func() *int32 {
				if (map[bool]int32{false: 0, true: 1}[(lengthptr == nil)]) != 0 {
					return nil
				} else {
					return &length_prevgroup
				}
			}())))) != 0 {
				goto FAILED
			}
			(*cd).parens_depth -= int32(1)
			if (bravalue == OP_ONCE) && ((*cd).bracount <= tempbracount) {
				*code = pcre_uchar((uint8(OP_ONCE_NC)))
			}
			if (bravalue >= OP_ASSERT) && (bravalue <= OP_ASSERTBACK_NOT) {
				(*cd).assert_depth -= int32(1)
			}
			if (bravalue == OP_COND) && (lengthptr == nil) {
				var tc *pcre_uchar = code
				var condcount int32 = int32(0)
				for {
					condcount += 1
					tc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tc))))))))))*unsafe.Sizeof(*tc))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*tc))) != OP_KET)])) != 0 {
						break
					}
				}
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code))))))) == OP_DEF {
					if condcount > int32(1) {
						*errorcodeptr = ERR54
						goto FAILED
					}
					bravalue = OP_DEF
				} else {
					if condcount > int32(2) {
						*errorcodeptr = ERR27
						goto FAILED
					}
					if condcount == int32(1) {
						subreqcharflags = pcre_int32((-int32(1)))
						subfirstcharflags = subreqcharflags
					}
				}
			}
			if int32(uint8((*ptr))) != int32(')') {
				*errorcodeptr = ERR14
				goto FAILED
			}
			if lengthptr != nil {
				if ((int32(2147483647) - int32(20)) - *lengthptr) < ((length_prevgroup - int32(2)) - (int32(2) * int32(2))) {
					*errorcodeptr = ERR20
					goto FAILED
				}
				*lengthptr += ((length_prevgroup - int32(2)) - (int32(2) * int32(2)))
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				func() pcre_uchar {
					*code = pcre_uchar((uint8(((int32(1) + int32(2)) >> uint64(int32(8))))))
					return *code
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32(1) + int32(2)) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
				}()
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = pcre_uchar((uint8(OP_KET)))
				func() pcre_uchar {
					*code = pcre_uchar((uint8(((int32(1) + int32(2)) >> uint64(int32(8))))))
					return *code
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32(1) + int32(2)) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
				}()
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
				goto SW_GENERATED_LABEL_127
			}
			code = tempcode
			if bravalue == OP_DEF {
				goto SW_GENERATED_LABEL_127
			}
			zeroreqchar = reqchar
			zeroreqcharflags = reqcharflags
			zerofirstchar = firstchar
			zerofirstcharflags = firstcharflags
			groupsetfirstchar = BOOL((int32(0)))
			if bravalue >= OP_ONCE {
				if firstcharflags == pcre_int32((-int32(2))) {
					if subfirstcharflags >= pcre_int32((int32(0))) {
						firstchar = subfirstchar
						firstcharflags = subfirstcharflags
						groupsetfirstchar = BOOL((int32(1)))
					} else {
						firstcharflags = pcre_int32((-int32(1)))
					}
					zerofirstcharflags = pcre_int32((-int32(1)))
				} else if (subfirstcharflags >= pcre_int32((int32(0)))) && (subreqcharflags < pcre_int32((int32(0)))) {
					subreqchar = subfirstchar
					subreqcharflags = (subfirstcharflags | tempreqvary)
				}
				if subreqcharflags >= pcre_int32((int32(0))) {
					reqchar = subreqchar
					reqcharflags = subreqcharflags
				}
			} else if ((bravalue == OP_ASSERT) && (subreqcharflags >= pcre_int32((int32(0))))) && (subfirstcharflags >= pcre_int32((int32(0)))) {
				reqchar = subreqchar
				reqcharflags = subreqcharflags
			}
		}
		goto SW_GENERATED_LABEL_127
	HANDLE_REFERENCE_CONTAINER_OUTER:
		;
	SW_GENERATED_LABEL_141:
		{
			if goto_HANDLE_REFERENCE {
				goto HANDLE_REFERENCE_CONTAINER_INNER
			}
			tempptr = ptr
			escape = check_escape(&ptr, &ec, errorcodeptr, int32((*cd).bracount), options, BOOL((int32(0))))
			if *errorcodeptr != int32(0) {
				goto FAILED
			}
		HANDLE_REFERENCE_CONTAINER_INNER:
			if !goto_HANDLE_REFERENCE && escape == int32(0) {
				c = ec
			} else {
				if goto_HANDLE_REFERENCE {
					goto HANDLE_REFERENCE_CONTAINER
				}
				if ((firstcharflags == pcre_int32((-int32(2)))) && (escape > ESC_b)) && (escape < ESC_Z) {
					firstcharflags = pcre_int32((-int32(1)))
				}
				zerofirstchar = firstchar
				zerofirstcharflags = firstcharflags
				zeroreqchar = reqchar
				zeroreqcharflags = reqcharflags
				if escape == ESC_g {
					var p *pcre_uchar
					var cf pcre_uint32
					item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
					terminator = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*func() *pcre_uchar {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							return ptr
						}()))) == int32('<'))]) != 0 {
							return int32('>')
						} else {
							return int32('\'')
						}
					}()
					skipbytes = int32(0)
					reset_bracount = BOOL((int32(0)))
					cf = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr)))))))))
					if ((cf != pcre_uint32((uint32('+')))) && (cf != pcre_uint32((uint32('-'))))) && (noarch.NotInt32((map[bool]int32{false: 0, true: 1}[((cf >= pcre_uint32((uint32('0')))) && (cf <= pcre_uint32((uint32('9')))))])) != 0) {
						is_recurse = BOOL((int32(1)))
						goto_NAMED_REF_OR_RECURSE = true
						goto NAMED_REF_OR_RECURSE_CONTAINER_OUTER
					}
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))
					for (int32(uint8((*p))) >= int32('0')) && (int32(uint8((*p))) <= int32('9')) {
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}
					if int32(uint8((*p))) != int32(uint8((pcre_uchar(terminator)))) {
						*errorcodeptr = ERR57
						goto FAILED
					}
					ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
					goto_HANDLE = HANDLE_NUMERICAL_RECURSION
					goto HANDLE_RECURSION_CONTAINER_OUTER
				}
				if escape == ESC_k {
					if (map[bool]int32{false: 0, true: 1}[(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('<')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('\''))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) != int32('{')))]) != 0 {
						*errorcodeptr = ERR69
						goto FAILED
					}
					is_recurse = BOOL((int32(0)))
					terminator = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*func() *pcre_uchar {
							ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
							return ptr
						}()))) == int32('<'))]) != 0 {
							return int32('>')
						} else {
							return func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*ptr))) == int32('\''))]) != 0 {
									return int32('\'')
								} else {
									return int32('}')
								}
							}()
						}
					}()
					goto_NAMED_REF_OR_RECURSE = true
					goto NAMED_REF_OR_RECURSE_CONTAINER_OUTER
				}
			HANDLE_REFERENCE_CONTAINER:
				if goto_HANDLE_REFERENCE || escape < int32(0) {
					var oc *open_capitem
					if goto_HANDLE_REFERENCE {
						goto_HANDLE_REFERENCE = false
						goto HANDLE_REFERENCE
					}
					recno = -escape
				HANDLE_REFERENCE:
					;
					if firstcharflags == pcre_int32((-int32(2))) {
						firstcharflags = pcre_int32((-int32(1)))
						zerofirstcharflags = firstcharflags
					}
					previous = code
					item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((options & int32(1)) != int32(0))]) != 0 {
							return OP_REFI
						} else {
							return OP_REF
						}
					}())))
					*code = pcre_uchar((uint8((recno >> uint64(int32(8))))))
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((recno & int32(255)))))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
					(*cd).backref_map |= uint32(func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(recno < int32(32))]) != 0 {
							return (int32(1) << uint64(recno))
						} else {
							return int32(1)
						}
					}())
					if recno > (*cd).top_backref {
						(*cd).top_backref = recno
					}
					for oc = (*cd).open_caps; oc != nil; oc = (*oc).next {
						if int32(uint16((pcre_uint16((*oc).number)))) == recno {
							(*oc).flag = pcre_uint16(int32(1))
							break
						}
					}
				} else if (escape == ESC_P) || (escape == ESC_p) {
					var negated BOOL
					var ptype uint32 = uint32(int32(0))
					var pdata uint32 = uint32(int32(0))
					if int32((NotBOOL(get_ucp(&ptr, &negated, &ptype, &pdata, errorcodeptr)))) != 0 {
						goto FAILED
					}
					previous = code
					item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((escape == ESC_p) != (int32((negated)) != 0))]) != 0 {
							return OP_PROP
						} else {
							return OP_NOTPROP
						}
					}())))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(ptype)))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(pdata)))
				} else {
					if (((escape == ESC_b) || (escape == ESC_B)) || (escape == ESC_A)) && ((*cd).max_lookbehind == int32(0)) {
						(*cd).max_lookbehind = int32(1)
					}
					if (escape >= ESC_DU) && (escape <= ESC_wu) {
						nestptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))
						ptr = ((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := *((**pcre_uchar)(func() unsafe.Pointer {
								tempVar := &substitutes[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((escape-ESC_DU))*unsafe.Sizeof(*tempVar))
							}()))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))
					} else {
						previous = func() *pcre_uchar {
							if (map[bool]int32{false: 0, true: 1}[((escape > ESC_b) && (escape < ESC_Z))]) != 0 {
								return code
							} else {
								return nil
							}
						}()
						item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
						*func() *pcre_uchar {
							defer func() {
								code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
							}()
							return code
						}() = pcre_uchar((uint8(func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((int32((NotBOOL(BOOL(utf)))) != 0) && (escape == ESC_C))]) != 0 {
								return OP_ALLANY
							} else {
								return escape
							}
						}())))
					}
				}
				continue
			}
			if (int32((utf)) != 0) && (c > pcre_uint32((uint32(int32(127))))) {
				mclength = _pcre_ord2utf(pcre_uint32(c), &mcbuffer[0])
			} else {
				*&mcbuffer[0] = pcre_uchar((uint8(uint32((c)))))
				mclength = uint32(int32(1))
			}
			goto ONE_CHAR
		}
	SW_GENERATED_LABEL_142:
		;
	NORMAL_CHAR:
		{
			mclength = uint32(int32(1))
			*&mcbuffer[0] = pcre_uchar((uint8(uint32((c)))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				for (int32(1) != 0) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(192)) == int32(128)) {
					*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := &mcbuffer[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(func() uint32 {
							defer func() {
								mclength += 1
							}()
							return mclength
						}()))*unsafe.Sizeof(*tempVar))
					}())) = *func() *pcre_uchar {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
						return ptr
					}()
				}
			}
		}
	ONE_CHAR:
		{
			previous = code
			item_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
			if (int32((utf)) != 0) && ((options & int32(1)) != int32(0)) {
				c = pcre_uint32((uint32(uint8((mcbuffer[0])))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(4))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63))))))
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(4))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &mcbuffer[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(5))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(63))))))
					}
				}
				if (func() pcre_uint32 {
					tempVar := pcre_uint32((uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).caseset))))))
					c = tempVar
					return tempVar
				}()) != pcre_uint32((uint32(int32(0)))) {
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(OP_PROP)))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar(int32(9))
					*func() *pcre_uchar {
						defer func() {
							code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						}()
						return code
					}() = pcre_uchar((uint8(uint32((c)))))
					if firstcharflags == pcre_int32((-int32(2))) {
						zerofirstcharflags = pcre_int32((-int32(1)))
						firstcharflags = zerofirstcharflags
					}
					goto SW_GENERATED_LABEL_127
				}
			}
			*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}() = pcre_uchar((uint8(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((options & int32(1)) != int32(0))]) != 0 {
					return OP_CHARI
				} else {
					return OP_CHAR
				}
			}())))
			for c = pcre_uint32(int32(0)); c < pcre_uint32((mclength)); c++ {
				*func() *pcre_uchar {
					defer func() {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
					}()
					return code
				}() = *((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := &mcbuffer[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
				}()))
			}
			if (int32(uint8((*&mcbuffer[0]))) == int32('\r')) || (int32(uint8((*&mcbuffer[0]))) == int32('\n')) {
				(*cd).external_flags |= pcre_uint32((uint32(int32(2048))))
			}
			if firstcharflags == pcre_int32((-int32(2))) {
				zerofirstcharflags = pcre_int32((-int32(1)))
				zeroreqchar = reqchar
				zeroreqcharflags = reqcharflags
				if (mclength == uint32(int32(1))) || (req_caseopt == pcre_int32((int32(0)))) {
					firstchar = pcre_uint32((uint32(uint8((*&mcbuffer[0])))))
					firstcharflags = req_caseopt
					if mclength != uint32(int32(1)) {
						reqchar = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))))
						reqcharflags = pcre_int32(((*cd).req_varyopt))
					}
				} else {
					reqcharflags = pcre_int32((-int32(1)))
					firstcharflags = reqcharflags
				}
			} else {
				zerofirstchar = firstchar
				zerofirstcharflags = firstcharflags
				zeroreqchar = reqchar
				zeroreqcharflags = reqcharflags
				if (mclength == uint32(int32(1))) || (req_caseopt == pcre_int32((int32(0)))) {
					reqchar = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) - (uintptr)(1)*unsafe.Sizeof(*code)))))))))
					reqcharflags = (req_caseopt | pcre_int32(((*cd).req_varyopt)))
				}
			}
			goto SW_GENERATED_LABEL_127
		}
	SW_GENERATED_LABEL_127:
	}
FAILED:
	;
	*ptrptr = ptr
	return BOOL((int32(0)))
}

// compile_regex - transpiled function from  /root/Documents/pcre/pcre_compile.c:8304
/*************************************************
*     Compile sequence of alternatives           *
*************************************************/ //
/* On entry, ptr is pointing past the bracket character, but on return it
points to the closing bracket, or vertical bar, or end of string. The code
variable is pointing at the byte into which the BRA operator has been stored.
This function is used during the pre-compile phase when we are trying to find
out the amount of memory needed, as well as during the real compile phase. The
value of lengthptr distinguishes the two phases.

Arguments:
  options           option bits, including any changes for this subpattern
  codeptr           -> the address of the current code pointer
  ptrptr            -> the address of the current pattern pointer
  errorcodeptr      -> pointer to error code variable
  lookbehind        TRUE if this is a lookbehind assertion
  reset_bracount    TRUE to reset the count for each branch
  skipbytes         skip this many bytes at start (for brackets and OP_COND)
  cond_depth        depth of nesting for conditional subpatterns
  firstcharptr      place to put the first required character
  firstcharflagsptr place to put the first character flags, or a negative number
  reqcharptr        place to put the last required character
  reqcharflagsptr   place to put the last required character flags, or a negative number
  bcptr             pointer to the chain of currently open branches
  cd                points to the data block with tables pointers etc.
  lengthptr         NULL during the real compile phase
                    points to length accumulator during pre-compile phase

Returns:            TRUE on success
*/ //
/* If set, call the external function that checks for stack availability. */ //
/* Miscellaneous initialization */ //
/* Accumulate the length for use in the pre-compile phase. Start with the
length of the BRA and KET and any extra bytes that are required at the
beginning. We accumulate in a local variable to save frequent testing of
lenthptr for NULL. We cannot do this by looking at the value of code at the
start and end of each alternative, because compiled items are discarded during
the pre-compile phase so that the work space is not exceeded. */ //
/* WARNING: If the above line is changed for any reason, you must also change
the code that abstracts option settings at the start of the pattern and makes
them global. It tests the value of length for (2 + 2*LINK_SIZE) in the
pre-compile phase to find out whether anything has yet been compiled or not. */ //
/* If this is a capturing subpattern, add to the chain of open capturing items
so that we can detect them if (*ACCEPT) is encountered. This is also used to
detect groups that contain recursive back references to themselves. Note that
only OP_CBRA need be tested here; changing this opcode to one of its variants,
e.g. OP_SCBRAPOS, happens later, after the group has been compiled. */ //
/* Offset is set zero to mark that this bracket is still open */ //
/* Loop for each alternative branch */ //
/* For a (?| group, reset the capturing bracket count so that each branch
uses the same numbers. */ //
/* Set up dummy OP_REVERSE if lookbehind assertion */ //
/* Now compile the branch; in the pre-compile phase its length gets added
into the length. */ //
/* Keep the highest bracket count in case (?| was used and some branch
has fewer than the rest. */ //
/* In the real compile phase, there is some post-processing to be done. */ //
/* If this is the first branch, the firstchar and reqchar values for the
   branch become the values for the regex. */ //
/* If this is not the first branch, the first char and reqchar have to
   match the values from all the previous branches, except that if the
   previous value for reqchar didn't have REQ_VARY set, it can still match,
   and we set REQ_VARY for the regex. */ //
/* If we previously had a firstchar, but it doesn't match the new branch,
   we have to abandon the firstchar for the regex, but if there was
   previously no reqchar, it takes on the value of the old firstchar. */ //
/* If we (now or from before) have no firstchar, a firstchar from the
   branch becomes a reqchar if there isn't a branch reqchar. */ //
/* Now ensure that the reqchars match */ //
/* To "or" REQ_VARY */ //
/* If lookbehind, check that this branch matches a fixed-length string, and
   put the length into the OP_REVERSE item. Temporarily mark the end of the
   branch with OP_END. If the branch contains OP_RECURSE, the result is -3
   because there may be forward references that we can't check here. Set a
   flag to cause another lookbehind check at the end. Why not do it all at the
   end? Because common, erroneous checks are picked up here and the offset of
   the problem can be shown. */ //
/* Reached end of expression, either ')' or end of pattern. In the real
compile phase, go back through the alternative branches and reverse the chain
of offsets, with the field in the BRA item now becoming an offset to the
first alternative. If there are no alternatives, it points to the end of the
group. The length in the terminating ket is always the length of the whole
bracketed item. Return leaving the pointer at the terminating char. */ //
/* Fill in the ket */ //
/* If it was a capturing subpattern, check to see if it contained any
   recursive back references. If so, we must wrap it in atomic brackets.
   Because we are moving code along, we must ensure that any pending recursive
   references are updated. In any event, remove the block from the chain. */ //
/* Retain the highest bracket number, in case resetting was used. */ //
/* Set values to pass back */ //
/* Another branch follows. In the pre-compile phase, we can move the code
pointer back to where it was for the start of the first branch. (That is,
pretend that each branch is the only one.)

In the real compile phase, insert an ALT node. Its length field points back
to the previous branch while the bracket remains open. At the end the chain
is reversed. It's done like this so that the start of the bracket has a
zero offset until it is closed, making it possible to detect recursion. */ //
/* Control never reaches here */ //
//
func compile_regex(options int32, codeptr **pcre_uchar, ptrptr **pcre_uchar, errorcodeptr *int32, lookbehind BOOL, reset_bracount BOOL, skipbytes int32, cond_depth int32, firstcharptr *pcre_uint32, firstcharflagsptr *pcre_int32, reqcharptr *pcre_uint32, reqcharflagsptr *pcre_int32, bcptr *branch_chain, cd *compile_data, lengthptr *int32) (c2goDefaultReturn BOOL) {
	var ptr *pcre_uchar = *ptrptr
	var code *pcre_uchar = *codeptr
	var last_branch *pcre_uchar = code
	var start_bracket *pcre_uchar = code
	var reverse_count *pcre_uchar = nil
	var capitem open_capitem
	var capnumber int32 = int32(0)
	var firstchar pcre_uint32
	var reqchar pcre_uint32
	var firstcharflags pcre_int32
	var reqcharflags pcre_int32
	var branchfirstchar pcre_uint32
	var branchreqchar pcre_uint32
	var branchfirstcharflags pcre_int32
	var branchreqcharflags pcre_int32
	var length int32
	var orig_bracount uint32
	var max_bracount uint32
	var bc branch_chain
	var save_hwm_offset size_t
	if (pcre_stack_guard != nil) && (pcre_stack_guard() != 0) {
		*errorcodeptr = ERR85
		return BOOL((int32(0)))
	}
	bc.outer = bcptr
	bc.current_branch = code
	reqchar = pcre_uint32(int32(0))
	firstchar = reqchar
	reqcharflags = pcre_int32((-int32(2)))
	firstcharflags = reqcharflags
	save_hwm_offset = size_t((uint32((int64(uintptr(unsafe.Pointer((*cd).hwm))) - int64(uintptr(unsafe.Pointer((*cd).start_workspace)))))))
	length = ((int32(2) + (int32(2) * int32(2))) + skipbytes)
	if int32(uint8((*code))) == OP_CBRA {
		capnumber = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(code)))))))))))
		capitem.number = pcre_uint16((uint16(capnumber)))
		capitem.next = (*cd).open_caps
		capitem.flag = pcre_uint16(int32(0))
		(*cd).open_caps = &capitem
	}
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) >> uint64(int32(8))))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
	}()
	func() pcre_uchar {
		*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) & int32(255)))))
		return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code))))
	}()
	code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+skipbytes))*unsafe.Sizeof(*code))))
	max_bracount = (*cd).bracount
	orig_bracount = max_bracount
	for {
		if int32((BOOL(reset_bracount))) != 0 {
			(*cd).bracount = orig_bracount
		}
		if int32((BOOL(lookbehind))) != 0 {
			*func() *pcre_uchar {
				defer func() {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
				}()
				return code
			}() = pcre_uchar((uint8(OP_REVERSE)))
			reverse_count = code
			func() pcre_uchar {
				*code = pcre_uchar((uint8((int32(0) >> uint64(int32(8))))))
				return *code
			}()
			func() pcre_uchar {
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8((int32(0) & int32(255)))))
				return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*code))))
			}()
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
			length += (int32(1) + int32(2))
		}
		if int32((NotBOOL(compile_branch(&options, &code, &ptr, errorcodeptr, &branchfirstchar, &branchfirstcharflags, &branchreqchar, &branchreqcharflags, &bc, cond_depth, cd, func() *int32 {
			if (map[bool]int32{false: 0, true: 1}[(lengthptr == nil)]) != 0 {
				return nil
			} else {
				return &length
			}
		}())))) != 0 {
			*ptrptr = ptr
			return BOOL((int32(0)))
		}
		if (*cd).bracount > max_bracount {
			max_bracount = (*cd).bracount
		}
		if lengthptr == nil {
			if int32(uint8((*last_branch))) != OP_ALT {
				firstchar = branchfirstchar
				firstcharflags = branchfirstcharflags
				reqchar = branchreqchar
				reqcharflags = branchreqcharflags
			} else {
				if (firstcharflags >= pcre_int32((int32(0)))) && ((firstcharflags != branchfirstcharflags) || (firstchar != branchfirstchar)) {
					if reqcharflags < pcre_int32((int32(0))) {
						reqchar = firstchar
						reqcharflags = firstcharflags
					}
					firstcharflags = pcre_int32((-int32(1)))
				}
				if ((firstcharflags < pcre_int32((int32(0)))) && (branchfirstcharflags >= pcre_int32((int32(0))))) && (branchreqcharflags < pcre_int32((int32(0)))) {
					branchreqchar = branchfirstchar
					branchreqcharflags = branchfirstcharflags
				}
				if ((reqcharflags & pcre_int32((^(int32(1) << uint64(int32(1)))))) != (branchreqcharflags & pcre_int32((^(int32(1) << uint64(int32(1))))))) || (reqchar != branchreqchar) {
					reqcharflags = pcre_int32((-int32(1)))
				} else {
					reqchar = branchreqchar
					reqcharflags |= branchreqcharflags
				}
			}
			if int32((BOOL(lookbehind))) != 0 {
				var fixed_length int32
				*code = pcre_uchar((uint8(OP_END)))
				fixed_length = find_fixedlength(last_branch, BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))])), BOOL((int32(0))), cd, nil)
				if fixed_length == -int32(3) {
					(*cd).check_lookbehind = BOOL((int32(1)))
				} else if fixed_length < int32(0) {
					*errorcodeptr = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(fixed_length == -int32(2))]) != 0 {
							return ERR36
						} else {
							return func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(fixed_length == -int32(4))]) != 0 {
									return ERR70
								} else {
									return ERR25
								}
							}()
						}
					}()
					*ptrptr = ptr
					return BOOL((int32(0)))
				} else {
					if fixed_length > (*cd).max_lookbehind {
						(*cd).max_lookbehind = fixed_length
					}
					func() pcre_uchar {
						*reverse_count = pcre_uchar((uint8((fixed_length >> uint64(int32(8))))))
						return *reverse_count
					}()
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(reverse_count)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*reverse_count)))) = pcre_uchar((uint8((fixed_length & int32(255)))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(reverse_count)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*reverse_count))))
					}()
				}
			}
		}
		if int32(uint8((*ptr))) != int32('|') {
			if lengthptr == nil {
				var branch_length int32 = (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_branch))))))
				for {
					var prev_length int32 = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((last_branch))) + (uintptr)(int32(1))*unsafe.Sizeof(*(last_branch)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((last_branch))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(last_branch)))))))))
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last_branch)) + (uintptr)(int32(1))*unsafe.Sizeof(*last_branch)))) = pcre_uchar((uint8((branch_length >> uint64(int32(8))))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last_branch)) + (uintptr)(int32(1))*unsafe.Sizeof(*last_branch))))
					}()
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last_branch)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*last_branch)))) = pcre_uchar((uint8((branch_length & int32(255)))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last_branch)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*last_branch))))
					}()
					branch_length = prev_length
					last_branch = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last_branch)) - (uintptr)(branch_length)*unsafe.Sizeof(*last_branch))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(branch_length > int32(0))])) != 0 {
						break
					}
				}
			}
			*code = pcre_uchar((uint8(OP_KET)))
			func() pcre_uchar {
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) >> uint64(int32(8))))))
				return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
			}()
			func() pcre_uchar {
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) & int32(255)))))
				return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code))))
			}()
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
			if capnumber > int32(0) {
				if uint16((pcre_uint16((*(*cd).open_caps).flag))) != 0 {
					*code = pcre_uchar((uint8(OP_END)))
					adjust_recurse(start_bracket, (int32(1) + int32(2)), BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))])), cd, size_t(save_hwm_offset))
					noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bracket)) + (uintptr)(int32(1))*unsafe.Sizeof(*start_bracket))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}()))), unsafe.Pointer(start_bracket), int32(uint32((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))))))
					*start_bracket = pcre_uchar((uint8(OP_ONCE)))
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bracket)) + (uintptr)(int32(1))*unsafe.Sizeof(*start_bracket)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) >> uint64(int32(8))))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bracket)) + (uintptr)(int32(1))*unsafe.Sizeof(*start_bracket))))
					}()
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bracket)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*start_bracket)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) & int32(255)))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bracket)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*start_bracket))))
					}()
					*code = pcre_uchar((uint8(OP_KET)))
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) >> uint64(int32(8))))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
					}()
					func() pcre_uchar {
						*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_bracket)))))) & int32(255)))))
						return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code))))
					}()
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
					length += (int32(2) + (int32(2) * int32(2)))
				}
				(*cd).open_caps = (*(*cd).open_caps).next
			}
			(*cd).bracount = max_bracount
			*codeptr = code
			*ptrptr = ptr
			*firstcharptr = firstchar
			*firstcharflagsptr = firstcharflags
			*reqcharptr = reqchar
			*reqcharflagsptr = reqcharflags
			if lengthptr != nil {
				if ((int32(2147483647) - int32(20)) - *lengthptr) < length {
					*errorcodeptr = ERR20
					return BOOL((int32(0)))
				}
				*lengthptr += length
			}
			return BOOL((int32(1)))
		}
		if lengthptr != nil {
			code = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := *codeptr
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}()))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(skipbytes)*unsafe.Sizeof(*tempVar))
			}()))
			length += (int32(1) + int32(2))
		} else {
			*code = pcre_uchar((uint8(OP_ALT)))
			func() pcre_uchar {
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_branch)))))) >> uint64(int32(8))))))
				return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
			}()
			func() pcre_uchar {
				*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code)))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(last_branch)))))) & int32(255)))))
				return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*code))))
			}()
			last_branch = code
			bc.current_branch = last_branch
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*code))))
		}
		ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(1)*unsafe.Sizeof(*ptr))))
	}
	return
}

// is_anchored - transpiled function from  /root/Documents/pcre/pcre_compile.c:8658
/*************************************************
*          Check for anchored expression         *
*************************************************/ //
/* Try to find out if this is an anchored regular expression. Consider each
alternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket
all of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then
it's anchored. However, if this is a multiline pattern, then only OP_SOD will
be found, because ^ generates OP_CIRCM in that mode.

We can also consider a regex to be anchored if OP_SOM starts all its branches.
This is the code for \G, which means "match at start of match position, taking
into account the match offset".

A branch is also implicitly anchored if it starts with .* and DOTALL is set,
because that will try the rest of the pattern at all possible matching points,
so there is no point trying again.... er ....

.... except when the .* appears inside capturing parentheses, and there is a
subsequent back reference to those parentheses. We haven't enough information
to catch that case precisely.

At first, the best we could do was to detect when .* was in capturing brackets
and the highest back reference was greater than or equal to that level.
However, by keeping a bitmap of the first 31 back references, we can catch some
of the more common cases more precisely.

... A second exception is when the .* appears inside an atomic group, because
this prevents the number of characters it matches from being adjusted.

Arguments:
  code           points to start of expression (the bracket)
  bracket_map    a bitmap of which brackets we are inside while testing; this
                  handles up to substring 31; after that we just have to take
                  the less precise approach
  cd             points to the compile data block
  atomcount      atomic group level

Returns:     TRUE or FALSE
*/ //
/* Non-capturing brackets */ //
/* Capturing brackets */ //
/* Positive forward assertions and conditions */ //
/* Atomic groups */ //
/* .* is not anchored unless DOTALL is set (which generates OP_ALLANY) and
   it isn't in brackets that are or may be referenced or inside an atomic
   group. */ //
/* Check for explicit anchoring */ //
/* Loop for each alternative */ //
//
func is_anchored(code *pcre_uchar, bracket_map uint32, cd *compile_data, atomcount int32) BOOL {
	for {
		var scode *pcre_uchar = first_significant_code(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &_pcre_OP_lengths[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*code))))*unsafe.Sizeof(*tempVar))
		}()))))))*unsafe.Sizeof(*code)))), BOOL((int32(0))))
		var op int32 = int32(uint8((*scode)))
		if (((op == OP_BRA) || (op == OP_BRAPOS)) || (op == OP_SBRA)) || (op == OP_SBRAPOS) {
			if int32((NotBOOL(is_anchored(scode, bracket_map, cd, atomcount)))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (((op == OP_CBRA) || (op == OP_CBRAPOS)) || (op == OP_SCBRA)) || (op == OP_SCBRAPOS) {
			var n int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(scode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(scode)))))))))))
			var new_map int32 = int32((bracket_map | uint32(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(n < int32(32))]) != 0 {
					return (int32(1) << uint64(n))
				} else {
					return int32(1)
				}
			}())))
			if int32((NotBOOL(is_anchored(scode, uint32(new_map), cd, atomcount)))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (op == OP_ASSERT) || (op == OP_COND) {
			if int32((NotBOOL(is_anchored(scode, bracket_map, cd, atomcount)))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (op == OP_ONCE) || (op == OP_ONCE_NC) {
			if int32((NotBOOL(is_anchored(scode, bracket_map, cd, (atomcount + int32(1)))))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (map[bool]int32{false: 0, true: 1}[(((op == OP_TYPESTAR) || (op == OP_TYPEMINSTAR)) || (op == OP_TYPEPOSSTAR))]) != 0 {
			if (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode))))))) != OP_ALLANY) || ((bracket_map & (*cd).backref_map) != uint32(int32(0)))) || (atomcount > int32(0))) || (int32((BOOL((*cd).had_pruneorskip))) != 0) {
				return BOOL((int32(0)))
			}
		} else if ((op != OP_SOD) && (op != OP_SOM)) && (op != OP_CIRC) {
			return BOOL((int32(0)))
		}
		code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
			break
		}
	}
	return BOOL((int32(1)))
}

// is_startline - transpiled function from  /root/Documents/pcre/pcre_compile.c:8749
/*************************************************
*         Check for starting with ^ or .*        *
*************************************************/ //
/* This is called to find out if every branch starts with ^ or .* so that
"first char" processing can be done to speed things up in multiline
matching and for non-DOTALL patterns that start with .* (which must start at
the beginning or after \n). As in the case of is_anchored() (see above), we
have to take account of back references to capturing brackets that contain .*
because in that case we can't make the assumption. Also, the appearance of .*
inside atomic brackets or in an assertion, or in a pattern that contains *PRUNE
or *SKIP does not count, because once again the assumption no longer holds.

Arguments:
  code           points to start of expression (the bracket)
  bracket_map    a bitmap of which brackets we are inside while testing; this
                  handles up to substring 31; after that we just have to take
                  the less precise approach
  cd             points to the compile data
  atomcount      atomic group level
  inassert       TRUE if in an assertion

Returns:         TRUE or FALSE
*/ //
/* If we are at the start of a conditional assertion group, *both* the
   conditional assertion *and* what follows the condition must satisfy the test
   for start of line. Other kinds of condition fail. Note that there may be an
   auto-callout at the start of a condition. */ //
/* Assertion */ //
/* Non-capturing brackets */ //
/* Capturing brackets */ //
/* Positive forward assertions */ //
/* Atomic brackets */ //
/* .* means "start at start or after \n" if it isn't in atomic brackets or
   brackets that may be referenced or an assertion, as long as the pattern does
   not contain *PRUNE or *SKIP, because these break the feature. Consider, for
   example, /.*?a(*PRUNE)b/ with the subject "aab", which matches "ab", i.e.
   not at the start of a line. */ //
/* Check for explicit circumflex; anything else gives a FALSE result. Note
   in particular that this includes atomic brackets OP_ONCE and OP_ONCE_NC
   because the number of characters matched by .* cannot be adjusted inside
   them. */ //
/* Move on to the next alternative */ //
/* Loop for each alternative */ //
//
func is_startline(code *pcre_uchar, bracket_map uint32, cd *compile_data, atomcount int32, inassert BOOL) BOOL {
	for {
		var scode *pcre_uchar = first_significant_code(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &_pcre_OP_lengths[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*code))))*unsafe.Sizeof(*tempVar))
		}()))))))*unsafe.Sizeof(*code)))), BOOL((int32(0))))
		var op int32 = int32(uint8((*scode)))
		if op == OP_COND {
			scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*scode))))
			if int32(uint8((*scode))) == OP_CALLOUT {
				scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CALLOUT)*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*scode))))
			}
			switch int32(uint8((pcre_uchar(*scode)))) {
			case OP_CREF:
				fallthrough
			case OP_DNCREF:
				fallthrough
			case OP_RREF:
				fallthrough
			case OP_DNRREF:
				fallthrough
			case OP_DEF:
				fallthrough
			case OP_FAIL:
				{
					return BOOL((int32(0)))
				}
			default:
				{
					if int32((NotBOOL(is_startline(scode, bracket_map, cd, atomcount, BOOL((int32(1))))))) != 0 {
						return BOOL((int32(0)))
					}
					for {
						scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))))*unsafe.Sizeof(*scode))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*scode))) == OP_ALT)])) != 0 {
							break
						}
					}
					scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*scode))))
					break
				}
			}
			scode = first_significant_code(scode, BOOL((int32(0))))
			op = int32(uint8((*scode)))
		}
		if (((op == OP_BRA) || (op == OP_BRAPOS)) || (op == OP_SBRA)) || (op == OP_SBRAPOS) {
			if int32((NotBOOL(is_startline(scode, bracket_map, cd, atomcount, BOOL(inassert))))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (((op == OP_CBRA) || (op == OP_CBRAPOS)) || (op == OP_SCBRA)) || (op == OP_SCBRAPOS) {
			var n int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(scode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(scode)))))))))))
			var new_map int32 = int32((bracket_map | uint32(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(n < int32(32))]) != 0 {
					return (int32(1) << uint64(n))
				} else {
					return int32(1)
				}
			}())))
			if int32((NotBOOL(is_startline(scode, uint32(new_map), cd, atomcount, BOOL(inassert))))) != 0 {
				return BOOL((int32(0)))
			}
		} else if op == OP_ASSERT {
			if int32((NotBOOL(is_startline(scode, bracket_map, cd, atomcount, BOOL((int32(1))))))) != 0 {
				return BOOL((int32(0)))
			}
		} else if (op == OP_ONCE) || (op == OP_ONCE_NC) {
			if int32((NotBOOL(is_startline(scode, bracket_map, cd, (atomcount + int32(1)), BOOL(inassert))))) != 0 {
				return BOOL((int32(0)))
			}
		} else if ((op == OP_TYPESTAR) || (op == OP_TYPEMINSTAR)) || (op == OP_TYPEPOSSTAR) {
			if ((((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode))))))) != OP_ANY) || ((bracket_map & (*cd).backref_map) != uint32(int32(0)))) || (atomcount > int32(0))) || (int32((BOOL((*cd).had_pruneorskip))) != 0)) || (int32((inassert)) != 0) {
				return BOOL((int32(0)))
			}
		} else if (op != OP_CIRC) && (op != OP_CIRCM) {
			return BOOL((int32(0)))
		}
		code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
			break
		}
	}
	return BOOL((int32(1)))
}

// find_firstassertedchar - transpiled function from  /root/Documents/pcre/pcre_compile.c:8870
/*************************************************
*       Check for asserted fixed first char      *
*************************************************/ //
/* During compilation, the "first char" settings from forward assertions are
discarded, because they can cause conflicts with actual literals that follow.
However, if we end up without a first char setting for an unanchored pattern,
it is worth scanning the regex to see if there is an initial asserted first
char. If all branches start with the same asserted char, or with a
non-conditional bracket all of whose alternatives start with the same asserted
char (recurse ad lib), then we return that char, with the flags set to zero or
REQ_CASELESS; otherwise return zero with REQ_NONE in the flags.

Arguments:
  code       points to start of expression (the bracket)
  flags      points to the first char flags, or to REQ_NONE
  inassert   TRUE if in an assertion

Returns:     the fixed first char, or 0 with REQ_NONE in flags
*/ //
/* Fall through */ //
/* Fall through */ //
//
func find_firstassertedchar(code *pcre_uchar, flags *pcre_int32, inassert BOOL) pcre_uint32 {
	var c pcre_uint32 = pcre_uint32(int32(0))
	var cflags int32 = -int32(1)
	*flags = pcre_int32((-int32(1)))
	for {
		var d pcre_uint32
		var dflags int32
		var xl int32 = func() int32 {
			if (map[bool]int32{false: 0, true: 1}[((((int32(uint8((*code))) == OP_CBRA) || (int32(uint8((*code))) == OP_SCBRA)) || (int32(uint8((*code))) == OP_CBRAPOS)) || (int32(uint8((*code))) == OP_SCBRAPOS))]) != 0 {
				return int32(2)
			} else {
				return int32(0)
			}
		}()
		var scode *pcre_uchar = first_significant_code(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(xl)*unsafe.Sizeof(*tempVar))
		}())), BOOL((int32(1))))
		var op pcre_uchar = *scode
		switch int32(uint8((pcre_uchar(op)))) {
		default:
			{
				return pcre_uint32(int32(0))
			}
		case OP_BRA:
			fallthrough
		case OP_BRAPOS:
			fallthrough
		case OP_CBRA:
			fallthrough
		case OP_SCBRA:
			fallthrough
		case OP_CBRAPOS:
			fallthrough
		case OP_SCBRAPOS:
			fallthrough
		case OP_ASSERT:
			fallthrough
		case OP_ONCE:
			fallthrough
		case OP_ONCE_NC:
			{
				d = find_firstassertedchar(scode, (*pcre_int32)(unsafe.Pointer(&dflags)), BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((op))) == OP_ASSERT)])))
				if dflags < int32(0) {
					return pcre_uint32(int32(0))
				}
				if cflags < int32(0) {
					c = d
					cflags = dflags
				} else if (c != d) || (cflags != dflags) {
					return pcre_uint32(int32(0))
				}
			}
		case OP_EXACT:
			{
				scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(2))*unsafe.Sizeof(*scode))))
			}
			fallthrough
		case OP_CHAR:
			fallthrough
		case OP_PLUS:
			fallthrough
		case OP_MINPLUS:
			fallthrough
		case OP_POSPLUS:
			{
				if int32((NotBOOL(BOOL(inassert)))) != 0 {
					return pcre_uint32(int32(0))
				}
				if cflags < int32(0) {
					c = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode)))))))))
					cflags = int32(0)
				} else if c != pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode))))))))) {
					return pcre_uint32(int32(0))
				}
			}
		case OP_EXACTI:
			{
				scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(2))*unsafe.Sizeof(*scode))))
			}
			fallthrough
		case OP_CHARI:
			fallthrough
		case OP_PLUSI:
			fallthrough
		case OP_MINPLUSI:
			fallthrough
		case OP_POSPLUSI:
			{
				if int32((NotBOOL(BOOL(inassert)))) != 0 {
					return pcre_uint32(int32(0))
				}
				if cflags < int32(0) {
					c = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode)))))))))
					cflags = (int32(1) << uint64(int32(0)))
				} else if c != pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(int32(1))*unsafe.Sizeof(*scode))))))))) {
					return pcre_uint32(int32(0))
				}
				break
			}
		}
		code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
			break
		}
	}
	*flags = pcre_int32((cflags))
	return pcre_uint32(c)
}

// add_name - transpiled function from  /root/Documents/pcre/pcre_compile.c:8961
/*************************************************
*     Add an entry to the name/number table      *
*************************************************/ //
/* This function is called between compiling passes to add an entry to the
name/number table, maintaining alphabetical order. Checking for permitted
and forbidden duplicates has already been done.

Arguments:
  cd           the compile data block
  name         the name to add
  length       the length of the name
  groupno      the group number

Returns:       nothing
*/ //
/* Current name is a substring */ //
/* Make space in the table and break the loop for an earlier name. For a
duplicate or later name, carry on. We do this for duplicates so that in the
simple case (when ?(| is not used) they are in order of their numbers. In all
cases they are in the order in which they appear in the pattern. */ //
/* Continue the loop for a later or duplicate name */ //
//
func add_name(cd *compile_data, name *pcre_uchar, length int32, groupno uint32) {
	var i int32
	var slot *pcre_uchar = (*cd).name_table
	for i = int32(0); i < (*cd).names_found; i++ {
		var crc int32 = noarch.Memcmp(unsafe.Pointer(name), unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)(int32(2))*unsafe.Sizeof(*slot))))), int32(uint32((length))))
		if (crc == int32(0)) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((int32(2)+length))*unsafe.Sizeof(*slot))))))) != int32(0)) {
			crc = -int32(1)
		}
		if crc < int32(0) {
			noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))), unsafe.Pointer(slot), int32(uint32((((*cd).names_found - i) * (*cd).name_entry_size))))
			break
		}
		slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*cd).name_entry_size)*unsafe.Sizeof(*slot))))
	}
	*slot = pcre_uchar((uint8((groupno >> uint64(int32(8))))))
	*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*slot)))) = pcre_uchar((uint8((groupno & uint32(int32(255))))))
	noarch.Memcpy(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)(int32(2))*unsafe.Sizeof(*slot))))), unsafe.Pointer(name), int32(uint32((length))))
	*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((int32(2)+length))*unsafe.Sizeof(*slot)))) = pcre_uchar(int32(0))
	(*cd).names_found += int32(1)
}

// pcre_compile - transpiled function from  /root/Documents/pcre/pcre_compile.c:9022
/*************************************************
*        Compile a Regular Expression            *
*************************************************/ //
/* This function takes a string and returns a pointer to a block of store
holding a compiled version of the expression. The original API for this
function had no error code return variable; it is retained for backwards
compatibility. The new function is given a new name.

Arguments:
  pattern       the regular expression
  options       various option bits
  errorcodeptr  pointer to error code variable (pcre_compile2() only)
                  can be NULL if you don't want a code value
  errorptr      pointer to pointer to error text
  erroroffset   ptr offset in pattern where error was detected
  tables        pointer to character tables or NULL

Returns:        pointer to compiled data block, or NULL on error,
                with errorptr and erroroffset set
*/ //
//
func pcre_compile(pattern *byte, options int32, errorptr **byte, erroroffset *int32, tables *uint8) *pcre {
	return pcre_compile2(pattern, options, nil, errorptr, erroroffset, tables)
}

// pcre_compile2 - transpiled function from  /root/Documents/pcre/pcre_compile.c:9046
/* For final END opcode */ //
/* This space is used for "compiling" into during the first phase, when we are
computing the amount of memory that is needed. Compiled items are thrown away
as soon as possible, so that a fairly large buffer should be sufficient for
this purpose. The same space is used in the second phase for remembering where
to fill in forward references to subpatterns. That may overflow, in which case
new memory is obtained from malloc(). */ //
/* This vector is used for remembering name groups during the pre-compile. In a
similar way to cworkspace, it can be expanded using malloc() if necessary. */ //
/* Set this early so that early errors get offset 0. */ //
/* We can't pass back an error message if errorptr is NULL; I guess the best we
can do is just return NULL, but we can set a code value if there is a code
pointer. */ //
/* However, we can give a message for this error */ //
/* Set up pointers to the individual character tables */ //
/* Check that all undefined public option bits are zero */ //
/* If PCRE_NEVER_UTF is set, remember it. */ //
/* Check for global one-time settings at the start of the pattern, and remember
the offset for later. */ //
/* Initialize here for LIMIT_MATCH/RECURSION */ //
/* For completeness and backward compatibility, (*UTFn) is supported in the
relevant libraries, but (*UTF) is generic and always supported. Note that
PCRE_UTF8 == PCRE_UTF16 == PCRE_UTF32. */ //
/* Integer overflow */ //
/* Integer overflow check */ //
/* PCRE_UTF(16|32) have the same value as PCRE_UTF8. */ //
/* Can't support UTF unless PCRE has been compiled to include the code. The
return of an error code from PRIV(valid_utf)() is a new feature, introduced in
release 8.13. It is passed back from pcre_[dfa_]exec(), but at the moment is
not used here. */ //
/* Can't support UCP unless PCRE has been compiled to include the code. */ //
/* Check validity of \R options. */ //
/* Handle different types of newline. The three bits give seven cases. The
current code allows for fixed one- or two-byte sequences, plus "any" and
"anycrlf". */ //
/* Build-time default */ //
/* Maximum back reference and backref bitmap. The bitmap records up to 31 back
references to help in deciding whether (.*) can be treated as anchored or not.
*/ //
/* Reflect pattern for debugging output */ //
/* Pretend to compile the pattern while actually just accumulating the length
of memory required. This behaviour is triggered by passing a non-NULL final
argument to compile_regex(). We pass a block of workspace (cworkspace) for it
to compile parts of the pattern into; the compiled code is discarded when it is
no longer needed, so hopefully this workspace will never overflow, though there
is a test for its doing so. */ //
/* Now do the pre-compile. On error, errorcode will be set non-zero, so we
don't need to look at the result of the function here. The initial options have
been put into the cd block so that they can be changed if an option setting is
found within the regex right at the beginning. Bringing initial option settings
outside can help speed up starting point checks. */ //
/* Compute the size of the data block for storing the compiled pattern. Integer
overflow should no longer be possible because nowadays we limit the maximum
value of cd->names_found and cd->name_entry_size. */ //
/* Get the memory. */ //
/* Put in the magic number, and save the sizes, initial options, internal
flags, and character table pointer. NULL is used for the default character
tables. The nullpad field is at the end; it's there to help in the case when a
regex compiled on a system with 4-byte pointers is run on another with 8-byte
pointers. */ //
/* The starting points of the name/number translation table and of the code are
passed around in the compile data block. The start/end pattern and initial
options are already set from the pre-compile phase, as is the name_entry_size
field. Reset the bracket count and the names_found field. Also reset the hwm
field; this time it's used for remembering forward references to subpatterns.
*/ //
/* Save for checking forward references */ //
/* If any named groups were found, create the name/number table from the list
created in the first pass. */ //
/* Set up a starting, non-extracting bracket, then compile the expression. On
error, errorcode will be set non-zero, so we don't need to look at the result
of the function here. */ //
/* Must disable after (*ACCEPT) */ //
/* If not reached end of pattern on success, there's an excess bracket. */ //
/* Fill in the terminating state and check for disastrous overflow, but
if debugging, leave the test till after things are printed out. */ //
/* Fill in any forward references that are required. There may be repeated
references; optimize for them, as searching a large regex takes time. */ //
/* Check that the hwm handling hasn't gone wrong. This whole area is
   rewritten in PCRE2 because there are some obscure cases. */ //
/* If the workspace had to be expanded, free the new memory. Set the pointer to
NULL to indicate that forward references have been filled in. */ //
/* Give an error if there's back reference to a non-existent capturing
subpattern. */ //
/* Unless disabled, check whether any single character iterators can be
auto-possessified. The function overwrites the appropriate opcode values, so
the type of the pointer must be cast. NOTE: the intermediate variable "temp" is
used in this code because at least one compiler gives a warning about loss of
"const" attribute if the cast (pcre_uchar *)codestart is used directly in the
function call. */ //
/* If there were any lookbehind assertions that contained OP_RECURSE
(recursions or subroutine calls), a flag is set for them to be checked here,
because they may contain forward references. Actual recursions cannot be fixed
length, but subroutine calls can. It is done like this so that those without
OP_RECURSE that are not fixed length get a diagnosic with a useful offset. The
exceptional ones forgo this. We scan the pattern to check that they are fixed
length, and set their lengths. */ //
/* Loop, searching for OP_REVERSE items, and process those that do not have
their length set. (Actually, it will also re-process any that have a length
of zero, but that is a pathological case, and it does no harm.) When we find
one, we temporarily terminate the branch it is in while we scan it. */ //
/* Failed to compile, or error while post-processing */ //
/* If the anchored option was not passed, set the flag if we can determine that
the pattern is anchored by virtue of ^ characters or \A or anything else, such
as starting with non-atomic .* when DOTALL is set and there are no occurrences
of *PRUNE or *SKIP.

Otherwise, if we know what the first byte has to be, save it, because that
speeds up unanchored matches no end. If not, see if we can set the
PCRE_STARTLINE flag. This is helpful for multiline matches when all branches
start with ^. and also when all branches start with non-atomic .* for
non-DOTALL matches when *PRUNE and SKIP are not present. */ //
/* Remove caseless flag for non-caseable chars */ //
/* For an anchored pattern, we use the "required byte" only if it follows a
variable length item in the regex. Remove the caseless flag for non-caseable
bytes. */ //
/* Print out the compiled data if debugging is enabled. This is never the
case when building a production library. */ //
/* Check for a pattern than can match an empty string, so that this information
can be provided to applications. */ //
//
func pcre_compile2(pattern *byte, options int32, errorcodeptr *int32, errorptr **byte, erroroffset *int32, tables *uint8) *pcre {
	var re *real_pcre
	var length int32 = int32(1)
	var firstcharflags pcre_int32
	var reqcharflags pcre_int32
	var firstchar pcre_uint32
	var reqchar pcre_uint32
	var limit_match pcre_uint32 = pcre_uint32(((uint32(int32(2147483647)) * uint32(2)) + uint32(1)))
	var limit_recursion pcre_uint32 = pcre_uint32(((uint32(int32(2147483647)) * uint32(2)) + uint32(1)))
	var newline int32
	var errorcode int32 = int32(0)
	var skipatstart int32 = int32(0)
	var utf BOOL
	var never_utf BOOL = BOOL((int32(0)))
	var size size_t
	var code *pcre_uchar
	var codestart *pcre_uchar
	var ptr *pcre_uchar
	var compile_block compile_data
	var cd *compile_data = &compile_block
	var cworkspace []pcre_uchar = make([]pcre_uchar, 4096, 4096)
	var named_groups []named_group = make([]named_group, 20, 20)
	var gotoErrorReturn int
	ptr = (*pcre_uchar)(unsafe.Pointer(pattern))
	if errorptr == nil {
		if errorcodeptr != nil {
			*errorcodeptr = int32(99)
		}
		return nil
	}
	*errorptr = nil
	if errorcodeptr != nil {
		*errorcodeptr = ERR0
	}
	if erroroffset == nil {
		errorcode = ERR16
		gotoErrorReturn = 2
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	*erroroffset = int32(0)
	if tables == nil {
		tables = (*uint8)(unsafe.Pointer(&_pcre_default_tables[0]))
	}
	(*cd).lcc = (*pcre_uint8)(unsafe.Pointer(((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(0))*unsafe.Sizeof(*tables))))))
	(*cd).fcc = (*pcre_uint8)(unsafe.Pointer(((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(256))*unsafe.Sizeof(*tables))))))
	(*cd).cbits = (*pcre_uint8)(unsafe.Pointer(((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(512))*unsafe.Sizeof(*tables))))))
	(*cd).ctypes = (*pcre_uint8)(unsafe.Pointer(((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)((int32(512)+int32(320)))*unsafe.Sizeof(*tables))))))
	if (options & ^(((((((((((((((((((((int32(1) | int32(8)) | int32(16)) | int32(2)) | int32(4)) | int32(32)) | int32(64)) | int32(512)) | int32(2048)) | int32(4096)) | int32(131072)) | int32(8192)) | int32(16384)) | int32(262144)) | int32(524288)) | (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) | int32(8388608)) | int32(16777216)) | int32(33554432)) | int32(536870912)) | int32(67108864)) | int32(65536))) != int32(0) {
		errorcode = ERR17
		gotoErrorReturn = 1
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	if (options & int32(65536)) != int32(0) {
		never_utf = BOOL((int32(1)))
	}
	(*cd).external_flags = pcre_uint32(int32(0))
	for (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))))) == int32('(')) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)((skipatstart+int32(1)))*unsafe.Sizeof(*ptr))))))) == int32('*')) {
		var newnl int32 = int32(0)
		var newbsr int32 = int32(0)
		if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("UTF8)\x00"), 1, 1))))[0], int32(uint32((int32(5))))) == int32(0) {
			skipatstart += int32(7)
			options |= int32(2048)
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("UTF)\x00"), 1, 1))))[0], int32(uint32((int32(4))))) == int32(0) {
			skipatstart += int32(6)
			options |= int32(2048)
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("UCP)\x00"), 1, 1))))[0], int32(uint32((int32(4))))) == int32(0) {
			skipatstart += int32(6)
			options |= int32(536870912)
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("NO_AUTO_POSSESS)\x00"), 1, 1))))[0], int32(uint32((int32(16))))) == int32(0) {
			skipatstart += int32(18)
			options |= int32(131072)
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("NO_START_OPT)\x00"), 1, 1))))[0], int32(uint32((int32(13))))) == int32(0) {
			skipatstart += int32(15)
			options |= int32(67108864)
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("LIMIT_MATCH=\x00"), 1, 1))))[0], int32(uint32((int32(12))))) == int32(0) {
			var c pcre_uint32 = pcre_uint32(int32(0))
			var p int32 = (skipatstart + int32(14))
			for (int32(*((*uint16)(func() unsafe.Pointer {
				tempVar := (*linux.CtypeLoc())
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uchar((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(p)*unsafe.Sizeof(*ptr))))))))))*unsafe.Sizeof(*tempVar))
			}()))) & int32(uint16(_ISdigit))) != 0 {
				if c > pcre_uint32(((((uint32(int32(2147483647)) * uint32(2)) + uint32(1)) / uint32(int32(10))) - uint32(int32(1)))) {
					break
				}
				c = (((c * pcre_uint32((uint32(int32(10))))) + pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(func() int32 {
					defer func() {
						p += 1
					}()
					return p
				}())*unsafe.Sizeof(*ptr)))))))))) - pcre_uint32((uint32('0'))))
			}
			if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(func() int32 {
				defer func() {
					p += 1
				}()
				return p
			}())*unsafe.Sizeof(*ptr))))))) != int32(')') {
				break
			}
			if c < limit_match {
				limit_match = c
				(*cd).external_flags |= pcre_uint32((uint32(int32(8192))))
			}
			skipatstart = p
			continue
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("LIMIT_RECURSION=\x00"), 1, 1))))[0], int32(uint32((int32(16))))) == int32(0) {
			var c pcre_uint32 = pcre_uint32(int32(0))
			var p int32 = (skipatstart + int32(18))
			for (int32(*((*uint16)(func() unsafe.Pointer {
				tempVar := (*linux.CtypeLoc())
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uchar((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(p)*unsafe.Sizeof(*ptr))))))))))*unsafe.Sizeof(*tempVar))
			}()))) & int32(uint16(_ISdigit))) != 0 {
				if c > pcre_uint32(((((uint32(int32(2147483647)) * uint32(2)) + uint32(1)) / uint32(int32(10))) - uint32(int32(1)))) {
					break
				}
				c = (((c * pcre_uint32((uint32(int32(10))))) + pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(func() int32 {
					defer func() {
						p += 1
					}()
					return p
				}())*unsafe.Sizeof(*ptr)))))))))) - pcre_uint32((uint32('0'))))
			}
			if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(func() int32 {
				defer func() {
					p += 1
				}()
				return p
			}())*unsafe.Sizeof(*ptr))))))) != int32(')') {
				break
			}
			if c < limit_recursion {
				limit_recursion = c
				(*cd).external_flags |= pcre_uint32((uint32(int32(16384))))
			}
			skipatstart = p
			continue
		}
		if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("CR)\x00"), 1, 1))))[0], int32(uint32((int32(3))))) == int32(0) {
			skipatstart += int32(5)
			newnl = int32(1048576)
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("LF)\x00"), 1, 1))))[0], int32(uint32((int32(3))))) == int32(0) {
			skipatstart += int32(5)
			newnl = int32(2097152)
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("CRLF)\x00"), 1, 1))))[0], int32(uint32((int32(5))))) == int32(0) {
			skipatstart += int32(7)
			newnl = (int32(1048576) + int32(2097152))
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("ANY)\x00"), 1, 1))))[0], int32(uint32((int32(4))))) == int32(0) {
			skipatstart += int32(6)
			newnl = int32(4194304)
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("ANYCRLF)\x00"), 1, 1))))[0], int32(uint32((int32(8))))) == int32(0) {
			skipatstart += int32(10)
			newnl = int32(5242880)
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("BSR_ANYCRLF)\x00"), 1, 1))))[0], int32(uint32((int32(12))))) == int32(0) {
			skipatstart += int32(14)
			newbsr = int32(8388608)
		} else if noarch.Strncmp((*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}())))), &(*(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("BSR_UNICODE)\x00"), 1, 1))))[0], int32(uint32((int32(12))))) == int32(0) {
			skipatstart += int32(14)
			newbsr = int32(16777216)
		}
		if newnl != int32(0) {
			options = ((options & ^(((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) | newnl)
		} else if newbsr != int32(0) {
			options = ((options & ^(int32(8388608) | int32(16777216))) | newbsr)
		} else {
			break
		}
	}
	utf = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))]))
	if (int32((utf)) != 0) && (int32((never_utf)) != 0) {
		errorcode = ERR78
		gotoErrorReturn = 2
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	if ((int32((utf)) != 0) && ((options & int32(8192)) == int32(0))) && ((func() int32 {
		tempVar := _pcre_valid_utf((*pcre_uchar)(unsafe.Pointer(pattern)), -int32(1), erroroffset)
		errorcode = tempVar
		return tempVar
	}()) != int32(0)) {
		errorcode = ERR44
		gotoErrorReturn = 2
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	if (options & (int32(8388608) | int32(16777216))) == (int32(8388608) | int32(16777216)) {
		errorcode = ERR56
		gotoErrorReturn = 1
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	switch options & (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880)) {
	case int32(0):
		{
			newline = int32(10)
		}
	case int32(1048576):
		{
			newline = int32('\r')
		}
	case int32(2097152):
		{
			newline = int32('\n')
		}
	case (int32(1048576) + int32(2097152)):
		{
			newline = int32((('\r' << uint64(int32(8))) | '\n'))
		}
	case int32(4194304):
		{
			newline = -int32(1)
		}
	case int32(5242880):
		{
			newline = -int32(2)
		}
	default:
		{
			errorcode = ERR56
			gotoErrorReturn = 1
			goto PCRE_EARLY_ERROR_RETURN_CONTAINER
		}
	}
	if newline == -int32(2) {
		(*cd).nltype = int32(2)
	} else if newline < int32(0) {
		(*cd).nltype = int32(1)
	} else {
		(*cd).nltype = int32(0)
		if newline > int32(255) {
			(*cd).nllen = int32(2)
			*&(*cd).nl[0] = pcre_uchar((uint8(((newline >> uint64(int32(8))) & int32(255)))))
			*((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := &(*cd).nl[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) = pcre_uchar((uint8((newline & int32(255)))))
		} else {
			(*cd).nllen = int32(1)
			*&(*cd).nl[0] = pcre_uchar((uint8(newline)))
		}
	}
	(*cd).top_backref = int32(0)
	(*cd).backref_map = uint32(int32(0))
	(*cd).bracount = uint32((func() int32 {
		tempVar := int32(0)
		(*cd).final_bracount = tempVar
		return tempVar
	}()))
	(*cd).names_found = int32(0)
	(*cd).name_entry_size = int32(0)
	(*cd).name_table = nil
	(*cd).dupnames = BOOL((int32(0)))
	(*cd).dupgroups = BOOL((int32(0)))
	(*cd).namedrefcount = uint32(int32(0))
	(*cd).start_code = &cworkspace[0]
	(*cd).hwm = &cworkspace[0]
	(*cd).iscondassert = BOOL((int32(0)))
	(*cd).start_workspace = &cworkspace[0]
	(*cd).workspace_size = (int32(2048) * int32(2))
	(*cd).named_groups = &named_groups[0]
	(*cd).named_group_list_size = int32(20)
	(*cd).start_pattern = (*pcre_uchar)(unsafe.Pointer(pattern))
	(*cd).end_pattern = (*pcre_uchar)(unsafe.Pointer(((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(pattern)) + (uintptr)(noarch.Strlen((*byte)(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(pattern))))))*unsafe.Sizeof(*pattern))))))
	(*cd).req_varyopt = int32(0)
	(*cd).parens_depth = int32(0)
	(*cd).assert_depth = int32(0)
	(*cd).max_lookbehind = int32(0)
	(*cd).external_options = pcre_uint32((uint32(options)))
	(*cd).open_caps = nil
	ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(skipatstart)*unsafe.Sizeof(*ptr))))
	code = &cworkspace[0]
	*code = pcre_uchar((uint8(OP_BRA)))
	_ = compile_regex(int32(uint32((pcre_uint32((*cd).external_options)))), &code, &ptr, &errorcode, BOOL((int32(0))), BOOL((int32(0))), int32(0), int32(0), &firstchar, &firstcharflags, &reqchar, &reqcharflags, nil, cd, &length)
	if errorcode != int32(0) {
		gotoErrorReturn = 1
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	if length > (int32(1) << uint64(int32(16))) {
		errorcode = ERR20
		gotoErrorReturn = 1
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	size = size_t((64 + (uint32((length + ((*cd).names_found * (*cd).name_entry_size))) * 1)))
	re = (*real_pcre)(pcre_malloc(size_t(size)))
	if re == nil {
		errorcode = ERR21
		gotoErrorReturn = 1
		goto PCRE_EARLY_ERROR_RETURN_CONTAINER
	}
	(*re).magic_number = pcre_uint32(1346589253)
	(*re).size = pcre_uint32((uint32(int32(uint32((size_t(size)))))))
	(*re).options = pcre_uint32((*cd).external_options)
	(*re).flags = pcre_uint32((*cd).external_flags)
	(*re).limit_match = limit_match
	(*re).limit_recursion = limit_recursion
	(*re).first_char = pcre_uint16(int32(0))
	(*re).req_char = pcre_uint16(int32(0))
	(*re).name_table_offset = pcre_uint16((uint16((64 / 1))))
	(*re).name_entry_size = pcre_uint16((uint16((*cd).name_entry_size)))
	(*re).name_count = pcre_uint16((uint16((*cd).names_found)))
	(*re).ref_count = pcre_uint16(int32(0))
	(*re).tables = (*pcre_uint8)(unsafe.Pointer(func() *uint8 {
		if (map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(tables))) == int64(uintptr(unsafe.Pointer(&_pcre_default_tables[0]))))]) != 0 {
			return nil
		} else {
			return tables
		}
	}()))
	(*re).nullpad = nil
	(*re).dummy3 = pcre_uint16(int32(0))
	(*re).dummy2 = (*re).dummy3
	(*re).dummy1 = (*re).dummy2
	(*cd).final_bracount = int32((*cd).bracount)
	(*cd).parens_depth = int32(0)
	(*cd).assert_depth = int32(0)
	(*cd).bracount = uint32(int32(0))
	(*cd).max_lookbehind = int32(0)
	(*cd).name_table = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(re))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
	}()))
	codestart = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*cd).name_table
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint16((pcre_uint16((*re).name_entry_size))))*int32(uint16((pcre_uint16((*re).name_count))))))*unsafe.Sizeof(*tempVar))
	}()))
	(*cd).start_code = codestart
	(*cd).hwm = ((*cd).start_workspace)
	(*cd).iscondassert = BOOL((int32(0)))
	(*cd).req_varyopt = int32(0)
	(*cd).had_accept = BOOL((int32(0)))
	(*cd).had_pruneorskip = BOOL((int32(0)))
	(*cd).check_lookbehind = BOOL((int32(0)))
	(*cd).open_caps = nil
	if (*cd).names_found > int32(0) {
		var i int32 = (*cd).names_found
		var ng *named_group = (*cd).named_groups
		(*cd).names_found = int32(0)
		for i > int32(0) {
			add_name(cd, (*ng).name, (*ng).length, uint32((pcre_uint32((*ng).number))))
			i -= 1
			ng = ((*named_group)(unsafe.Pointer(uintptr(unsafe.Pointer(ng)) + (uintptr)(1)*unsafe.Sizeof(*ng))))
		}
		if (*cd).named_group_list_size > int32(20) {
			pcre_free(unsafe.Pointer((*cd).named_groups))
		}
	}
	ptr = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(pattern))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(skipatstart)*unsafe.Sizeof(*tempVar))
	}()))
	code = codestart
	*code = pcre_uchar((uint8(OP_BRA)))
	_ = compile_regex(int32(uint32((pcre_uint32((*re).options)))), &code, &ptr, &errorcode, BOOL((int32(0))), BOOL((int32(0))), int32(0), int32(0), &firstchar, &firstcharflags, &reqchar, &reqcharflags, nil, cd, nil)
	(*re).top_bracket = pcre_uint16((uint16((*cd).bracount)))
	(*re).top_backref = pcre_uint16((uint16((*cd).top_backref)))
	(*re).max_lookbehind = pcre_uint16((uint16((*cd).max_lookbehind)))
	(*re).flags = (pcre_uint32((*cd).external_flags) | pcre_uint32((uint32(int32(1)))))
	if int32((BOOL((*cd).had_accept))) != 0 {
		reqchar = pcre_uint32(int32(0))
		reqcharflags = pcre_int32((-int32(1)))
	}
	if (errorcode == int32(0)) && (int32(uint8((*ptr))) != int32('\x00')) {
		errorcode = ERR22
	}
	*func() *pcre_uchar {
		defer func() {
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
		}()
		return code
	}() = pcre_uchar((uint8(OP_END)))
	if (int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(codestart)))) > int64(length) {
		errorcode = ERR23
	}
	if int64(uintptr(unsafe.Pointer((*cd).hwm))) > int64(uintptr(unsafe.Pointer((*cd).start_workspace))) {
		var prev_recno int32 = -int32(1)
		var groupptr *pcre_uchar = nil
		for (errorcode == int32(0)) && (int64(uintptr(unsafe.Pointer((*cd).hwm))) > int64(uintptr(unsafe.Pointer((*cd).start_workspace)))) {
			var offset int32
			var recno int32
			(*cd).hwm = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*cd).hwm
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
			offset = ((int32(uint8((*((*cd).hwm)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*cd).hwm)
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*tempVar))
			}()))))))
			if (offset == int32(0)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(codestart)) + (uintptr)((offset-int32(1)))*unsafe.Sizeof(*codestart))))))) != OP_RECURSE) {
				errorcode = ERR10
				break
			}
			recno = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)(offset)*unsafe.Sizeof(*(codestart)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*(codestart)))))))))
			if recno != prev_recno {
				groupptr = _pcre_find_bracket(codestart, BOOL(utf), recno)
				prev_recno = recno
			}
			if groupptr == nil {
				errorcode = ERR53
			} else {
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)(offset)*unsafe.Sizeof(*(codestart))))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(groupptr))) - int64(uintptr(unsafe.Pointer(codestart)))))) >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)(offset)*unsafe.Sizeof(*(codestart)))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*(codestart))))) = pcre_uchar((uint8(((int32((int64(uintptr(unsafe.Pointer(groupptr))) - int64(uintptr(unsafe.Pointer(codestart)))))) & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*(codestart)))))
				}()
			}
		}
	}
	if (*cd).workspace_size > (int32(2048) * int32(2)) {
		pcre_free(unsafe.Pointer((*cd).start_workspace))
	}
	(*cd).start_workspace = nil
	if (errorcode == int32(0)) && (int32(uint16((pcre_uint16((*re).top_backref)))) > int32(uint16((pcre_uint16((*re).top_bracket))))) {
		errorcode = ERR15
	}
	if (errorcode == int32(0)) && ((options & int32(131072)) == int32(0)) {
		var temp *pcre_uchar = codestart
		auto_possessify(temp, BOOL(utf), cd)
	}
	if (errorcode == int32(0)) && (int32((BOOL((*cd).check_lookbehind))) != 0) {
		var cc *pcre_uchar = codestart
		for cc = _pcre_find_bracket(codestart, BOOL(utf), -int32(1)); cc != nil; cc = _pcre_find_bracket(cc, BOOL(utf), -int32(1)) {
			if ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))) == int32(0) {
				var fixed_length int32
				var be *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(int32(1))*unsafe.Sizeof(*cc))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}()))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) - (uintptr)(2)*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) - (uintptr)(1)*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*tempVar))
				}()))
				var end_op int32 = int32(uint8((*be)))
				*be = pcre_uchar((uint8(OP_END)))
				fixed_length = find_fixedlength(cc, BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(2048))))) != pcre_uint32((uint32(int32(0)))))])), BOOL((int32(1))), cd, nil)
				*be = pcre_uchar((uint8(end_op)))
				if fixed_length < int32(0) {
					errorcode = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[(fixed_length == -int32(2))]) != 0 {
							return ERR36
						} else {
							return func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(fixed_length == -int32(4))]) != 0 {
									return ERR70
								} else {
									return ERR25
								}
							}()
						}
					}()
					break
				}
				if fixed_length > (*cd).max_lookbehind {
					(*cd).max_lookbehind = fixed_length
				}
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc)))) = pcre_uchar((uint8((fixed_length >> uint64(int32(8))))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc))))
				}()
				func() pcre_uchar {
					*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*cc)))) = pcre_uchar((uint8((fixed_length & int32(255)))))
					return *((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*cc))))
				}()
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
		}
	}
PCRE_EARLY_ERROR_RETURN_CONTAINER:
	if errorcode != int32(0) || gotoErrorReturn != 0 {
		switch(gotoErrorReturn) {
		case 1:
			goto PCRE_EARLY_ERROR_RETURN
		case 2:
			goto PCRE_EARLY_ERROR_RETURN2
		}
		pcre_free(unsafe.Pointer(re))
	PCRE_EARLY_ERROR_RETURN:
		;
		*erroroffset = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(pattern))))))))
	PCRE_EARLY_ERROR_RETURN2:
		;
		*errorptr = find_error_text(errorcode)
		if errorcodeptr != nil {
			*errorcodeptr = errorcode
		}
		return nil
	}
	if (pcre_uint32((*re).options) & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
		if int32((is_anchored(codestart, uint32(int32(0)), cd, int32(0)))) != 0 {
			(*re).options |= pcre_uint32((uint32(int32(16))))
		} else {
			if firstcharflags < pcre_int32((int32(0))) {
				firstchar = find_firstassertedchar(codestart, &firstcharflags, BOOL((int32(0))))
			}
			if firstcharflags >= pcre_int32((int32(0))) {
				(*re).first_char = pcre_uint16((uint16(uint32((firstchar & pcre_uint32((uint32(int32(255)))))))))
				if (firstcharflags & pcre_int32((int32(1) << uint64(int32(0))))) != pcre_int32((int32(0))) {
					if (int32(1) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*cd).fcc
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).first_char)))))*unsafe.Sizeof(*tempVar))
					}()))))) != int32(uint16((pcre_uint16((*re).first_char))))) {
						(*re).flags |= pcre_uint32((uint32(int32(32))))
					}
				}
				(*re).flags |= pcre_uint32((uint32(int32(16))))
			} else if int32((is_startline(codestart, uint32(int32(0)), cd, int32(0), BOOL((int32(0)))))) != 0 {
				(*re).flags |= pcre_uint32((uint32(int32(256))))
			}
		}
	}
	if (reqcharflags >= pcre_int32((int32(0)))) && (((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0))))) || ((reqcharflags & pcre_int32((int32(1) << uint64(int32(1))))) != pcre_int32((int32(0))))) {
		(*re).req_char = pcre_uint16((uint16(uint32((reqchar & pcre_uint32((uint32(int32(255)))))))))
		if (reqcharflags & pcre_int32((int32(1) << uint64(int32(0))))) != pcre_int32((int32(0))) {
			if (int32(1) != 0) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*cd).fcc
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).req_char)))))*unsafe.Sizeof(*tempVar))
			}()))))) != int32(uint16((pcre_uint16((*re).req_char))))) {
				(*re).flags |= pcre_uint32((uint32(int32(128))))
			}
		}
		(*re).flags |= pcre_uint32((uint32(int32(64))))
	}
	for {
		if int32((could_be_empty_branch(codestart, code, BOOL(utf), cd, nil))) != 0 {
			(*re).flags |= pcre_uint32((uint32(int32(32768))))
			break
		}
		codestart = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(codestart)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)(int32(1))*unsafe.Sizeof(*(codestart))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((codestart))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(codestart))))))))))*unsafe.Sizeof(*codestart))))
		if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*codestart))) == OP_ALT)])) != 0 {
			break
		}
	}
	return (*pcre)(unsafe.Pointer(re))
}

var real_link_size int32 = int32(2)

// pcre_config - transpiled function from  /root/Documents/pcre/pcre_config.c:69
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_config(). */ //
/* Keep the original link size. */ //
/*************************************************
* Return info about what features are configured *
*************************************************/ //
/* This function has an extensible interface so that additional items can be
added compatibly.

Arguments:
  what             what information is required
  where            where to put the information

Returns:           0 if data returned, negative on error
*/ //
//
func pcre_config(what int32, where unsafe.Pointer) int32 {
	switch what {
	case int32(0):
		{
			*(*int32)(where) = int32(1)
		}
	case int32(10):
		{
			*(*int32)(where) = int32(0)
			return (-int32(3))
		}
	case int32(12):
		{
			*(*int32)(where) = int32(0)
			return (-int32(3))
		}
	case int32(6):
		{
			*(*int32)(where) = int32(1)
		}
	case int32(9):
		{
			*(*int32)(where) = int32(0)
		}
	case int32(11):
		{
			*(**byte)(where) = nil
		}
	case int32(1):
		{
			*(*int32)(where) = int32(10)
		}
	case int32(8):
		{
			*(*int32)(where) = int32(0)
		}
	case int32(2):
		{
			*(*int32)(where) = real_link_size
		}
	case int32(3):
		{
			*(*int32)(where) = int32(10)
		}
	case int32(13):
		{
			*(*uint32)(where) = uint32(int32(250))
		}
	case int32(4):
		{
			*(*uint32)(where) = uint32(int32(10000000))
		}
	case int32(7):
		{
			*(*uint32)(where) = uint32(int32(10000000))
		}
	case int32(5):
		{
			*(*int32)(where) = int32(1)
		}
	default:
		{
			return (-int32(3))
		}
	}
	return int32(0)
}

var coptable []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}
var poptable []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}
var toptable1 []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(4)), pcre_uint8(int32(4)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(16)), pcre_uint8(int32(16)), pcre_uint8(int32(0)), pcre_uint8(int32(0))}
var toptable2 []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(4)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_uint8(int32(16)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(1))}

type stateblock struct {
	offset int32
	count  int32
	data   int32
}

// internal_dfa_exec - transpiled function from  /root/Documents/pcre/pcre_dfa_exec.c:397
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language (but see
below for why this module is different).

                       Written by Philip Hazel
           Copyright (c) 1997-2017 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_dfa_exec(), which is an
alternative matching function that uses a sort of DFA algorithm (not a true
FSM). This is NOT Perl-compatible, but it has advantages in certain
applications. */ //
/* NOTE ABOUT PERFORMANCE: A user of this function sent some code that improved
the performance of his patterns greatly. I could not use it as it stood, as it
was not thread safe, and made assumptions about pattern sizes. Also, it caused
test 7 to loop, and test 9 to crash with a segfault.

The issue is the check for duplicate states, which is done by a simple linear
search up the state list. (Grep for "duplicate" below to find the code.) For
many patterns, there will never be many states active at one time, so a simple
linear search is fine. In patterns that have many active states, it might be a
bottleneck. The suggested code used an indexing scheme to remember which states
had previously been used for each character, and avoided the linear search when
it knew there was no chance of a duplicate. This was implemented when adding
states to the state lists.

I wrote some thread-safe, not-limited code to try something similar at the time
of checking for duplicates (instead of when adding states), using index vectors
on the stack. It did give a 13% improvement with one specially constructed
pattern for certain subject strings, but on other strings and on many of the
simpler patterns in the test suite it did worse. The major problem, I think,
was the extra time to initialize the index. This had to be done for each call
of internal_dfa_exec(). (The supplied patch used a static vector, initialized
only once - I suspect this was the cause of the problems with the tests.)

Overall, I concluded that the gains in some cases did not outweigh the losses
in others, so I abandoned this code. */ //
/* For use to indent debugging output */ //
/*************************************************
*      Code parameters and static tables         *
*************************************************/ //
/* These are offsets that are used to turn the OP_TYPESTAR and friends opcodes
into others, under special conditions. A gap of 20 between the blocks should be
enough. The resulting opcodes don't have to be less than 256 because they are
never stored, so we push them well clear of the normal opcodes. */ //
/* This table identifies those opcodes that are followed immediately by a
character that is to be tested in some way. This makes it possible to
centralize the loading of these characters. In the case of Type * etc, the
"character" is the opcode for \D, \d, \S, \s, \W, or \w, which will always be a
small value. Non-zero values in the table are the offsets from the opcode where
the character is to be found. ***NOTE*** If the start of this table is
modified, the three tables that follow must also be modified. */ //
/* End                                    */ //
/* \A, \G, \K, \B, \b                     */ //
/* \D, \d, \S, \s, \W, \w                 */ //
/* Any, AllAny, Anybyte                   */ //
/* \P, \p                                 */ //
/* \R, \H, \h, \V, \v                     */ //
/* \X                                     */ //
/* \Z, \z, $, $M, ^, ^M                   */ //
/* Char                                   */ //
/* Chari                                  */ //
/* not                                    */ //
/* noti                                   */ //
/* Positive single-char repeats                                          */ //
/* *, *?, +, +?, ?, ??                    */ //
/* upto, minupto                          */ //
/* exact                                  */ //
/* *+, ++, ?+, upto+                      */ //
/* *I, *?I, +I, +?I, ?I, ??I              */ //
/* upto I, minupto I                      */ //
/* exact I                                */ //
/* *+I, ++I, ?+I, upto+I                  */ //
/* Negative single-char repeats - only for chars < 256                   */ //
/* NOT *, *?, +, +?, ?, ??                */ //
/* NOT upto, minupto                      */ //
/* NOT exact                              */ //
/* NOT *+, ++, ?+, upto+                  */ //
/* NOT *I, *?I, +I, +?I, ?I, ??I          */ //
/* NOT upto I, minupto I                  */ //
/* NOT exact I                            */ //
/* NOT *+I, ++I, ?+I, upto+I              */ //
/* Positive type repeats                                                 */ //
/* Type *, *?, +, +?, ?, ??               */ //
/* Type upto, minupto                     */ //
/* Type exact                             */ //
/* Type *+, ++, ?+, upto+                 */ //
/* Character class & ref repeats                                         */ //
/* *, *?, +, +?, ?, ??                    */ //
/* CRRANGE, CRMINRANGE                    */ //
/* Possessive *+, ++, ?+, CRPOSRANGE      */ //
/* CLASS                                  */ //
/* NCLASS                                 */ //
/* XCLASS - variable length               */ //
/* REF                                    */ //
/* REFI                                   */ //
/* DNREF                                  */ //
/* DNREFI                                 */ //
/* RECURSE                                */ //
/* CALLOUT                                */ //
/* Alt                                    */ //
/* Ket                                    */ //
/* KetRmax                                */ //
/* KetRmin                                */ //
/* KetRpos                                */ //
/* Reverse                                */ //
/* Assert                                 */ //
/* Assert not                             */ //
/* Assert behind                          */ //
/* Assert behind not                      */ //
/* ONCE, ONCE_NC                          */ //
/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */ //
/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */ //
/* CREF, DNCREF                           */ //
/* RREF, DNRREF                           */ //
/* DEF                                    */ //
/* BRAZERO, BRAMINZERO, BRAPOSZERO        */ //
/* MARK, PRUNE, PRUNE_ARG                 */ //
/* SKIP, SKIP_ARG, THEN, THEN_ARG         */ //
/* COMMIT, FAIL, ACCEPT, ASSERT_ACCEPT    */ //
/* CLOSE, SKIPZERO  */ //
/* This table identifies those opcodes that inspect a character. It is used to
remember the fact that a character could have been inspected when the end of
the subject is reached. ***NOTE*** If the start of this table is modified, the
two tables that follow must also be modified. */ //
/* End                                    */ //
/* \A, \G, \K, \B, \b                     */ //
/* \D, \d, \S, \s, \W, \w                 */ //
/* Any, AllAny, Anybyte                   */ //
/* \P, \p                                 */ //
/* \R, \H, \h, \V, \v                     */ //
/* \X                                     */ //
/* \Z, \z, $, $M, ^, ^M                   */ //
/* Char                                   */ //
/* Chari                                  */ //
/* not                                    */ //
/* noti                                   */ //
/* Positive single-char repeats                                          */ //
/* *, *?, +, +?, ?, ??                    */ //
/* upto, minupto, exact                   */ //
/* *+, ++, ?+, upto+                      */ //
/* *I, *?I, +I, +?I, ?I, ??I              */ //
/* upto I, minupto I, exact I             */ //
/* *+I, ++I, ?+I, upto+I                  */ //
/* Negative single-char repeats - only for chars < 256                   */ //
/* NOT *, *?, +, +?, ?, ??                */ //
/* NOT upto, minupto, exact               */ //
/* NOT *+, ++, ?+, upto+                  */ //
/* NOT *I, *?I, +I, +?I, ?I, ??I          */ //
/* NOT upto I, minupto I, exact I         */ //
/* NOT *+I, ++I, ?+I, upto+I              */ //
/* Positive type repeats                                                 */ //
/* Type *, *?, +, +?, ?, ??               */ //
/* Type upto, minupto, exact              */ //
/* Type *+, ++, ?+, upto+                 */ //
/* Character class & ref repeats                                         */ //
/* *, *?, +, +?, ?, ??                    */ //
/* CRRANGE, CRMINRANGE                    */ //
/* Possessive *+, ++, ?+, CRPOSRANGE      */ //
/* CLASS                                  */ //
/* NCLASS                                 */ //
/* XCLASS - variable length               */ //
/* REF                                    */ //
/* REFI                                   */ //
/* DNREF                                  */ //
/* DNREFI                                 */ //
/* RECURSE                                */ //
/* CALLOUT                                */ //
/* Alt                                    */ //
/* Ket                                    */ //
/* KetRmax                                */ //
/* KetRmin                                */ //
/* KetRpos                                */ //
/* Reverse                                */ //
/* Assert                                 */ //
/* Assert not                             */ //
/* Assert behind                          */ //
/* Assert behind not                      */ //
/* ONCE, ONCE_NC                          */ //
/* BRA, BRAPOS, CBRA, CBRAPOS, COND       */ //
/* SBRA, SBRAPOS, SCBRA, SCBRAPOS, SCOND  */ //
/* CREF, DNCREF                           */ //
/* RREF, DNRREF                           */ //
/* DEF                                    */ //
/* BRAZERO, BRAMINZERO, BRAPOSZERO        */ //
/* MARK, PRUNE, PRUNE_ARG                 */ //
/* SKIP, SKIP_ARG, THEN, THEN_ARG         */ //
/* COMMIT, FAIL, ACCEPT, ASSERT_ACCEPT    */ //
/* CLOSE, SKIPZERO                        */ //
/* These 2 tables allow for compact code for testing for \D, \d, \S, \s, \W,
and \w */ //
/* OP_ANY, OP_ALLANY */ //
/* OP_ANY, OP_ALLANY */ //
/* Structure for holding data about a particular state, which is in effect the
current data for an active path through the match tree. It must consist
entirely of ints because the working vector we are passed, and which we put
these structures in, is a vector of ints. */ //
/* Offset to opcode */ //
/* Count for repeats */ //
/* Some use extra data */ //
/*************************************************
*    Execute a Regular Expression - DFA engine   *
*************************************************/ //
/* This internal function applies a compiled pattern to a subject string,
starting at a given point, using a DFA engine. This function is called from the
external one, possibly multiple times if the pattern is not anchored. The
function calls itself recursively for some kinds of subpattern.

Arguments:
  md                the match_data block with fixed information
  this_start_code   the opening bracket of this subexpression's code
  current_subject   where we currently are in the subject string
  start_offset      start offset in the subject string
  offsets           vector to contain the matching string offsets
  offsetcount       size of same
  workspace         vector of workspace
  wscount           size of same
  rlevel            function call recursion level

Returns:            > 0 => number of match offset pairs placed in offsets
                    = 0 => offsets overflowed; longest matches are present
                     -1 => failed to match
                   < -1 => some kind of unexpected problem

The following macros are used for adding states to the two state vectors (one
for the current character, one for the following character). */ //
/* And now, here is the code */ //
/* Some fields in the md block are frequently referenced, so we load them into
independent variables in the hope that this will perform better. */ //
/* A negative number */ //
/* The first thing in any (sub) pattern is a bracket of some sort. Push all
the alternative states onto the list, and find out where the end is. This
makes is possible to use this function recursively, when we want to stop at a
matching internal ket rather than at the end.

If the first opcode in the first alternative is OP_REVERSE, we are dealing with
a backward assertion. In that case, we have to find out the maximum amount to
move back, and set up each alternative appropriately. */ //
/* If we can't go back the amount required for the longest lookbehind
pattern, go back as far as we can; some alternatives may still be viable. */ //
/* In character mode we have to step back character by character */ //
/* In byte-mode we can do this quickly. */ //
/* Save the earliest consulted character */ //
/* Now we can process the individual branches. */ //
/* This is the code for a "normal" subpattern (not a backward assertion). The
start of a whole pattern is always one of these. If we are at the top level,
we may be asked to restart matching from the same point that we reached for a
previous partial match. We still have to scan through the top-level branches to
find the end state. */ //
/* Restarting */ //
/* Not restarting */ //
/* Bit indicating which vector is current */ //
/* Loop for scanning the subject */ //
/* Make the new state list into the active state list and empty the
new state list. */ //
/* Remember for the restarting feature */ //
/* Set the pointers for adding new states */ //
/* Load the current character from the subject outside the loop, as many
different states may want to look at it, and we assume that at least one
will. */ //
/* Number of data items in the character */ //
/* This indicates the end of the subject */ //
/* This value should never actually be used */ //
/* Scan up the active states and act on each one. The result of an action
may be to add more states to the currently active list (e.g. on hitting a
parenthesis) or it may be to put states on the new list, for considering
when we move the character pointer on. */ //
/* A negative offset is a special case meaning "hold off going to this
   (negated) state until the number of characters in the data field have
   been skipped". If the could_continue flag was passed over from a previous
   state, arrange for it to passed on. */ //
/* Check for a duplicate state with the same count, and skip if found.
   See the note at the head of this module about the possibility of improving
   performance here. */ //
/* The state offset is the offset to the opcode */ //
/* If this opcode inspects a character, but we are at the end of the
   subject, remember the fact for use when testing for a partial match. */ //
/* If this opcode is followed by an inline character, load it. It is
   tempting to test for the presence of a subject character here, but that
   is wrong, because sometimes zero repetitions of the subject are
   permitted.

   We also use this mechanism for opcodes such as OP_TYPEPLUS that take an
   argument that is not a data character - but is always one byte long because
   the values are small. We have to take special action to deal with  \P, \p,
   \H, \h, \V, \v and \X in this case. To keep the other cases fast, convert
   these ones to new opcodes. */ //
/* Not strictly necessary, but compilers moan */ //
/* if these variables are not set. */ //
/* Now process the individual opcodes */ //
/* ========================================================================== */ //
/* These cases are never obeyed. This is a fudge that causes a compile-
   time error if the vectors coptable or poptable, which are indexed by
   opcode, are not the correct length. It seems to be the only way to do
   such a check at compile time, as the sizeof() operator does not work
   in the C preprocessor. */ //
/* ========================================================================== */ //
/* Reached a closing bracket. If not at the end of the pattern, carry
   on with the next opcode. For repeating opcodes, also add the repeat
   state. Note that KETRPOS will always be encountered at the end of the
   subpattern, because the possessive subpattern repeats are always handled
   using recursive calls. Thus, it never adds any new states.

   At the end of the (sub)pattern, unless we have an empty string and
   PCRE_NOTEMPTY is set, or PCRE_NOTEMPTY_ATSTART is set and we are at the
   start of the subject, save the match data, shifting up all previous
   matches so we always have the longest first. */ //
/* ========================================================================== */ //
/* These opcodes add to the current list of states without looking
   at the current character. */ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/* ========================================================================== */ //
/* These opcodes inspect the next subject character, and sometimes
   the previous one as well, but do not have an argument. The variable
   clen contains the length of the current character and is zero if we are
   at the end of the subject. */ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/* Check the next character by Unicode property. We will get here only
   if the support is in the binary; otherwise a compile-time error occurs.
*/ //
/* These are specials for combination cases. */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Should never occur, but keep compilers from grumbling. */ //
/* ========================================================================== */ //
/* These opcodes likewise inspect the subject character, but have an
   argument that is not a data character. It is one of these opcodes:
   OP_ANY, OP_ALLANY, OP_DIGIT, OP_NOT_DIGIT, OP_WHITESPACE, OP_NOT_SPACE,
   OP_WORDCHAR, OP_NOT_WORDCHAR. The value is loaded into d. */ //
/* Already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* Remove non-match possibility */ //
/* ========================================================================== */ //
/* These are virtual opcodes that are used when something like
   OP_TYPEPLUS has OP_PROP, OP_NOTPROP, OP_ANYNL, or OP_EXTUNI as its
   argument. It keeps the code above fast for the other cases. The argument
   is in the d variable. */ //
/* Already matched */ //
/* These are specials for combination cases. */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Should never occur, but keep compilers from grumbling. */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Already matched */ //
/* Fall through */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* These are specials for combination cases. */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Should never occur, but keep compilers from grumbling. */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* These are specials for combination cases. */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Should never occur, but keep compilers from grumbling. */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* Fall through */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Number already matched */ //
/* Remove non-match possibility */ //
/* ========================================================================== */ //
/* These opcodes are followed by a character that is usually compared
   to the current subject character; it is loaded into d. We still get
   here even if there is no subject character, because in some cases zero
   repetitions are permitted. */ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/* If we have Unicode property support, we can use it to test the
   other case of the character. */ //
/* Not UTF mode */ //
/*-----------------------------------------------------------------*/ //
/* This is a tricky one because it can match more than one character.
   Find out how many characters to skip, and then set up a negative state
   to wait for them to pass before continuing. */ //
/*-----------------------------------------------------------------*/ //
/* This is a tricky like EXTUNI because it too can match more than one
   character (when CR is followed by LF). In this case, set up a negative
   state to wait for one character to pass before continuing. */ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/*-----------------------------------------------------------------*/ //
/* Match a negated single character casefully. */ //
/*-----------------------------------------------------------------*/ //
/* Match a negated single character caselessly. */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Already matched */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Remove non-match possibility */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Number already matched */ //
/*-----------------------------------------------------------------*/ //
/* Fall through */ //
/* Number already matched */ //
/* Remove non-match possibility */ //
/* ========================================================================== */ //
/* These are the class-handling opcodes */ //
/* For a simple class, there is always just a 32-byte table, and we
   can set isinclass from it. */ //
/* An extended class may have a table or a list of single characters,
   ranges, or both, and it may be positive or negative. There's a
   function that sorts all this out. */ //
/* At this point, isinclass is set for all kinds of class, and ecode
   points to the byte after the end of the class. If there is a
   quantifier, this is where it will be. */ //
/* Remove non-match possibility */ //
/* Already matched */ //
/* Remove non-match possibility */ //
/* Remove non-match possibility */ //
/* Already matched */ //
/* Remove non-match possibility */ //
/* Max 0 => no limit */ //
/* ========================================================================== */ //
/* These are the opcodes for fancy brackets of various kinds. We have
   to use recursion in order to handle them. The "always failing" assertion
   (?!) is optimised to OP_FAIL when compiling, so we have to support that,
   though the other "backtracking verbs" are not supported. */ //
/* Count FAILs for multiple states */ //
/* static match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recursion level */ //
/*-----------------------------------------------------------------*/ //
/* Because of the way auto-callout works during compile, a callout item
   is inserted between OP_COND and an assertion condition. This does not
   happen for the other conditions. */ //
/* Version 1 of the callout block */ //
/* No (*MARK) support */ //
/* Abandon */ //
/* Fail this thread */ //
/* Skip callout data */ //
/* Back reference conditions and duplicate named recursion conditions
   are not supported */ //
/* The DEFINE condition is always false, and the assertion (?!) is
   converted to OP_FAIL. */ //
/* The only supported version of OP_RREF is for the value RREF_ANY,
   which means "test if in any recursion". We can't test for specifically
   recursed groups. */ //
/* Otherwise, the condition is an assertion */ //
/* fixed match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recursion level */ //
/*-----------------------------------------------------------------*/ //
/* Check for repeating a recursion without advancing the subject
   pointer. This should catch convoluted mutual recursions. (Some simple
   cases are caught at compile time.) */ //
/* Remember this recursion and where we started it so as to
   catch infinite loops. */ //
/* fixed match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recursion level */ //
/* Done this recursion */ //
/* Ran out of internal offsets */ //
/* For each successful matched substring, set up the next state with a
   count of characters to skip before trying it. Note that the count is in
   characters, not bytes. */ //
/*-----------------------------------------------------------------*/ //
/* Codevalue will be one of above BRAs */ //
/* Loop to match the subpattern as many times as possible as if it were
   a complete pattern. */ //
/* fixed match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recursion level */ //
/* Failed to match */ //
/* Matched: break the loop if zero characters matched. */ //
/* Advance temporary position ptr */ //
/* At this point we have matched the subpattern matched_count
   times, and local_ptr is pointing to the character after the end of the
   last match. */ //
/* Optimization: if there are no more active states, and there
   are no new states yet set up, then skip over the subject string
   right here, to save looping. Otherwise, set up the new state to swing
   into action when the end of the matched substring is reached. */ //
/*-----------------------------------------------------------------*/ //
/* fixed match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recursion level */ //
/* If the end of this subpattern is KETRMAX or KETRMIN, we must
   arrange for the repeat state also to be added to the relevant list.
   Calculate the offset, or set -1 for no repeat. */ //
/* If we have matched an empty string, add the next state at the
   current character pointer. This is important so that the duplicate
   checking kicks in, which is what breaks infinite loops that match an
   empty string. */ //
/* Optimization: if there are no more active states, and there
   are no new states yet set up, then skip over the subject string
   right here, to save looping. Otherwise, set up the new state to swing
   into action when the end of the matched substring is reached. */ //
/* If we are adding a repeat state at the new character position,
   we must fudge things so that it is the only current state.
   Otherwise, it might be a duplicate of one we processed before, and
   that would cause it to be skipped. */ //
/* ========================================================================== */ //
/* Handle callouts */ //
/* Version 1 of the callout block */ //
/* No (*MARK) support */ //
/* Abandon */ //
/* ========================================================================== */ //
/* Unsupported opcode */ //
/* End of loop scanning active states */ //
/* We have finished the processing at the current subject character. If no
new states have been set for the next character, we have found all the
matches that we are going to find. If we are at the top level and partial
matching has been requested, check for appropriate conditions.

The "forced_ fail" variable counts the number of (*F) encountered for the
character. If it is equal to the original active_count (saved in
workspace[1]) it means that (*F) was found on every active state. In this
case we don't want to give a partial match.

The "could_continue" variable is true if a state could have continued but
for the fact that the end of the subject was reached. */ //
/* Top level, and */ //
/* Some could go on, and */ //
/* Not all forced fail & */ //
/* either... */ //
/* Hard partial */ //
/* or... */ //
/* Soft partial and */ //
/* no matches */ //
/* And... */ //
/* Either partial NL */ //
/* or ... */ //
/* End of subject and */ //
/* Inspected non-empty string */ //
/* In effect, "return", but see the comment below */ //
/* One or more states are active for the next character. */ //
/* Advance to next subject character */ //
/* Loop to move along the subject string */ //
/* Control gets here from "break" a few lines above. We do it this way because
if we use "return" above, we have compiler trouble. Some compilers warn if
there's nothing here because they think the function doesn't return a value. On
the other hand, if we put a dummy statement here, some more clever compilers
complain that it can't be reached. Sigh. */ //
//
func internal_dfa_exec(md *dfa_match_data, this_start_code *pcre_uchar, current_subject *pcre_uchar, start_offset int32, offsets *int32, offsetcount int32, workspace *int32, wscount int32, rlevel int32) int32 {
	var active_states *stateblock
	var new_states *stateblock
	var temp_states *stateblock
	var next_active_state *stateblock
	var next_new_state *stateblock
	var ctypes *pcre_uint8
	var lcc *pcre_uint8
	var fcc *pcre_uint8
	var ptr *pcre_uchar
	var end_code *pcre_uchar
	var first_op *pcre_uchar
	var new_recursive dfa_recursion_info
	var active_count int32
	var new_count int32
	var match_count int32
	var start_subject *pcre_uchar = (*md).start_subject
	var end_subject *pcre_uchar = (*md).end_subject
	var start_code *pcre_uchar = (*md).start_code
	var utf BOOL = BOOL((map[bool]int32{false: 0, true: 1}[(((*md).poptions & int32(2048)) != int32(0))]))
	var reset_could_continue BOOL = BOOL((int32(0)))
	rlevel += 1
	offsetcount &= -int32(2)
	wscount -= int32(2)
	wscount = ((wscount - (wscount % (int32((16 / 4)) * int32(2)))) / (int32(2) * int32((16 / 4))))
	ctypes = ((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := (*md).tables
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(512)+int32(320)))*unsafe.Sizeof(*tempVar))
	}()))
	lcc = ((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := (*md).tables
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(0))*unsafe.Sizeof(*tempVar))
	}()))
	fcc = ((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := (*md).tables
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(256))*unsafe.Sizeof(*tempVar))
	}()))
	match_count = -int32(1)
	active_states = (*stateblock)(unsafe.Pointer(((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(2))*unsafe.Sizeof(*workspace))))))
	new_states = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(active_states)) + (uintptr)(wscount)*unsafe.Sizeof(*active_states))))
	next_new_state = new_states
	new_count = int32(0)
	first_op = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(this_start_code)) + (uintptr)(int32(1))*unsafe.Sizeof(*this_start_code))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}()))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(func() int32 {
			if (map[bool]int32{false: 0, true: 1}[((((int32(uint8((*this_start_code))) == OP_CBRA) || (int32(uint8((*this_start_code))) == OP_SCBRA)) || (int32(uint8((*this_start_code))) == OP_CBRAPOS)) || (int32(uint8((*this_start_code))) == OP_SCBRAPOS))]) != 0 {
				return int32(2)
			} else {
				return int32(0)
			}
		}())*unsafe.Sizeof(*tempVar))
	}()))
	if int32(uint8((*first_op))) == OP_REVERSE {
		var max_back int32 = int32(0)
		var gone_back int32
		end_code = this_start_code
		for {
			var back int32 = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(end_code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(end_code)))))))))
			if back > max_back {
				max_back = back
			}
			end_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_code))))))))))*unsafe.Sizeof(*end_code))))
			if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_code))) == OP_ALT)])) != 0 {
				break
			}
		}
		if int32((BOOL(utf))) != 0 {
			for gone_back = int32(0); gone_back < max_back; gone_back++ {
				if int64(uintptr(unsafe.Pointer(current_subject))) <= int64(uintptr(unsafe.Pointer(start_subject))) {
					break
				}
				current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(1)*unsafe.Sizeof(*current_subject))))
				for (int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer(start_subject)))) && ((int32(uint8((*current_subject))) & int32(192)) == int32(128)) {
					current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(1)*unsafe.Sizeof(*current_subject))))
				}
			}
		} else {
			gone_back = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(max_back)*unsafe.Sizeof(*current_subject))))))) < int64(uintptr(unsafe.Pointer(start_subject))))]) != 0 {
					return (int32((int64(uintptr(unsafe.Pointer(current_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
				} else {
					return max_back
				}
			}()
			current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(gone_back)*unsafe.Sizeof(*current_subject))))
		}
		if int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) {
			(*md).start_used_ptr = current_subject
		}
		end_code = this_start_code
		for {
			var back int32 = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(end_code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(end_code)))))))))
			if back <= gone_back {
				var bstate int32 = (int32((((int64(uintptr(unsafe.Pointer(end_code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(2))) + int64((int32(2) * int32(2))))))
				if func() int32 {
					defer func() {
						new_count += 1
					}()
					return new_count
				}() < wscount {
					(*next_new_state).offset = -bstate
					(*next_new_state).count = int32(0)
					(*next_new_state).data = (gone_back - back)
					next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
				} else {
					return (-int32(19))
				}
			}
			end_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_code))))))))))*unsafe.Sizeof(*end_code))))
			if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_code))) == OP_ALT)])) != 0 {
				break
			}
		}
	} else {
		end_code = this_start_code
		if (rlevel == int32(1)) && (((*md).moptions & int32(131072)) != int32(0)) {
			for {
				end_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_code))))))))))*unsafe.Sizeof(*end_code))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_code))) == OP_ALT)])) != 0 {
					break
				}
			}
			new_count = *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(1))*unsafe.Sizeof(*workspace))))
			if noarch.NotInt32(*workspace) != 0 {
				noarch.Memcpy(unsafe.Pointer(new_states), unsafe.Pointer(active_states), int32((uint32(new_count) * 16)))
			}
		} else {
			var length int32 = ((int32(1) + int32(2)) + func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((((int32(uint8((*this_start_code))) == OP_CBRA) || (int32(uint8((*this_start_code))) == OP_SCBRA)) || (int32(uint8((*this_start_code))) == OP_CBRAPOS)) || (int32(uint8((*this_start_code))) == OP_SCBRAPOS))]) != 0 {
					return int32(2)
				} else {
					return int32(0)
				}
			}())
			for {
				if func() int32 {
					defer func() {
						new_count += 1
					}()
					return new_count
				}() < wscount {
					(*next_new_state).offset = (int32(((int64(uintptr(unsafe.Pointer(end_code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(length))))
					(*next_new_state).count = int32(0)
					next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
				} else {
					return (-int32(19))
				}
				end_code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_code))))))))))*unsafe.Sizeof(*end_code))))
				length = (int32(1) + int32(2))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_code))) == OP_ALT)])) != 0 {
					break
				}
			}
		}
	}
	*workspace = int32(0)
	ptr = current_subject
	for {
		var i int32
		var j int32
		var clen int32
		var dlen int32
		var c pcre_uint32
		var d pcre_uint32
		var forced_fail int32 = int32(0)
		var partial_newline BOOL = BOOL((int32(0)))
		var could_continue BOOL = reset_could_continue
		reset_could_continue = BOOL((int32(0)))
		temp_states = active_states
		active_states = new_states
		new_states = temp_states
		active_count = new_count
		new_count = int32(0)
		*workspace ^= int32(1)
		*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(1))*unsafe.Sizeof(*workspace)))) = active_count
		next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(active_states)) + (uintptr)(active_count)*unsafe.Sizeof(*active_states))))
		next_new_state = new_states
		if int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer(end_subject))) {
			clen = int32(1)
			c = pcre_uint32((uint32(uint8((*ptr)))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
					clen += 1
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
					clen += int32(2)
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
					clen += int32(3)
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
					clen += int32(4)
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
					clen += int32(5)
				}
			}
		} else {
			clen = int32(0)
			c = pcre_uint32((uint32(4294967295)))
		}
		for i = int32(0); i < active_count; i++ {
			var current_state *stateblock = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(active_states)) + (uintptr)(i)*unsafe.Sizeof(*active_states))))
			var caseless BOOL = BOOL((int32(0)))
			var code *pcre_uchar
			var state_offset int32 = (*current_state).offset
			var codevalue int32
			var rrc int32
			var count int32
			if state_offset < int32(0) {
				if (*current_state).data > int32(0) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = state_offset
						(*next_new_state).count = (*current_state).count
						(*next_new_state).data = ((*current_state).data - int32(1))
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
					if int32((BOOL(could_continue))) != 0 {
						reset_could_continue = BOOL((int32(1)))
					}
					continue
				} else {
					state_offset = -state_offset
					(*current_state).offset = state_offset
				}
			}
			for j = int32(0); j < i; j++ {
				if ((*((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(active_states)) + (uintptr)(j)*unsafe.Sizeof(*active_states))))).offset == state_offset) && ((*((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(active_states)) + (uintptr)(j)*unsafe.Sizeof(*active_states))))).count == (*current_state).count) {
					goto NEXT_ACTIVE_STATE
				}
			}
			code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_code)) + (uintptr)(state_offset)*unsafe.Sizeof(*start_code))))
			codevalue = int32(uint8((*code)))
			if (clen == int32(0)) && (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &poptable[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
			}()))))) != int32(0)) {
				could_continue = BOOL((int32(1)))
			}
			if int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &coptable[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
			}()))))) > int32(0) {
				dlen = int32(1)
				if int32((BOOL(utf))) != 0 {
					d = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((int32(0)+int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &coptable[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
					}())))))))))*unsafe.Sizeof(*code)))))))))
					if d >= pcre_uint32((uint32(int32(192)))) {
						if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63))))))
							dlen += 1
						} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63))))))
							dlen += int32(2)
						} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63))))))
							dlen += int32(3)
						} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(4))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63))))))
							dlen += int32(4)
						} else {
							d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(3))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(4))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &coptable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*code))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(5))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(63))))))
							dlen += int32(5)
						}
					}
				} else {
					d = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &coptable[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*code)))))))))
				}
				if codevalue >= OP_TYPESTAR {
					switch pcre_uint32(d) {
					case pcre_uint32(OP_ANYBYTE):
						{
							return (-int32(16))
						}
					case pcre_uint32(OP_NOTPROP):
						fallthrough
					case pcre_uint32(OP_PROP):
						{
							codevalue += int32(300)
						}
					case pcre_uint32(OP_ANYNL):
						{
							codevalue += int32(340)
						}
					case pcre_uint32(OP_EXTUNI):
						{
							codevalue += int32(320)
						}
					case pcre_uint32(OP_NOT_HSPACE):
						fallthrough
					case pcre_uint32(OP_HSPACE):
						{
							codevalue += int32(360)
						}
					case pcre_uint32(OP_NOT_VSPACE):
						fallthrough
					case pcre_uint32(OP_VSPACE):
						{
							codevalue += int32(380)
						}
					default:
						{
							break
						}
					}
				}
			} else {
				dlen = int32(0)
				d = pcre_uint32((uint32(4294967295)))
			}
			switch codevalue {
			case OP_TABLE_LENGTH:
				goto SW_GENERATED_LABEL_171
			case (OP_TABLE_LENGTH + map[bool]int32{false: 0, true: 1}[((162 == uint32(OP_TABLE_LENGTH)) && (162 == uint32(OP_TABLE_LENGTH)))]):
				goto SW_GENERATED_LABEL_172
			case OP_KET:
				goto SW_GENERATED_LABEL_173
			case OP_KETRMIN:
				goto SW_GENERATED_LABEL_174
			case OP_KETRMAX:
				goto SW_GENERATED_LABEL_175
			case OP_KETRPOS:
				goto SW_GENERATED_LABEL_176
			case OP_ALT:
				goto SW_GENERATED_LABEL_177
			case OP_BRA:
				goto SW_GENERATED_LABEL_178
			case OP_SBRA:
				goto SW_GENERATED_LABEL_179
			case OP_CBRA:
				goto SW_GENERATED_LABEL_180
			case OP_SCBRA:
				goto SW_GENERATED_LABEL_181
			case OP_BRAZERO:
				goto SW_GENERATED_LABEL_182
			case OP_BRAMINZERO:
				goto SW_GENERATED_LABEL_183
			case OP_SKIPZERO:
				goto SW_GENERATED_LABEL_184
			case OP_CIRC:
				goto SW_GENERATED_LABEL_185
			case OP_CIRCM:
				goto SW_GENERATED_LABEL_186
			case OP_EOD:
				goto SW_GENERATED_LABEL_187
			case OP_SOD:
				goto SW_GENERATED_LABEL_188
			case OP_SOM:
				goto SW_GENERATED_LABEL_189
			case OP_ANY:
				goto SW_GENERATED_LABEL_190
			case OP_ALLANY:
				goto SW_GENERATED_LABEL_191
			case OP_EODN:
				goto SW_GENERATED_LABEL_192
			case OP_DOLL:
				goto SW_GENERATED_LABEL_193
			case OP_DOLLM:
				goto SW_GENERATED_LABEL_194
			case OP_DIGIT:
				goto SW_GENERATED_LABEL_195
			case OP_WHITESPACE:
				goto SW_GENERATED_LABEL_196
			case OP_WORDCHAR:
				goto SW_GENERATED_LABEL_197
			case OP_NOT_DIGIT:
				goto SW_GENERATED_LABEL_198
			case OP_NOT_WHITESPACE:
				goto SW_GENERATED_LABEL_199
			case OP_NOT_WORDCHAR:
				goto SW_GENERATED_LABEL_200
			case OP_WORD_BOUNDARY:
				goto SW_GENERATED_LABEL_201
			case OP_NOT_WORD_BOUNDARY:
				goto SW_GENERATED_LABEL_202
			case OP_PROP:
				goto SW_GENERATED_LABEL_203
			case OP_NOTPROP:
				goto SW_GENERATED_LABEL_204
			case OP_TYPEPLUS:
				goto SW_GENERATED_LABEL_205
			case OP_TYPEMINPLUS:
				goto SW_GENERATED_LABEL_206
			case OP_TYPEPOSPLUS:
				goto SW_GENERATED_LABEL_207
			case OP_TYPEQUERY:
				goto SW_GENERATED_LABEL_208
			case OP_TYPEMINQUERY:
				goto SW_GENERATED_LABEL_209
			case OP_TYPEPOSQUERY:
				goto SW_GENERATED_LABEL_210
			case OP_TYPESTAR:
				goto SW_GENERATED_LABEL_211
			case OP_TYPEMINSTAR:
				goto SW_GENERATED_LABEL_212
			case OP_TYPEPOSSTAR:
				goto SW_GENERATED_LABEL_213
			case OP_TYPEEXACT:
				goto SW_GENERATED_LABEL_214
			case OP_TYPEUPTO:
				goto SW_GENERATED_LABEL_215
			case OP_TYPEMINUPTO:
				goto SW_GENERATED_LABEL_216
			case OP_TYPEPOSUPTO:
				goto SW_GENERATED_LABEL_217
			case (int32(300) + OP_TYPEPLUS):
				goto SW_GENERATED_LABEL_218
			case (int32(300) + OP_TYPEMINPLUS):
				goto SW_GENERATED_LABEL_219
			case (int32(300) + OP_TYPEPOSPLUS):
				goto SW_GENERATED_LABEL_220
			case (int32(320) + OP_TYPEPLUS):
				goto SW_GENERATED_LABEL_221
			case (int32(320) + OP_TYPEMINPLUS):
				goto SW_GENERATED_LABEL_222
			case (int32(320) + OP_TYPEPOSPLUS):
				goto SW_GENERATED_LABEL_223
			case (int32(340) + OP_TYPEPLUS):
				goto SW_GENERATED_LABEL_224
			case (int32(340) + OP_TYPEMINPLUS):
				goto SW_GENERATED_LABEL_225
			case (int32(340) + OP_TYPEPOSPLUS):
				goto SW_GENERATED_LABEL_226
			case (int32(380) + OP_TYPEPLUS):
				goto SW_GENERATED_LABEL_227
			case (int32(380) + OP_TYPEMINPLUS):
				goto SW_GENERATED_LABEL_228
			case (int32(380) + OP_TYPEPOSPLUS):
				goto SW_GENERATED_LABEL_229
			case (int32(360) + OP_TYPEPLUS):
				goto SW_GENERATED_LABEL_230
			case (int32(360) + OP_TYPEMINPLUS):
				goto SW_GENERATED_LABEL_231
			case (int32(360) + OP_TYPEPOSPLUS):
				goto SW_GENERATED_LABEL_232
			case (int32(300) + OP_TYPEQUERY):
				goto SW_GENERATED_LABEL_233
			case (int32(300) + OP_TYPEMINQUERY):
				goto SW_GENERATED_LABEL_234
			case (int32(300) + OP_TYPEPOSQUERY):
				goto SW_GENERATED_LABEL_235
			case (int32(300) + OP_TYPESTAR):
				goto SW_GENERATED_LABEL_236
			case (int32(300) + OP_TYPEMINSTAR):
				goto SW_GENERATED_LABEL_237
			case (int32(300) + OP_TYPEPOSSTAR):
				goto SW_GENERATED_LABEL_238
			case (int32(320) + OP_TYPEQUERY):
				goto SW_GENERATED_LABEL_239
			case (int32(320) + OP_TYPEMINQUERY):
				goto SW_GENERATED_LABEL_240
			case (int32(320) + OP_TYPEPOSQUERY):
				goto SW_GENERATED_LABEL_241
			case (int32(320) + OP_TYPESTAR):
				goto SW_GENERATED_LABEL_242
			case (int32(320) + OP_TYPEMINSTAR):
				goto SW_GENERATED_LABEL_243
			case (int32(320) + OP_TYPEPOSSTAR):
				goto SW_GENERATED_LABEL_244
			case (int32(340) + OP_TYPEQUERY):
				goto SW_GENERATED_LABEL_245
			case (int32(340) + OP_TYPEMINQUERY):
				goto SW_GENERATED_LABEL_246
			case (int32(340) + OP_TYPEPOSQUERY):
				goto SW_GENERATED_LABEL_247
			case (int32(340) + OP_TYPESTAR):
				goto SW_GENERATED_LABEL_248
			case (int32(340) + OP_TYPEMINSTAR):
				goto SW_GENERATED_LABEL_249
			case (int32(340) + OP_TYPEPOSSTAR):
				goto SW_GENERATED_LABEL_250
			case (int32(380) + OP_TYPEQUERY):
				goto SW_GENERATED_LABEL_251
			case (int32(380) + OP_TYPEMINQUERY):
				goto SW_GENERATED_LABEL_252
			case (int32(380) + OP_TYPEPOSQUERY):
				goto SW_GENERATED_LABEL_253
			case (int32(380) + OP_TYPESTAR):
				goto SW_GENERATED_LABEL_254
			case (int32(380) + OP_TYPEMINSTAR):
				goto SW_GENERATED_LABEL_255
			case (int32(380) + OP_TYPEPOSSTAR):
				goto SW_GENERATED_LABEL_256
			case (int32(360) + OP_TYPEQUERY):
				goto SW_GENERATED_LABEL_257
			case (int32(360) + OP_TYPEMINQUERY):
				goto SW_GENERATED_LABEL_258
			case (int32(360) + OP_TYPEPOSQUERY):
				goto SW_GENERATED_LABEL_259
			case (int32(360) + OP_TYPESTAR):
				goto SW_GENERATED_LABEL_260
			case (int32(360) + OP_TYPEMINSTAR):
				goto SW_GENERATED_LABEL_261
			case (int32(360) + OP_TYPEPOSSTAR):
				goto SW_GENERATED_LABEL_262
			case (int32(300) + OP_TYPEEXACT):
				goto SW_GENERATED_LABEL_263
			case (int32(300) + OP_TYPEUPTO):
				goto SW_GENERATED_LABEL_264
			case (int32(300) + OP_TYPEMINUPTO):
				goto SW_GENERATED_LABEL_265
			case (int32(300) + OP_TYPEPOSUPTO):
				goto SW_GENERATED_LABEL_266
			case (int32(320) + OP_TYPEEXACT):
				goto SW_GENERATED_LABEL_267
			case (int32(320) + OP_TYPEUPTO):
				goto SW_GENERATED_LABEL_268
			case (int32(320) + OP_TYPEMINUPTO):
				goto SW_GENERATED_LABEL_269
			case (int32(320) + OP_TYPEPOSUPTO):
				goto SW_GENERATED_LABEL_270
			case (int32(340) + OP_TYPEEXACT):
				goto SW_GENERATED_LABEL_271
			case (int32(340) + OP_TYPEUPTO):
				goto SW_GENERATED_LABEL_272
			case (int32(340) + OP_TYPEMINUPTO):
				goto SW_GENERATED_LABEL_273
			case (int32(340) + OP_TYPEPOSUPTO):
				goto SW_GENERATED_LABEL_274
			case (int32(380) + OP_TYPEEXACT):
				goto SW_GENERATED_LABEL_275
			case (int32(380) + OP_TYPEUPTO):
				goto SW_GENERATED_LABEL_276
			case (int32(380) + OP_TYPEMINUPTO):
				goto SW_GENERATED_LABEL_277
			case (int32(380) + OP_TYPEPOSUPTO):
				goto SW_GENERATED_LABEL_278
			case (int32(360) + OP_TYPEEXACT):
				goto SW_GENERATED_LABEL_279
			case (int32(360) + OP_TYPEUPTO):
				goto SW_GENERATED_LABEL_280
			case (int32(360) + OP_TYPEMINUPTO):
				goto SW_GENERATED_LABEL_281
			case (int32(360) + OP_TYPEPOSUPTO):
				goto SW_GENERATED_LABEL_282
			case OP_CHAR:
				goto SW_GENERATED_LABEL_283
			case OP_CHARI:
				goto SW_GENERATED_LABEL_284
			case OP_EXTUNI:
				goto SW_GENERATED_LABEL_285
			case OP_ANYNL:
				goto SW_GENERATED_LABEL_286
			case OP_NOT_VSPACE:
				goto SW_GENERATED_LABEL_287
			case OP_VSPACE:
				goto SW_GENERATED_LABEL_288
			case OP_NOT_HSPACE:
				goto SW_GENERATED_LABEL_289
			case OP_HSPACE:
				goto SW_GENERATED_LABEL_290
			case OP_NOT:
				goto SW_GENERATED_LABEL_291
			case OP_NOTI:
				goto SW_GENERATED_LABEL_292
			case OP_PLUSI:
				goto SW_GENERATED_LABEL_293
			case OP_MINPLUSI:
				goto SW_GENERATED_LABEL_294
			case OP_POSPLUSI:
				goto SW_GENERATED_LABEL_295
			case OP_NOTPLUSI:
				goto SW_GENERATED_LABEL_296
			case OP_NOTMINPLUSI:
				goto SW_GENERATED_LABEL_297
			case OP_NOTPOSPLUSI:
				goto SW_GENERATED_LABEL_298
			case OP_PLUS:
				goto SW_GENERATED_LABEL_299
			case OP_MINPLUS:
				goto SW_GENERATED_LABEL_300
			case OP_POSPLUS:
				goto SW_GENERATED_LABEL_301
			case OP_NOTPLUS:
				goto SW_GENERATED_LABEL_302
			case OP_NOTMINPLUS:
				goto SW_GENERATED_LABEL_303
			case OP_NOTPOSPLUS:
				goto SW_GENERATED_LABEL_304
			case OP_QUERYI:
				goto SW_GENERATED_LABEL_305
			case OP_MINQUERYI:
				goto SW_GENERATED_LABEL_306
			case OP_POSQUERYI:
				goto SW_GENERATED_LABEL_307
			case OP_NOTQUERYI:
				goto SW_GENERATED_LABEL_308
			case OP_NOTMINQUERYI:
				goto SW_GENERATED_LABEL_309
			case OP_NOTPOSQUERYI:
				goto SW_GENERATED_LABEL_310
			case OP_QUERY:
				goto SW_GENERATED_LABEL_311
			case OP_MINQUERY:
				goto SW_GENERATED_LABEL_312
			case OP_POSQUERY:
				goto SW_GENERATED_LABEL_313
			case OP_NOTQUERY:
				goto SW_GENERATED_LABEL_314
			case OP_NOTMINQUERY:
				goto SW_GENERATED_LABEL_315
			case OP_NOTPOSQUERY:
				goto SW_GENERATED_LABEL_316
			case OP_STARI:
				goto SW_GENERATED_LABEL_317
			case OP_MINSTARI:
				goto SW_GENERATED_LABEL_318
			case OP_POSSTARI:
				goto SW_GENERATED_LABEL_319
			case OP_NOTSTARI:
				goto SW_GENERATED_LABEL_320
			case OP_NOTMINSTARI:
				goto SW_GENERATED_LABEL_321
			case OP_NOTPOSSTARI:
				goto SW_GENERATED_LABEL_322
			case OP_STAR:
				goto SW_GENERATED_LABEL_323
			case OP_MINSTAR:
				goto SW_GENERATED_LABEL_324
			case OP_POSSTAR:
				goto SW_GENERATED_LABEL_325
			case OP_NOTSTAR:
				goto SW_GENERATED_LABEL_326
			case OP_NOTMINSTAR:
				goto SW_GENERATED_LABEL_327
			case OP_NOTPOSSTAR:
				goto SW_GENERATED_LABEL_328
			case OP_EXACTI:
				goto SW_GENERATED_LABEL_329
			case OP_NOTEXACTI:
				goto SW_GENERATED_LABEL_330
			case OP_EXACT:
				goto SW_GENERATED_LABEL_331
			case OP_NOTEXACT:
				goto SW_GENERATED_LABEL_332
			case OP_UPTOI:
				goto SW_GENERATED_LABEL_333
			case OP_MINUPTOI:
				goto SW_GENERATED_LABEL_334
			case OP_POSUPTOI:
				goto SW_GENERATED_LABEL_335
			case OP_NOTUPTOI:
				goto SW_GENERATED_LABEL_336
			case OP_NOTMINUPTOI:
				goto SW_GENERATED_LABEL_337
			case OP_NOTPOSUPTOI:
				goto SW_GENERATED_LABEL_338
			case OP_UPTO:
				goto SW_GENERATED_LABEL_339
			case OP_MINUPTO:
				goto SW_GENERATED_LABEL_340
			case OP_POSUPTO:
				goto SW_GENERATED_LABEL_341
			case OP_NOTUPTO:
				goto SW_GENERATED_LABEL_342
			case OP_NOTMINUPTO:
				goto SW_GENERATED_LABEL_343
			case OP_NOTPOSUPTO:
				goto SW_GENERATED_LABEL_344
			case OP_CLASS:
				goto SW_GENERATED_LABEL_345
			case OP_NCLASS:
				goto SW_GENERATED_LABEL_346
			case OP_XCLASS:
				goto SW_GENERATED_LABEL_347
			case OP_FAIL:
				goto SW_GENERATED_LABEL_348
			case OP_ASSERT:
				goto SW_GENERATED_LABEL_349
			case OP_ASSERT_NOT:
				goto SW_GENERATED_LABEL_350
			case OP_ASSERTBACK:
				goto SW_GENERATED_LABEL_351
			case OP_ASSERTBACK_NOT:
				goto SW_GENERATED_LABEL_352
			case OP_COND:
				goto SW_GENERATED_LABEL_353
			case OP_SCOND:
				goto SW_GENERATED_LABEL_354
			case OP_RECURSE:
				goto SW_GENERATED_LABEL_355
			case OP_BRAPOS:
				goto SW_GENERATED_LABEL_356
			case OP_SBRAPOS:
				goto SW_GENERATED_LABEL_357
			case OP_CBRAPOS:
				goto SW_GENERATED_LABEL_358
			case OP_SCBRAPOS:
				goto SW_GENERATED_LABEL_359
			case OP_BRAPOSZERO:
				goto SW_GENERATED_LABEL_360
			case OP_ONCE:
				goto SW_GENERATED_LABEL_361
			case OP_ONCE_NC:
				goto SW_GENERATED_LABEL_362
			case OP_CALLOUT:
				goto SW_GENERATED_LABEL_363
			default:
				goto SW_GENERATED_LABEL_364
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_171:
			;
		SW_GENERATED_LABEL_172:
			{
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_173:
			;
		SW_GENERATED_LABEL_174:
			;
		SW_GENERATED_LABEL_175:
			;
		SW_GENERATED_LABEL_176:
			{
				if int64(uintptr(unsafe.Pointer(code))) != int64(uintptr(unsafe.Pointer(end_code))) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + int32(1)) + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
					if codevalue != OP_KET {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (state_offset - ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					}
				} else {
					if (int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer(current_subject)))) || ((((*md).moptions & int32(1024)) == int32(0)) && ((((*md).moptions & int32(268435456)) == int32(0)) || (int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)((*md).start_offset)*unsafe.Sizeof(*start_subject)))))))))) {
						if match_count < int32(0) {
							match_count = func() int32 {
								if (map[bool]int32{false: 0, true: 1}[(offsetcount >= int32(2))]) != 0 {
									return int32(1)
								} else {
									return int32(0)
								}
							}()
						} else if (match_count > int32(0)) && ((func() int32 {
							match_count += 1
							return match_count
						}() * int32(2)) > offsetcount) {
							match_count = int32(0)
						}
						count = (func() int32 {
							if (map[bool]int32{false: 0, true: 1}[(match_count == int32(0))]) != 0 {
								return offsetcount
							} else {
								return (match_count * int32(2))
							}
						}() - int32(2))
						if count > int32(0) {
							noarch.Memcpy(unsafe.Pointer(((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(2))*unsafe.Sizeof(*offsets))))), unsafe.Pointer(offsets), int32((uint32(count) * 4)))
						}
						if offsetcount >= int32(2) {
							*offsets = (int32((int64(uintptr(unsafe.Pointer(current_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
							*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject))))))
						}
						if ((*md).moptions & int32(65536)) != int32(0) {
							return match_count
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_177:
			{
				for {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
						break
					}
				}
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (int32((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code))))))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_178:
			;
		SW_GENERATED_LABEL_179:
			{
				for {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (int32((((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(1))) + int64(int32(2)))))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
						break
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_180:
			;
		SW_GENERATED_LABEL_181:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (int32(((((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(1))) + int64(int32(2))) + int64(int32(2)))))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				for int32(uint8((*code))) == OP_ALT {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (int32((((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(1))) + int64(int32(2)))))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_182:
			;
		SW_GENERATED_LABEL_183:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(1))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(2))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(code)))))))))))*unsafe.Sizeof(*code))))
				for int32(uint8((*code))) == OP_ALT {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				}
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (int32((((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(1))) + int64(int32(2)))))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_184:
			{
				code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(1)+((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(2))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(code)))))))))))*unsafe.Sizeof(*code))))
				for int32(uint8((*code))) == OP_ALT {
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				}
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (int32((((int64(uintptr(unsafe.Pointer(code))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(1))) + int64(int32(2)))))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_185:
			{
				if (int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(start_subject)))) && (((*md).moptions & int32(128)) == int32(0)) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_186:
			{
				if ((int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(start_subject)))) && (((*md).moptions & int32(128)) == int32(0))) || ((int64(uintptr(unsafe.Pointer(ptr))) != int64(uintptr(unsafe.Pointer(end_subject)))) && (func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((ptr), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).start_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(int32(uint8(((*md).nllen))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(int32(uint8((((*md).nllen)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}() != 0)) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_187:
			{
				if int64(uintptr(unsafe.Pointer(ptr))) >= int64(uintptr(unsafe.Pointer(end_subject))) {
					if ((*md).moptions & int32(134217728)) != int32(0) {
						could_continue = BOOL((int32(1)))
					} else {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (state_offset + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_188:
			{
				if int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(start_subject))) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_189:
			{
				if int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)(start_offset)*unsafe.Sizeof(*start_subject))))))) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_190:
			{
				if (clen > int32(0)) && (noarch.NotInt32((func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}())) != 0) {
					if ((((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = (state_offset + int32(1))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_191:
			{
				if clen > int32(0) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = (state_offset + int32(1))
						(*next_new_state).count = int32(0)
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_192:
			{
				if (clen == int32(0)) && (((*md).moptions & int32(134217728)) != int32(0)) {
					could_continue = BOOL((int32(1)))
				} else if (clen == int32(0)) || ((func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}() != 0) && (int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_subject)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*end_subject))))))))) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_193:
			{
				if ((*md).moptions & int32(256)) == int32(0) {
					if (clen == int32(0)) && (((*md).moptions & int32(134217728)) != int32(0)) {
						could_continue = BOOL((int32(1)))
					} else if (clen == int32(0)) || (((((*md).poptions & int32(32)) == int32(0)) && (func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}() != 0)) && (int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_subject)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*end_subject))))))))) {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (state_offset + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					} else if ((((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (((*md).moptions & (int32(134217728) | int32(32768))) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						if ((*md).moptions & int32(134217728)) != int32(0) {
							reset_could_continue = BOOL((int32(1)))
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -(state_offset + int32(1))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = int32(1)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							partial_newline = BOOL((int32(1)))
							could_continue = partial_newline
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_194:
			{
				if ((*md).moptions & int32(256)) == int32(0) {
					if (clen == int32(0)) && (((*md).moptions & int32(134217728)) != int32(0)) {
						could_continue = BOOL((int32(1)))
					} else if (clen == int32(0)) || ((((*md).poptions & int32(32)) == int32(0)) && (func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}() != 0)) {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (state_offset + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					} else if ((((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (((*md).moptions & (int32(134217728) | int32(32768))) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						if ((*md).moptions & int32(134217728)) != int32(0) {
							reset_could_continue = BOOL((int32(1)))
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -(state_offset + int32(1))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = int32(1)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							partial_newline = BOOL((int32(1)))
							could_continue = partial_newline
						}
					}
				} else if (func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}()) != 0 {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_195:
			;
		SW_GENERATED_LABEL_196:
			;
		SW_GENERATED_LABEL_197:
			{
				if ((clen > int32(0)) && (c < pcre_uint32((uint32(int32(256)))))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &toptable1[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
				}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &toptable2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
				}())))))) != int32(0)) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = (state_offset + int32(1))
						(*next_new_state).count = int32(0)
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_198:
			;
		SW_GENERATED_LABEL_199:
			;
		SW_GENERATED_LABEL_200:
			{
				if (clen > int32(0)) && ((c >= pcre_uint32((uint32(int32(256))))) || (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &toptable1[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
				}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &toptable2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codevalue)*unsafe.Sizeof(*tempVar))
				}())))))) != int32(0))) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = (state_offset + int32(1))
						(*next_new_state).count = int32(0)
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_201:
			;
		SW_GENERATED_LABEL_202:
			{
				var left_word int32
				var right_word int32
				if int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer(start_subject))) {
					var temp *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))
					if int64(uintptr(unsafe.Pointer(temp))) < int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) {
						(*md).start_used_ptr = temp
					}
					if int32((BOOL(utf))) != 0 {
						for (int32(uint8((*temp))) & int32(192)) == int32(128) {
							temp = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) - (uintptr)(1)*unsafe.Sizeof(*temp))))
						}
					}
					d = pcre_uint32((uint32(uint8((*temp)))))
					if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(192))))) {
						if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(1))*unsafe.Sizeof(*temp))))))) & int32(63))))))
						} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(1))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(2))*unsafe.Sizeof(*temp))))))) & int32(63))))))
						} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(1))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(2))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(3))*unsafe.Sizeof(*temp))))))) & int32(63))))))
						} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(1))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(2))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(3))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(4))*unsafe.Sizeof(*temp))))))) & int32(63))))))
						} else {
							d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(1))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(2))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(3))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(4))*unsafe.Sizeof(*temp))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + (uintptr)(int32(5))*unsafe.Sizeof(*temp))))))) & int32(63))))))
						}
					}
					if ((*md).poptions & int32(536870912)) != int32(0) {
						if d == pcre_uint32((uint32('_'))) {
							left_word = int32(1)
						} else {
							var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							left_word = map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]
						}
					} else {
						left_word = map[bool]int32{false: 0, true: 1}[((d < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*ctypes))))))) & int32(16)) != int32(0)))]
					}
				} else {
					left_word = int32(0)
				}
				if clen > int32(0) {
					if ((*md).poptions & int32(536870912)) != int32(0) {
						if c == pcre_uint32((uint32('_'))) {
							right_word = int32(1)
						} else {
							var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							right_word = map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]
						}
					} else {
						right_word = map[bool]int32{false: 0, true: 1}[((c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(16)) != int32(0)))]
					}
				} else {
					right_word = int32(0)
				}
				if (left_word == right_word) == (codevalue == OP_NOT_WORD_BOUNDARY) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_203:
			;
		SW_GENERATED_LABEL_204:
			{
				if clen > int32(0) {
					var OK BOOL
					var cp *pcre_uint32
					var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))) {
					case int32(0):
						{
							OK = BOOL((int32(1)))
						}
					case int32(1):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt))]))
						}
					case int32(2):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))))))]))
						}
					case int32(3):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).chartype)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(4):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).script)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(5):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N)))))]))
						}
					case int32(6):
						fallthrough
					case int32(7):
						{
							switch pcre_uint32(c) {
							case pcre_uint32('\t'):
								fallthrough
							case pcre_uint32(' '):
								fallthrough
							case pcre_uint32((uint8('\u00a0'))):
								fallthrough
							case pcre_uint32(int32(5760)):
								fallthrough
							case pcre_uint32(int32(6158)):
								fallthrough
							case pcre_uint32(int32(8192)):
								fallthrough
							case pcre_uint32(int32(8193)):
								fallthrough
							case pcre_uint32(int32(8194)):
								fallthrough
							case pcre_uint32(int32(8195)):
								fallthrough
							case pcre_uint32(int32(8196)):
								fallthrough
							case pcre_uint32(int32(8197)):
								fallthrough
							case pcre_uint32(int32(8198)):
								fallthrough
							case pcre_uint32(int32(8199)):
								fallthrough
							case pcre_uint32(int32(8200)):
								fallthrough
							case pcre_uint32(int32(8201)):
								fallthrough
							case pcre_uint32(int32(8202)):
								fallthrough
							case pcre_uint32(int32(8239)):
								fallthrough
							case pcre_uint32(int32(8287)):
								fallthrough
							case pcre_uint32(int32(12288)):
								fallthrough
							case pcre_uint32('\n'):
								fallthrough
							case pcre_uint32('\v'):
								fallthrough
							case pcre_uint32('\f'):
								fallthrough
							case pcre_uint32('\r'):
								fallthrough
							case pcre_uint32((uint8('\u0085'))):
								fallthrough
							case pcre_uint32(int32(8232)):
								fallthrough
							case pcre_uint32(int32(8233)):
								{
									OK = BOOL((int32(1)))
								}
							default:
								{
									OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
										tempVar := &_pcre_ucp_gentype[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
									}())) == pcre_uint32((uint32(ucp_Z))))]))
									break
								}
							}
						}
					case int32(8):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_')))))]))
						}
					case int32(9):
						{
							cp = ((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_caseless_sets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*tempVar))
							}()))
							for {
								if c < *cp {
									OK = BOOL((int32(0)))
									break
								}
								if c == *func() *pcre_uint32 {
									defer func() {
										cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
									}()
									return cp
								}() {
									OK = BOOL((int32(1)))
									break
								}
							}
						}
					case int32(10):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344))))))]))
						}
					default:
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(codevalue != OP_PROP)]))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(codevalue == OP_PROP)])) {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = (state_offset + int32(3))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_205:
			;
		SW_GENERATED_LABEL_206:
			;
		SW_GENERATED_LABEL_207:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					if (((((d == pcre_uint32((uint32(OP_ANY)))) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else if ((((c >= pcre_uint32((uint32(int32(256))))) && (d != pcre_uint32((uint32(OP_DIGIT))))) && (d != pcre_uint32((uint32(OP_WHITESPACE))))) && (d != pcre_uint32((uint32(OP_WORDCHAR))))) || (((c < pcre_uint32((uint32(int32(256))))) && ((d != pcre_uint32((uint32(OP_ANY)))) || (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) != int32(0))) {
						if (count > int32(0)) && (codevalue == OP_TYPEPOSPLUS) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = state_offset
							(*next_new_state).count = count
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_208:
			;
		SW_GENERATED_LABEL_209:
			;
		SW_GENERATED_LABEL_210:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					if (((((d == pcre_uint32((uint32(OP_ANY)))) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else if ((((c >= pcre_uint32((uint32(int32(256))))) && (d != pcre_uint32((uint32(OP_DIGIT))))) && (d != pcre_uint32((uint32(OP_WHITESPACE))))) && (d != pcre_uint32((uint32(OP_WORDCHAR))))) || (((c < pcre_uint32((uint32(int32(256))))) && ((d != pcre_uint32((uint32(OP_ANY)))) || (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) != int32(0))) {
						if codevalue == OP_TYPEPOSQUERY {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = (state_offset + int32(2))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_211:
			;
		SW_GENERATED_LABEL_212:
			;
		SW_GENERATED_LABEL_213:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					if (((((d == pcre_uint32((uint32(OP_ANY)))) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else if ((((c >= pcre_uint32((uint32(int32(256))))) && (d != pcre_uint32((uint32(OP_DIGIT))))) && (d != pcre_uint32((uint32(OP_WHITESPACE))))) && (d != pcre_uint32((uint32(OP_WORDCHAR))))) || (((c < pcre_uint32((uint32(int32(256))))) && ((d != pcre_uint32((uint32(OP_ANY)))) || (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) != int32(0))) {
						if codevalue == OP_TYPEPOSSTAR {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = state_offset
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_214:
			{
				count = (*current_state).count
				if clen > int32(0) {
					if (((((d == pcre_uint32((uint32(OP_ANY)))) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else if ((((c >= pcre_uint32((uint32(int32(256))))) && (d != pcre_uint32((uint32(OP_DIGIT))))) && (d != pcre_uint32((uint32(OP_WHITESPACE))))) && (d != pcre_uint32((uint32(OP_WORDCHAR))))) || (((c < pcre_uint32((uint32(int32(256))))) && ((d != pcre_uint32((uint32(OP_ANY)))) || (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) != int32(0))) {
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (((state_offset + int32(1)) + int32(2)) + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_215:
			;
		SW_GENERATED_LABEL_216:
			;
		SW_GENERATED_LABEL_217:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = ((state_offset + int32(2)) + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				count = (*current_state).count
				if clen > int32(0) {
					if (((((d == pcre_uint32((uint32(OP_ANY)))) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (((*md).moptions & int32(134217728)) != int32(0))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
						partial_newline = BOOL((int32(1)))
						could_continue = partial_newline
					} else if ((((c >= pcre_uint32((uint32(int32(256))))) && (d != pcre_uint32((uint32(OP_DIGIT))))) && (d != pcre_uint32((uint32(OP_WHITESPACE))))) && (d != pcre_uint32((uint32(OP_WORDCHAR))))) || (((c < pcre_uint32((uint32(int32(256))))) && ((d != pcre_uint32((uint32(OP_ANY)))) || (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((ptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(ptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*ptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0))) && (((int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ctypes)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*ctypes))))))) & int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) ^ int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &toptable2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*tempVar))
					}())))))) != int32(0))) {
						if codevalue == OP_TYPEPOSUPTO {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = ((state_offset + int32(2)) + int32(2))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_218:
			;
		SW_GENERATED_LABEL_219:
			;
		SW_GENERATED_LABEL_220:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(4))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var OK BOOL
					var cp *pcre_uint32
					var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code)))))))) {
					case int32(0):
						{
							OK = BOOL((int32(1)))
						}
					case int32(1):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt))]))
						}
					case int32(2):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))))]))
						}
					case int32(3):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).chartype)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(4):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).script)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(5):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N)))))]))
						}
					case int32(6):
						fallthrough
					case int32(7):
						{
							switch pcre_uint32(c) {
							case pcre_uint32('\t'):
								fallthrough
							case pcre_uint32(' '):
								fallthrough
							case pcre_uint32((uint8('\u00a0'))):
								fallthrough
							case pcre_uint32(int32(5760)):
								fallthrough
							case pcre_uint32(int32(6158)):
								fallthrough
							case pcre_uint32(int32(8192)):
								fallthrough
							case pcre_uint32(int32(8193)):
								fallthrough
							case pcre_uint32(int32(8194)):
								fallthrough
							case pcre_uint32(int32(8195)):
								fallthrough
							case pcre_uint32(int32(8196)):
								fallthrough
							case pcre_uint32(int32(8197)):
								fallthrough
							case pcre_uint32(int32(8198)):
								fallthrough
							case pcre_uint32(int32(8199)):
								fallthrough
							case pcre_uint32(int32(8200)):
								fallthrough
							case pcre_uint32(int32(8201)):
								fallthrough
							case pcre_uint32(int32(8202)):
								fallthrough
							case pcre_uint32(int32(8239)):
								fallthrough
							case pcre_uint32(int32(8287)):
								fallthrough
							case pcre_uint32(int32(12288)):
								fallthrough
							case pcre_uint32('\n'):
								fallthrough
							case pcre_uint32('\v'):
								fallthrough
							case pcre_uint32('\f'):
								fallthrough
							case pcre_uint32('\r'):
								fallthrough
							case pcre_uint32((uint8('\u0085'))):
								fallthrough
							case pcre_uint32(int32(8232)):
								fallthrough
							case pcre_uint32(int32(8233)):
								{
									OK = BOOL((int32(1)))
								}
							default:
								{
									OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
										tempVar := &_pcre_ucp_gentype[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
									}())) == pcre_uint32((uint32(ucp_Z))))]))
									break
								}
							}
						}
					case int32(8):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_')))))]))
						}
					case int32(9):
						{
							cp = ((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_caseless_sets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*tempVar))
							}()))
							for {
								if c < *cp {
									OK = BOOL((int32(0)))
									break
								}
								if c == *func() *pcre_uint32 {
									defer func() {
										cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
									}()
									return cp
								}() {
									OK = BOOL((int32(1)))
									break
								}
							}
						}
					case int32(10):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344))))))]))
						}
					default:
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(codevalue != OP_PROP)]))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_PROP))))])) {
						if (count > int32(0)) && (codevalue == (int32(300) + OP_TYPEPOSPLUS)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = state_offset
							(*next_new_state).count = count
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_221:
			;
		SW_GENERATED_LABEL_222:
			;
		SW_GENERATED_LABEL_223:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var lgb int32
					var rgb int32
					var nptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(clen)*unsafe.Sizeof(*ptr))))
					var ncount int32 = int32(0)
					if (count > int32(0)) && (codevalue == (int32(320) + OP_TYPEPOSPLUS)) {
						active_count -= 1
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					}
					lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).gbprop))))
					for int64(uintptr(unsafe.Pointer(nptr))) < int64(uintptr(unsafe.Pointer(end_subject))) {
						dlen = int32(1)
						if int32((NotBOOL(BOOL(utf)))) != 0 {
							d = pcre_uint32((uint32(uint8((*nptr)))))
						} else {
							d = pcre_uint32((uint32(uint8((*nptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(5)
								}
							}
						}
						rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).gbprop))))
						if (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gbtable[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
						}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
							break
						}
						ncount += 1
						lgb = rgb
						nptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(dlen)*unsafe.Sizeof(*nptr))))
					}
					count += 1
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = -state_offset
						(*next_new_state).count = count
						(*next_new_state).data = ncount
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_224:
			;
		SW_GENERATED_LABEL_225:
			;
		SW_GENERATED_LABEL_226:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var ncount int32 = int32(0)
					switch pcre_uint32(c) {
					case pcre_uint32('\v'):
						goto SW_GENERATED_LABEL_144
					case pcre_uint32('\f'):
						goto SW_GENERATED_LABEL_145
					case pcre_uint32((uint8('\u0085'))):
						goto SW_GENERATED_LABEL_146
					case pcre_uint32(int32(8232)):
						goto SW_GENERATED_LABEL_147
					case pcre_uint32(int32(8233)):
						goto SW_GENERATED_LABEL_148
					case pcre_uint32('\r'):
						goto SW_GENERATED_LABEL_149
					case pcre_uint32('\n'):
						goto SW_GENERATED_LABEL_150
					default:
						goto SW_GENERATED_LABEL_151
					}
					goto SW_GENERATED_LABEL_143
				SW_GENERATED_LABEL_144:
					;
				SW_GENERATED_LABEL_145:
					;
				SW_GENERATED_LABEL_146:
					;
				SW_GENERATED_LABEL_147:
					;
				SW_GENERATED_LABEL_148:
					{
						if ((*md).moptions & int32(8388608)) != int32(0) {
							goto SW_GENERATED_LABEL_143
						}
						goto ANYNL01
					}
				SW_GENERATED_LABEL_149:
					{
						if (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32('\n')) {
							ncount = int32(1)
						}
					}
				ANYNL01:
					{
					}
				SW_GENERATED_LABEL_150:
					{
						if (count > int32(0)) && (codevalue == (int32(340) + OP_TYPEPOSPLUS)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -state_offset
							(*next_new_state).count = count
							(*next_new_state).data = ncount
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
					goto SW_GENERATED_LABEL_143
				SW_GENERATED_LABEL_151:
					{
						goto SW_GENERATED_LABEL_143
					}
				SW_GENERATED_LABEL_143:
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_227:
			;
		SW_GENERATED_LABEL_228:
			;
		SW_GENERATED_LABEL_229:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_VSPACE))))])) {
						if (count > int32(0)) && (codevalue == (int32(380) + OP_TYPEPOSPLUS)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -state_offset
							(*next_new_state).count = count
							(*next_new_state).data = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_230:
			;
		SW_GENERATED_LABEL_231:
			;
		SW_GENERATED_LABEL_232:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_HSPACE))))])) {
						if (count > int32(0)) && (codevalue == (int32(360) + OP_TYPEPOSPLUS)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -state_offset
							(*next_new_state).count = count
							(*next_new_state).data = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_233:
			;
		SW_GENERATED_LABEL_234:
			;
		SW_GENERATED_LABEL_235:
			{
				count = int32(4)
				goto QS1
			}
		SW_GENERATED_LABEL_236:
			;
		SW_GENERATED_LABEL_237:
			;
		SW_GENERATED_LABEL_238:
			{
				count = int32(0)
			}
		QS1:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(4))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var OK BOOL
					var cp *pcre_uint32
					var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code)))))))) {
					case int32(0):
						{
							OK = BOOL((int32(1)))
						}
					case int32(1):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt))]))
						}
					case int32(2):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))))]))
						}
					case int32(3):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).chartype)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(4):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).script)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(5):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N)))))]))
						}
					case int32(6):
						fallthrough
					case int32(7):
						{
							switch pcre_uint32(c) {
							case pcre_uint32('\t'):
								fallthrough
							case pcre_uint32(' '):
								fallthrough
							case pcre_uint32((uint8('\u00a0'))):
								fallthrough
							case pcre_uint32(int32(5760)):
								fallthrough
							case pcre_uint32(int32(6158)):
								fallthrough
							case pcre_uint32(int32(8192)):
								fallthrough
							case pcre_uint32(int32(8193)):
								fallthrough
							case pcre_uint32(int32(8194)):
								fallthrough
							case pcre_uint32(int32(8195)):
								fallthrough
							case pcre_uint32(int32(8196)):
								fallthrough
							case pcre_uint32(int32(8197)):
								fallthrough
							case pcre_uint32(int32(8198)):
								fallthrough
							case pcre_uint32(int32(8199)):
								fallthrough
							case pcre_uint32(int32(8200)):
								fallthrough
							case pcre_uint32(int32(8201)):
								fallthrough
							case pcre_uint32(int32(8202)):
								fallthrough
							case pcre_uint32(int32(8239)):
								fallthrough
							case pcre_uint32(int32(8287)):
								fallthrough
							case pcre_uint32(int32(12288)):
								fallthrough
							case pcre_uint32('\n'):
								fallthrough
							case pcre_uint32('\v'):
								fallthrough
							case pcre_uint32('\f'):
								fallthrough
							case pcre_uint32('\r'):
								fallthrough
							case pcre_uint32((uint8('\u0085'))):
								fallthrough
							case pcre_uint32(int32(8232)):
								fallthrough
							case pcre_uint32(int32(8233)):
								{
									OK = BOOL((int32(1)))
								}
							default:
								{
									OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
										tempVar := &_pcre_ucp_gentype[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
									}())) == pcre_uint32((uint32(ucp_Z))))]))
									break
								}
							}
						}
					case int32(8):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_')))))]))
						}
					case int32(9):
						{
							cp = ((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_caseless_sets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(3))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*tempVar))
							}()))
							for {
								if c < *cp {
									OK = BOOL((int32(0)))
									break
								}
								if c == *func() *pcre_uint32 {
									defer func() {
										cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
									}()
									return cp
								}() {
									OK = BOOL((int32(1)))
									break
								}
							}
						}
					case int32(10):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344))))))]))
						}
					default:
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(codevalue != OP_PROP)]))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_PROP))))])) {
						if (codevalue == (int32(300) + OP_TYPEPOSSTAR)) || (codevalue == (int32(300) + OP_TYPEPOSQUERY)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = (state_offset + count)
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
				goto SW_GENERATED_LABEL_170
			}
		SW_GENERATED_LABEL_239:
			;
		SW_GENERATED_LABEL_240:
			;
		SW_GENERATED_LABEL_241:
			{
				count = int32(2)
				goto QS2
			}
		SW_GENERATED_LABEL_242:
			;
		SW_GENERATED_LABEL_243:
			;
		SW_GENERATED_LABEL_244:
			{
				count = int32(0)
			}
		QS2:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var lgb int32
					var rgb int32
					var nptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(clen)*unsafe.Sizeof(*ptr))))
					var ncount int32 = int32(0)
					if (codevalue == (int32(320) + OP_TYPEPOSSTAR)) || (codevalue == (int32(320) + OP_TYPEPOSQUERY)) {
						active_count -= 1
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					}
					lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).gbprop))))
					for int64(uintptr(unsafe.Pointer(nptr))) < int64(uintptr(unsafe.Pointer(end_subject))) {
						dlen = int32(1)
						if int32((NotBOOL(BOOL(utf)))) != 0 {
							d = pcre_uint32((uint32(uint8((*nptr)))))
						} else {
							d = pcre_uint32((uint32(uint8((*nptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(5)
								}
							}
						}
						rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).gbprop))))
						if (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gbtable[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
						}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
							break
						}
						ncount += 1
						lgb = rgb
						nptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(dlen)*unsafe.Sizeof(*nptr))))
					}
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = -(state_offset + count)
						(*next_new_state).count = int32(0)
						(*next_new_state).data = ncount
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
				goto SW_GENERATED_LABEL_170
			}
		SW_GENERATED_LABEL_245:
			;
		SW_GENERATED_LABEL_246:
			;
		SW_GENERATED_LABEL_247:
			{
				count = int32(2)
				goto QS3
			}
		SW_GENERATED_LABEL_248:
			;
		SW_GENERATED_LABEL_249:
			;
		SW_GENERATED_LABEL_250:
			{
				count = int32(0)
			}
		QS3:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var ncount int32 = int32(0)
					switch pcre_uint32(c) {
					case pcre_uint32('\v'):
						goto SW_GENERATED_LABEL_153
					case pcre_uint32('\f'):
						goto SW_GENERATED_LABEL_154
					case pcre_uint32((uint8('\u0085'))):
						goto SW_GENERATED_LABEL_155
					case pcre_uint32(int32(8232)):
						goto SW_GENERATED_LABEL_156
					case pcre_uint32(int32(8233)):
						goto SW_GENERATED_LABEL_157
					case pcre_uint32('\r'):
						goto SW_GENERATED_LABEL_158
					case pcre_uint32('\n'):
						goto SW_GENERATED_LABEL_159
					default:
						goto SW_GENERATED_LABEL_160
					}
					goto SW_GENERATED_LABEL_152
				SW_GENERATED_LABEL_153:
					;
				SW_GENERATED_LABEL_154:
					;
				SW_GENERATED_LABEL_155:
					;
				SW_GENERATED_LABEL_156:
					;
				SW_GENERATED_LABEL_157:
					{
						if ((*md).moptions & int32(8388608)) != int32(0) {
							goto SW_GENERATED_LABEL_152
						}
						goto ANYNL02
					}
				SW_GENERATED_LABEL_158:
					{
						if (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32('\n')) {
							ncount = int32(1)
						}
					}
				ANYNL02:
					{
					}
				SW_GENERATED_LABEL_159:
					{
						if (codevalue == (int32(340) + OP_TYPEPOSSTAR)) || (codevalue == (int32(340) + OP_TYPEPOSQUERY)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -(state_offset + count)
							(*next_new_state).count = int32(0)
							(*next_new_state).data = ncount
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
					goto SW_GENERATED_LABEL_152
				SW_GENERATED_LABEL_160:
					{
						goto SW_GENERATED_LABEL_152
					}
				SW_GENERATED_LABEL_152:
				}
				goto SW_GENERATED_LABEL_170
			}
		SW_GENERATED_LABEL_251:
			;
		SW_GENERATED_LABEL_252:
			;
		SW_GENERATED_LABEL_253:
			{
				count = int32(2)
				goto QS4
			}
		SW_GENERATED_LABEL_254:
			;
		SW_GENERATED_LABEL_255:
			;
		SW_GENERATED_LABEL_256:
			{
				count = int32(0)
			}
		QS4:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_VSPACE))))])) {
						if (codevalue == (int32(380) + OP_TYPEPOSSTAR)) || (codevalue == (int32(380) + OP_TYPEPOSQUERY)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -(state_offset + count)
							(*next_new_state).count = int32(0)
							(*next_new_state).data = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
				goto SW_GENERATED_LABEL_170
			}
		SW_GENERATED_LABEL_257:
			;
		SW_GENERATED_LABEL_258:
			;
		SW_GENERATED_LABEL_259:
			{
				count = int32(2)
				goto QS5
			}
		SW_GENERATED_LABEL_260:
			;
		SW_GENERATED_LABEL_261:
			;
		SW_GENERATED_LABEL_262:
			{
				count = int32(0)
			}
		QS5:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (state_offset + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_HSPACE))))])) {
						if (codevalue == (int32(360) + OP_TYPEPOSSTAR)) || (codevalue == (int32(360) + OP_TYPEPOSQUERY)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -(state_offset + count)
							(*next_new_state).count = int32(0)
							(*next_new_state).data = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
				goto SW_GENERATED_LABEL_170
			}
		SW_GENERATED_LABEL_263:
			;
		SW_GENERATED_LABEL_264:
			;
		SW_GENERATED_LABEL_265:
			;
		SW_GENERATED_LABEL_266:
			{
				if codevalue != (int32(300) + OP_TYPEEXACT) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (((state_offset + int32(1)) + int32(2)) + int32(3))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				count = (*current_state).count
				if clen > int32(0) {
					var OK BOOL
					var cp *pcre_uint32
					var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*code)))))))) {
					case int32(0):
						{
							OK = BOOL((int32(1)))
						}
					case int32(1):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt))]))
						}
					case int32(2):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(2)))*unsafe.Sizeof(*code))))))))))]))
						}
					case int32(3):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).chartype)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(2)))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(4):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((pcre_uint8((*prop).script)))) == int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(2)))*unsafe.Sizeof(*code))))))))]))
						}
					case int32(5):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N)))))]))
						}
					case int32(6):
						fallthrough
					case int32(7):
						{
							switch pcre_uint32(c) {
							case pcre_uint32('\t'):
								fallthrough
							case pcre_uint32(' '):
								fallthrough
							case pcre_uint32((uint8('\u00a0'))):
								fallthrough
							case pcre_uint32(int32(5760)):
								fallthrough
							case pcre_uint32(int32(6158)):
								fallthrough
							case pcre_uint32(int32(8192)):
								fallthrough
							case pcre_uint32(int32(8193)):
								fallthrough
							case pcre_uint32(int32(8194)):
								fallthrough
							case pcre_uint32(int32(8195)):
								fallthrough
							case pcre_uint32(int32(8196)):
								fallthrough
							case pcre_uint32(int32(8197)):
								fallthrough
							case pcre_uint32(int32(8198)):
								fallthrough
							case pcre_uint32(int32(8199)):
								fallthrough
							case pcre_uint32(int32(8200)):
								fallthrough
							case pcre_uint32(int32(8201)):
								fallthrough
							case pcre_uint32(int32(8202)):
								fallthrough
							case pcre_uint32(int32(8239)):
								fallthrough
							case pcre_uint32(int32(8287)):
								fallthrough
							case pcre_uint32(int32(12288)):
								fallthrough
							case pcre_uint32('\n'):
								fallthrough
							case pcre_uint32('\v'):
								fallthrough
							case pcre_uint32('\f'):
								fallthrough
							case pcre_uint32('\r'):
								fallthrough
							case pcre_uint32((uint8('\u0085'))):
								fallthrough
							case pcre_uint32(int32(8232)):
								fallthrough
							case pcre_uint32(int32(8233)):
								{
									OK = BOOL((int32(1)))
								}
							default:
								{
									OK = BOOL((map[bool]int32{false: 0, true: 1}[(*((*pcre_uint32)(func() unsafe.Pointer {
										tempVar := &_pcre_ucp_gentype[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
									}())) == pcre_uint32((uint32(ucp_Z))))]))
									break
								}
							}
						}
					case int32(8):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_')))))]))
						}
					case int32(9):
						{
							cp = ((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_caseless_sets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(1)+int32(2))+int32(2)))*unsafe.Sizeof(*code))))))))*unsafe.Sizeof(*tempVar))
							}()))
							for {
								if c < *cp {
									OK = BOOL((int32(0)))
									break
								}
								if c == *func() *pcre_uint32 {
									defer func() {
										cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
									}()
									return cp
								}() {
									OK = BOOL((int32(1)))
									break
								}
							}
						}
					case int32(10):
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344))))))]))
						}
					default:
						{
							OK = BOOL((map[bool]int32{false: 0, true: 1}[(codevalue != OP_PROP)]))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_PROP))))])) {
						if codevalue == (int32(300) + OP_TYPEPOSUPTO) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (((state_offset + int32(1)) + int32(2)) + int32(3))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_267:
			;
		SW_GENERATED_LABEL_268:
			;
		SW_GENERATED_LABEL_269:
			;
		SW_GENERATED_LABEL_270:
			{
				if codevalue != (int32(320) + OP_TYPEEXACT) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + int32(2)) + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				count = (*current_state).count
				if clen > int32(0) {
					var lgb int32
					var rgb int32
					var nptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(clen)*unsafe.Sizeof(*ptr))))
					var ncount int32 = int32(0)
					if codevalue == (int32(320) + OP_TYPEPOSUPTO) {
						active_count -= 1
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					}
					lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).gbprop))))
					for int64(uintptr(unsafe.Pointer(nptr))) < int64(uintptr(unsafe.Pointer(end_subject))) {
						dlen = int32(1)
						if int32((NotBOOL(BOOL(utf)))) != 0 {
							d = pcre_uint32((uint32(uint8((*nptr)))))
						} else {
							d = pcre_uint32((uint32(uint8((*nptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(5)
								}
							}
						}
						rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).gbprop))))
						if (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gbtable[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
						}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
							break
						}
						ncount += 1
						lgb = rgb
						nptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(dlen)*unsafe.Sizeof(*nptr))))
					}
					if (int64(uintptr(unsafe.Pointer(nptr))) >= int64(uintptr(unsafe.Pointer(end_subject)))) && (((*md).moptions & int32(134217728)) != int32(0)) {
						reset_could_continue = BOOL((int32(1)))
					}
					if func() int32 {
						count += 1
						return count
					}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -((state_offset + int32(2)) + int32(2))
							(*next_new_state).count = int32(0)
							(*next_new_state).data = ncount
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					} else {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -state_offset
							(*next_new_state).count = count
							(*next_new_state).data = ncount
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_271:
			;
		SW_GENERATED_LABEL_272:
			;
		SW_GENERATED_LABEL_273:
			;
		SW_GENERATED_LABEL_274:
			{
				if codevalue != (int32(340) + OP_TYPEEXACT) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + int32(2)) + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				count = (*current_state).count
				if clen > int32(0) {
					var ncount int32 = int32(0)
					switch pcre_uint32(c) {
					case pcre_uint32('\v'):
						goto SW_GENERATED_LABEL_162
					case pcre_uint32('\f'):
						goto SW_GENERATED_LABEL_163
					case pcre_uint32((uint8('\u0085'))):
						goto SW_GENERATED_LABEL_164
					case pcre_uint32(int32(8232)):
						goto SW_GENERATED_LABEL_165
					case pcre_uint32(int32(8233)):
						goto SW_GENERATED_LABEL_166
					case pcre_uint32('\r'):
						goto SW_GENERATED_LABEL_167
					case pcre_uint32('\n'):
						goto SW_GENERATED_LABEL_168
					default:
						goto SW_GENERATED_LABEL_169
					}
					goto SW_GENERATED_LABEL_161
				SW_GENERATED_LABEL_162:
					;
				SW_GENERATED_LABEL_163:
					;
				SW_GENERATED_LABEL_164:
					;
				SW_GENERATED_LABEL_165:
					;
				SW_GENERATED_LABEL_166:
					{
						if ((*md).moptions & int32(8388608)) != int32(0) {
							goto SW_GENERATED_LABEL_161
						}
						goto ANYNL03
					}
				SW_GENERATED_LABEL_167:
					{
						if (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32('\n')) {
							ncount = int32(1)
						}
					}
				ANYNL03:
					{
					}
				SW_GENERATED_LABEL_168:
					{
						if codevalue == (int32(340) + OP_TYPEPOSUPTO) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -((state_offset + int32(2)) + int32(2))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = ncount
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -state_offset
								(*next_new_state).count = count
								(*next_new_state).data = ncount
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
					goto SW_GENERATED_LABEL_161
				SW_GENERATED_LABEL_169:
					{
						goto SW_GENERATED_LABEL_161
					}
				SW_GENERATED_LABEL_161:
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_275:
			;
		SW_GENERATED_LABEL_276:
			;
		SW_GENERATED_LABEL_277:
			;
		SW_GENERATED_LABEL_278:
			{
				if codevalue != (int32(380) + OP_TYPEEXACT) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + int32(2)) + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				count = (*current_state).count
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_VSPACE))))])) {
						if codevalue == (int32(380) + OP_TYPEPOSUPTO) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -((state_offset + int32(2)) + int32(2))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -state_offset
								(*next_new_state).count = count
								(*next_new_state).data = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_279:
			;
		SW_GENERATED_LABEL_280:
			;
		SW_GENERATED_LABEL_281:
			;
		SW_GENERATED_LABEL_282:
			{
				if codevalue != (int32(360) + OP_TYPEEXACT) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + int32(2)) + int32(2))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				count = (*current_state).count
				if clen > int32(0) {
					var OK BOOL
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
							OK = BOOL((int32(1)))
						}
					default:
						{
							OK = BOOL((int32(0)))
							break
						}
					}
					if OK == BOOL((map[bool]int32{false: 0, true: 1}[(d == pcre_uint32((uint32(OP_HSPACE))))])) {
						if codevalue == (int32(360) + OP_TYPEPOSUPTO) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -((state_offset + int32(2)) + int32(2))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -state_offset
								(*next_new_state).count = count
								(*next_new_state).data = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_283:
			{
				if (clen > int32(0)) && (c == d) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = ((state_offset + dlen) + int32(1))
						(*next_new_state).count = int32(0)
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_284:
			{
				if clen == int32(0) {
					goto SW_GENERATED_LABEL_170
				}
				if int32((BOOL(utf))) != 0 {
					if c == d {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = ((state_offset + dlen) + int32(1))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					} else {
						var othercase uint32
						if c < pcre_uint32((uint32(int32(128)))) {
							othercase = uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(fcc)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*fcc)))))))
						} else {
							othercase = uint32((pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))))
						}
						if d == pcre_uint32((othercase)) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = ((state_offset + dlen) + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				} else {
					if int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((lcc))) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*(lcc)))))))) == int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((lcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(lcc)))))))) {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = (state_offset + int32(2))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_285:
			{
				if clen > int32(0) {
					var lgb int32
					var rgb int32
					var nptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(clen)*unsafe.Sizeof(*ptr))))
					var ncount int32 = int32(0)
					lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).gbprop))))
					for int64(uintptr(unsafe.Pointer(nptr))) < int64(uintptr(unsafe.Pointer(end_subject))) {
						dlen = int32(1)
						if int32((NotBOOL(BOOL(utf)))) != 0 {
							d = pcre_uint32((uint32(uint8((*nptr)))))
						} else {
							d = pcre_uint32((uint32(uint8((*nptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*nptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*nptr))))))) & int32(63))))))
									dlen += int32(5)
								}
							}
						}
						rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).gbprop))))
						if (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gbtable[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
						}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
							break
						}
						ncount += 1
						lgb = rgb
						nptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nptr)) + (uintptr)(dlen)*unsafe.Sizeof(*nptr))))
					}
					if (int64(uintptr(unsafe.Pointer(nptr))) >= int64(uintptr(unsafe.Pointer(end_subject)))) && (((*md).moptions & int32(134217728)) != int32(0)) {
						reset_could_continue = BOOL((int32(1)))
					}
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = -(state_offset + int32(1))
						(*next_new_state).count = int32(0)
						(*next_new_state).data = ncount
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_286:
			{
				if clen > int32(0) {
					switch pcre_uint32(c) {
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							if ((*md).moptions & int32(8388608)) != int32(0) {
								break
							}
						}
						fallthrough
					case pcre_uint32('\n'):
						{
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					case pcre_uint32('\r'):
						{
							if int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) >= int64(uintptr(unsafe.Pointer(end_subject))) {
								if func() int32 {
									defer func() {
										new_count += 1
									}()
									return new_count
								}() < wscount {
									(*next_new_state).offset = (state_offset + int32(1))
									(*next_new_state).count = int32(0)
									next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
								} else {
									return (-int32(19))
								}
								if ((*md).moptions & int32(134217728)) != int32(0) {
									reset_could_continue = BOOL((int32(1)))
								}
							} else if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*ptr))))))) == int32('\n') {
								if func() int32 {
									defer func() {
										new_count += 1
									}()
									return new_count
								}() < wscount {
									(*next_new_state).offset = -(state_offset + int32(1))
									(*next_new_state).count = int32(0)
									(*next_new_state).data = int32(1)
									next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
								} else {
									return (-int32(19))
								}
							} else {
								if func() int32 {
									defer func() {
										new_count += 1
									}()
									return new_count
								}() < wscount {
									(*next_new_state).offset = (state_offset + int32(1))
									(*next_new_state).count = int32(0)
									next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
								} else {
									return (-int32(19))
								}
							}
							break
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_287:
			{
				if clen > int32(0) {
					switch pcre_uint32(c) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
						}
					default:
						{
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
							break
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_288:
			{
				if clen > int32(0) {
					switch pcre_uint32(c) {
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					default:
						{
							break
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_289:
			{
				if clen > int32(0) {
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
						}
					default:
						{
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
							break
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_290:
			{
				if clen > int32(0) {
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						{
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					default:
						{
							break
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_291:
			{
				if (clen > int32(0)) && (c != d) {
					if func() int32 {
						defer func() {
							new_count += 1
						}()
						return new_count
					}() < wscount {
						(*next_new_state).offset = ((state_offset + dlen) + int32(1))
						(*next_new_state).count = int32(0)
						next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_292:
			{
				if clen > int32(0) {
					var otherd pcre_uint32
					if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
						otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).other_case))))))
					} else {
						otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
					}
					if (c != d) && (c != otherd) {
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = ((state_offset + dlen) + int32(1))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_293:
			;
		SW_GENERATED_LABEL_294:
			;
		SW_GENERATED_LABEL_295:
			;
		SW_GENERATED_LABEL_296:
			;
		SW_GENERATED_LABEL_297:
			;
		SW_GENERATED_LABEL_298:
			{
				caseless = BOOL((int32(1)))
				codevalue -= (OP_STARI - OP_STAR)
			}
		SW_GENERATED_LABEL_299:
			;
		SW_GENERATED_LABEL_300:
			;
		SW_GENERATED_LABEL_301:
			;
		SW_GENERATED_LABEL_302:
			;
		SW_GENERATED_LABEL_303:
			;
		SW_GENERATED_LABEL_304:
			{
				count = (*current_state).count
				if count > int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = ((state_offset + dlen) + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
				if clen > int32(0) {
					var otherd pcre_uint32 = pcre_uint32((uint32(4294967295)))
					if int32((BOOL(caseless))) != 0 {
						if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
							otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))
						} else {
							otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
						}
					}
					if ((c == d) || (c == otherd)) == (codevalue < OP_NOTSTAR) {
						if (count > int32(0)) && ((codevalue == OP_POSPLUS) || (codevalue == OP_NOTPOSPLUS)) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						count += 1
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = state_offset
							(*next_new_state).count = count
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_305:
			;
		SW_GENERATED_LABEL_306:
			;
		SW_GENERATED_LABEL_307:
			;
		SW_GENERATED_LABEL_308:
			;
		SW_GENERATED_LABEL_309:
			;
		SW_GENERATED_LABEL_310:
			{
				caseless = BOOL((int32(1)))
				codevalue -= (OP_STARI - OP_STAR)
			}
		SW_GENERATED_LABEL_311:
			;
		SW_GENERATED_LABEL_312:
			;
		SW_GENERATED_LABEL_313:
			;
		SW_GENERATED_LABEL_314:
			;
		SW_GENERATED_LABEL_315:
			;
		SW_GENERATED_LABEL_316:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = ((state_offset + dlen) + int32(1))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var otherd pcre_uint32 = pcre_uint32((uint32(4294967295)))
					if int32((BOOL(caseless))) != 0 {
						if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
							otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))
						} else {
							otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
						}
					}
					if ((c == d) || (c == otherd)) == (codevalue < OP_NOTSTAR) {
						if (codevalue == OP_POSQUERY) || (codevalue == OP_NOTPOSQUERY) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = ((state_offset + dlen) + int32(1))
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_317:
			;
		SW_GENERATED_LABEL_318:
			;
		SW_GENERATED_LABEL_319:
			;
		SW_GENERATED_LABEL_320:
			;
		SW_GENERATED_LABEL_321:
			;
		SW_GENERATED_LABEL_322:
			{
				caseless = BOOL((int32(1)))
				codevalue -= (OP_STARI - OP_STAR)
			}
		SW_GENERATED_LABEL_323:
			;
		SW_GENERATED_LABEL_324:
			;
		SW_GENERATED_LABEL_325:
			;
		SW_GENERATED_LABEL_326:
			;
		SW_GENERATED_LABEL_327:
			;
		SW_GENERATED_LABEL_328:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = ((state_offset + dlen) + int32(1))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				if clen > int32(0) {
					var otherd pcre_uint32 = pcre_uint32((uint32(4294967295)))
					if int32((BOOL(caseless))) != 0 {
						if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
							otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))
						} else {
							otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
						}
					}
					if ((c == d) || (c == otherd)) == (codevalue < OP_NOTSTAR) {
						if (codevalue == OP_POSSTAR) || (codevalue == OP_NOTPOSSTAR) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = state_offset
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_329:
			;
		SW_GENERATED_LABEL_330:
			{
				caseless = BOOL((int32(1)))
				codevalue -= (OP_STARI - OP_STAR)
			}
		SW_GENERATED_LABEL_331:
			;
		SW_GENERATED_LABEL_332:
			{
				count = (*current_state).count
				if clen > int32(0) {
					var otherd pcre_uint32 = pcre_uint32((uint32(4294967295)))
					if int32((BOOL(caseless))) != 0 {
						if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
							otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))
						} else {
							otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
						}
					}
					if ((c == d) || (c == otherd)) == (codevalue < OP_NOTSTAR) {
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (((state_offset + dlen) + int32(1)) + int32(2))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_333:
			;
		SW_GENERATED_LABEL_334:
			;
		SW_GENERATED_LABEL_335:
			;
		SW_GENERATED_LABEL_336:
			;
		SW_GENERATED_LABEL_337:
			;
		SW_GENERATED_LABEL_338:
			{
				caseless = BOOL((int32(1)))
				codevalue -= (OP_STARI - OP_STAR)
			}
		SW_GENERATED_LABEL_339:
			;
		SW_GENERATED_LABEL_340:
			;
		SW_GENERATED_LABEL_341:
			;
		SW_GENERATED_LABEL_342:
			;
		SW_GENERATED_LABEL_343:
			;
		SW_GENERATED_LABEL_344:
			{
				if func() int32 {
					defer func() {
						active_count += 1
					}()
					return active_count
				}() < wscount {
					(*next_active_state).offset = (((state_offset + dlen) + int32(1)) + int32(2))
					(*next_active_state).count = int32(0)
					next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
				} else {
					return (-int32(19))
				}
				count = (*current_state).count
				if clen > int32(0) {
					var otherd pcre_uint32 = pcre_uint32((uint32(4294967295)))
					if int32((BOOL(caseless))) != 0 {
						if (int32((utf)) != 0) && (d >= pcre_uint32((uint32(int32(128))))) {
							otherd = pcre_uint32((int32(uint32((pcre_uint32(d)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).other_case))))))
						} else {
							otherd = pcre_uint32((uint32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((fcc))) + (uintptr)(int32(uint32((d))))*unsafe.Sizeof(*(fcc))))))))))
						}
					}
					if ((c == d) || (c == otherd)) == (codevalue < OP_NOTSTAR) {
						if (codevalue == OP_POSUPTO) || (codevalue == OP_NOTPOSUPTO) {
							active_count -= 1
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						}
						if func() int32 {
							count += 1
							return count
						}() >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (((state_offset + dlen) + int32(1)) + int32(2))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_345:
			;
		SW_GENERATED_LABEL_346:
			;
		SW_GENERATED_LABEL_347:
			{
				var isinclass BOOL = BOOL((int32(0)))
				var next_state_offset int32
				var ecode *pcre_uchar
				if codevalue != OP_XCLASS {
					ecode = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*tempVar))
					}()))
					if clen > int32(0) {
						isinclass = BOOL((func() int32 {
							if (map[bool]int32{false: 0, true: 1}[(c > pcre_uint32((uint32(int32(255)))))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[(codevalue == OP_NCLASS)])
							} else {
								return (map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := ((*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
								}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0))])
							}
						}()))
					}
				} else {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
					if clen > int32(0) {
						isinclass = _pcre_xclass(pcre_uint32(c), ((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
						}())), BOOL(utf))
					}
				}
				next_state_offset = (int32((int64(uintptr(unsafe.Pointer(ecode))) - int64(uintptr(unsafe.Pointer(start_code))))))
				switch int32(uint8((pcre_uchar(*ecode)))) {
				case OP_CRSTAR:
					fallthrough
				case OP_CRMINSTAR:
					fallthrough
				case OP_CRPOSSTAR:
					{
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (next_state_offset + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
						if int32((BOOL(isinclass))) != 0 {
							if int32(uint8((*ecode))) == OP_CRPOSSTAR {
								active_count -= 1
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							}
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				case OP_CRPLUS:
					fallthrough
				case OP_CRMINPLUS:
					fallthrough
				case OP_CRPOSPLUS:
					{
						count = (*current_state).count
						if count > int32(0) {
							if func() int32 {
								defer func() {
									active_count += 1
								}()
								return active_count
							}() < wscount {
								(*next_active_state).offset = (next_state_offset + int32(1))
								(*next_active_state).count = int32(0)
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							} else {
								return (-int32(19))
							}
						}
						if int32((BOOL(isinclass))) != 0 {
							if (count > int32(0)) && (int32(uint8((*ecode))) == OP_CRPOSPLUS) {
								active_count -= 1
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							}
							count += 1
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = state_offset
								(*next_new_state).count = count
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				case OP_CRQUERY:
					fallthrough
				case OP_CRMINQUERY:
					fallthrough
				case OP_CRPOSQUERY:
					{
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (next_state_offset + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
						if int32((BOOL(isinclass))) != 0 {
							if int32(uint8((*ecode))) == OP_CRPOSQUERY {
								active_count -= 1
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							}
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = (next_state_offset + int32(1))
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				case OP_CRRANGE:
					fallthrough
				case OP_CRMINRANGE:
					fallthrough
				case OP_CRPOSRANGE:
					{
						count = (*current_state).count
						if count >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))) {
							if func() int32 {
								defer func() {
									active_count += 1
								}()
								return active_count
							}() < wscount {
								(*next_active_state).offset = ((next_state_offset + int32(1)) + (int32(2) * int32(2)))
								(*next_active_state).count = int32(0)
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							} else {
								return (-int32(19))
							}
						}
						if int32((BOOL(isinclass))) != 0 {
							var max int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
							if (int32(uint8((*ecode))) == OP_CRPOSRANGE) && (count >= int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))) {
								active_count -= 1
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) - (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							}
							if (func() int32 {
								count += 1
								return count
							}() >= max) && (max != int32(0)) {
								if func() int32 {
									defer func() {
										new_count += 1
									}()
									return new_count
								}() < wscount {
									(*next_new_state).offset = ((next_state_offset + int32(1)) + (int32(2) * int32(2)))
									(*next_new_state).count = int32(0)
									next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
								} else {
									return (-int32(19))
								}
							} else {
								if func() int32 {
									defer func() {
										new_count += 1
									}()
									return new_count
								}() < wscount {
									(*next_new_state).offset = state_offset
									(*next_new_state).count = count
									next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
								} else {
									return (-int32(19))
								}
							}
						}
					}
				default:
					{
						if int32((BOOL(isinclass))) != 0 {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = next_state_offset
								(*next_new_state).count = int32(0)
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
						break
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_348:
			{
				forced_fail += 1
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_349:
			;
		SW_GENERATED_LABEL_350:
			;
		SW_GENERATED_LABEL_351:
			;
		SW_GENERATED_LABEL_352:
			{
				var rc int32
				var local_offsets []int32 = make([]int32, 2, 2)
				var local_workspace []int32 = make([]int32, 1000, 1000)
				var endasscode *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
				for int32(uint8((*endasscode))) == OP_ALT {
					endasscode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endasscode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endasscode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(endasscode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endasscode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(endasscode))))))))))*unsafe.Sizeof(*endasscode))))
				}
				rc = internal_dfa_exec(md, code, ptr, (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject)))))), &local_offsets[0], int32((8 / 4)), &local_workspace[0], int32((4000 / 4)), rlevel)
				if rc == -int32(16) {
					return rc
				}
				if (rc >= int32(0)) == ((codevalue == OP_ASSERT) || (codevalue == OP_ASSERTBACK)) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endasscode)) + (uintptr)(int32(2))*unsafe.Sizeof(*endasscode))))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))) - int64(uintptr(unsafe.Pointer(start_code))))))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_353:
			;
		SW_GENERATED_LABEL_354:
			{
				var local_offsets []int32 = make([]int32, 1000, 1000)
				var local_workspace []int32 = make([]int32, 1000, 1000)
				var codelink int32 = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code)))))))))
				var condcode int32
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code))))))) == OP_CALLOUT {
					rrc = int32(0)
					if pcre_callout != nil {
						var cb pcre_callout_block
						cb.version = int32(1)
						cb.callout_number = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*code)))))))
						cb.offset_vector = offsets
						cb.subject = (*byte)(unsafe.Pointer(start_subject))
						cb.subject_length = (int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
						cb.start_match = (int32((int64(uintptr(unsafe.Pointer(current_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
						cb.current_position = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject))))))
						cb.pattern_position = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(3)))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(2)+int32(3))+int32(1)))*unsafe.Sizeof(*(code)))))))))
						cb.next_item_length = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(3)+(int32(2)*int32(2))))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(3)+(int32(2)*int32(2)))+int32(1)))*unsafe.Sizeof(*(code)))))))))
						cb.capture_top = int32(1)
						cb.capture_last = -int32(1)
						cb.callout_data = (*md).callout_data
						cb.mark = nil
						if (func() int32 {
							tempVar := pcre_callout(&cb)
							rrc = tempVar
							return tempVar
						}()) < int32(0) {
							return rrc
						}
					}
					if rrc > int32(0) {
						goto SW_GENERATED_LABEL_170
					}
					code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_OP_lengths[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CALLOUT)*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*code))))
				}
				condcode = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*code)))))))
				if ((condcode == OP_CREF) || (condcode == OP_DNCREF)) || (condcode == OP_DNRREF) {
					return (-int32(17))
				}
				if (condcode == OP_DEF) || (condcode == OP_FAIL) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (((state_offset + codelink) + int32(2)) + int32(1))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				} else if condcode == OP_RREF {
					var value int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(code)))))))))))
					if value != int32(65535) {
						return (-int32(17))
					}
					if (*md).recursive != nil {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (((state_offset + int32(2)) + int32(2)) + int32(2))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					} else {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (((state_offset + codelink) + int32(2)) + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					}
				} else {
					var rc int32
					var asscode *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(2))*unsafe.Sizeof(*code))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}()))
					var endasscode *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(asscode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((asscode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(asscode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((asscode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(asscode))))))))))*unsafe.Sizeof(*asscode))))
					for int32(uint8((*endasscode))) == OP_ALT {
						endasscode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endasscode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endasscode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(endasscode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((endasscode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(endasscode))))))))))*unsafe.Sizeof(*endasscode))))
					}
					rc = internal_dfa_exec(md, asscode, ptr, (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject)))))), &local_offsets[0], int32((4000 / 4)), &local_workspace[0], int32((4000 / 4)), rlevel)
					if rc == -int32(16) {
						return rc
					}
					if (rc >= int32(0)) == ((condcode == OP_ASSERT) || (condcode == OP_ASSERTBACK)) {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (int32((int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endasscode)) + (uintptr)(int32(2))*unsafe.Sizeof(*endasscode))))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))) - int64(uintptr(unsafe.Pointer(start_code))))))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					} else {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = (((state_offset + codelink) + int32(2)) + int32(1))
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_355:
			{
				var ri *dfa_recursion_info
				var local_offsets []int32 = make([]int32, 1000, 1000)
				var local_workspace []int32 = make([]int32, 1000, 1000)
				var callpat *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*start_code))))
				var recno int32 = int32(func() uint32 {
					if (map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(callpat))) == int64(uintptr(unsafe.Pointer((*md).start_code))))]) != 0 {
						return uint32(int32(0))
					} else {
						return uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(callpat)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(callpat))))))))))
					}
				}())
				var rc int32
				for ri = (*md).recursive; ri != nil; ri = (*ri).prevrec {
					if (recno == (*ri).group_num) && (int64(uintptr(unsafe.Pointer(ptr))) == int64(uintptr(unsafe.Pointer((*ri).subject_position)))) {
						return (-int32(26))
					}
				}
				new_recursive.group_num = recno
				new_recursive.subject_position = ptr
				new_recursive.prevrec = (*md).recursive
				(*md).recursive = &new_recursive
				rc = internal_dfa_exec(md, callpat, ptr, (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject)))))), &local_offsets[0], int32((4000 / 4)), &local_workspace[0], int32((4000 / 4)), rlevel)
				(*md).recursive = new_recursive.prevrec
				if rc == int32(0) {
					return (-int32(20))
				}
				if rc > int32(0) {
					for rc = ((rc * int32(2)) - int32(2)); rc >= int32(0); rc -= int32(2) {
						var charcount int32 = (*((*int32)(func() unsafe.Pointer {
							tempVar := &local_offsets[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((rc+int32(1)))*unsafe.Sizeof(*tempVar))
						}())) - *((*int32)(func() unsafe.Pointer {
							tempVar := &local_offsets[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(rc)*unsafe.Sizeof(*tempVar))
						}())))
						if int32((BOOL(utf))) != 0 {
							var p *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)(*((*int32)(func() unsafe.Pointer {
								tempVar := &local_offsets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(rc)*unsafe.Sizeof(*tempVar))
							}())))*unsafe.Sizeof(*start_subject))))
							var pp *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)(*((*int32)(func() unsafe.Pointer {
								tempVar := &local_offsets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((rc+int32(1)))*unsafe.Sizeof(*tempVar))
							}())))*unsafe.Sizeof(*start_subject))))
							for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(pp))) {
								if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*func() *pcre_uchar {
									defer func() {
										p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
									}()
									return p
								}()))) & int32(192)) == int32(128))]) != 0 {
									charcount -= 1
								}
							}
						}
						if charcount > int32(0) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -((state_offset + int32(2)) + int32(1))
								(*next_new_state).count = int32(0)
								(*next_new_state).data = (charcount - int32(1))
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						} else {
							if func() int32 {
								defer func() {
									active_count += 1
								}()
								return active_count
							}() < wscount {
								(*next_active_state).offset = ((state_offset + int32(2)) + int32(1))
								(*next_active_state).count = int32(0)
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				} else if rc != -int32(1) {
					return rc
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_356:
			;
		SW_GENERATED_LABEL_357:
			;
		SW_GENERATED_LABEL_358:
			;
		SW_GENERATED_LABEL_359:
			;
		SW_GENERATED_LABEL_360:
			{
				var charcount int32
				var matched_count int32
				var local_ptr *pcre_uchar = ptr
				var allow_zero BOOL
				if codevalue == OP_BRAPOSZERO {
					allow_zero = BOOL((int32(1)))
					codevalue = int32(uint8((*func() *pcre_uchar {
						code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(1)*unsafe.Sizeof(*code))))
						return code
					}())))
				} else {
					allow_zero = BOOL((int32(0)))
				}
				for matched_count = int32(0); ; matched_count++ {
					var local_offsets []int32 = make([]int32, 2, 2)
					var local_workspace []int32 = make([]int32, 1000, 1000)
					var rc int32 = internal_dfa_exec(md, code, local_ptr, (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject)))))), &local_offsets[0], int32((8 / 4)), &local_workspace[0], int32((4000 / 4)), rlevel)
					if rc < int32(0) {
						if rc != -int32(1) {
							return rc
						}
						break
					}
					charcount = (*((*int32)(func() unsafe.Pointer {
						tempVar := &local_offsets[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}())) - *&local_offsets[0])
					if charcount == int32(0) {
						break
					}
					local_ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(local_ptr)) + (uintptr)(charcount)*unsafe.Sizeof(*local_ptr))))
				}
				if (matched_count > int32(0)) || (int32((allow_zero)) != 0) {
					var end_subpattern *pcre_uchar = code
					var next_state_offset int32
					for {
						end_subpattern = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_subpattern)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_subpattern))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_subpattern))))))))))*unsafe.Sizeof(*end_subpattern))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_subpattern))) == OP_ALT)])) != 0 {
							break
						}
					}
					next_state_offset = (int32((((int64(uintptr(unsafe.Pointer(end_subpattern))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(2))) + int64(int32(1)))))
					if ((i + int32(1)) >= active_count) && (new_count == int32(0)) {
						ptr = local_ptr
						clen = int32(0)
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = next_state_offset
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					} else {
						var p *pcre_uchar = ptr
						var pp *pcre_uchar = local_ptr
						charcount = (int32((int64(uintptr(unsafe.Pointer(pp))) - int64(uintptr(unsafe.Pointer(p))))))
						if int32((BOOL(utf))) != 0 {
							for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(pp))) {
								if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*func() *pcre_uchar {
									defer func() {
										p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
									}()
									return p
								}()))) & int32(192)) == int32(128))]) != 0 {
									charcount -= 1
								}
							}
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -next_state_offset
							(*next_new_state).count = int32(0)
							(*next_new_state).data = (charcount - int32(1))
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_361:
			;
		SW_GENERATED_LABEL_362:
			{
				var local_offsets []int32 = make([]int32, 2, 2)
				var local_workspace []int32 = make([]int32, 1000, 1000)
				var rc int32 = internal_dfa_exec(md, code, ptr, (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject)))))), &local_offsets[0], int32((8 / 4)), &local_workspace[0], int32((4000 / 4)), rlevel)
				if rc >= int32(0) {
					var end_subpattern *pcre_uchar = code
					var charcount int32 = (*((*int32)(func() unsafe.Pointer {
						tempVar := &local_offsets[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}())) - *&local_offsets[0])
					var next_state_offset int32
					var repeat_state_offset int32
					for {
						end_subpattern = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(end_subpattern)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_subpattern))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_subpattern))))))))))*unsafe.Sizeof(*end_subpattern))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*end_subpattern))) == OP_ALT)])) != 0 {
							break
						}
					}
					next_state_offset = (int32((((int64(uintptr(unsafe.Pointer(end_subpattern))) - int64(uintptr(unsafe.Pointer(start_code)))) + int64(int32(2))) + int64(int32(1)))))
					repeat_state_offset = func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*end_subpattern))) == OP_KETRMAX) || (int32(uint8((*end_subpattern))) == OP_KETRMIN))]) != 0 {
							return (int32(((int64(uintptr(unsafe.Pointer(end_subpattern))) - int64(uintptr(unsafe.Pointer(start_code)))) - int64(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)(int32(1))*unsafe.Sizeof(*(end_subpattern)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((end_subpattern))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(end_subpattern)))))))))))))
						} else {
							return -int32(1)
						}
					}()
					if charcount == int32(0) {
						if func() int32 {
							defer func() {
								active_count += 1
							}()
							return active_count
						}() < wscount {
							(*next_active_state).offset = next_state_offset
							(*next_active_state).count = int32(0)
							next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
						} else {
							return (-int32(19))
						}
					} else if ((i + int32(1)) >= active_count) && (new_count == int32(0)) {
						ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(charcount)*unsafe.Sizeof(*ptr))))
						clen = int32(0)
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = next_state_offset
							(*next_new_state).count = int32(0)
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
						if repeat_state_offset >= int32(0) {
							next_active_state = active_states
							active_count = int32(0)
							i = -int32(1)
							if func() int32 {
								defer func() {
									active_count += 1
								}()
								return active_count
							}() < wscount {
								(*next_active_state).offset = repeat_state_offset
								(*next_active_state).count = int32(0)
								next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
							} else {
								return (-int32(19))
							}
						}
					} else {
						if int32((BOOL(utf))) != 0 {
							var p *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)(*&local_offsets[0])*unsafe.Sizeof(*start_subject))))
							var pp *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_subject)) + (uintptr)(*((*int32)(func() unsafe.Pointer {
								tempVar := &local_offsets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}())))*unsafe.Sizeof(*start_subject))))
							for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(pp))) {
								if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*func() *pcre_uchar {
									defer func() {
										p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
									}()
									return p
								}()))) & int32(192)) == int32(128))]) != 0 {
									charcount -= 1
								}
							}
						}
						if func() int32 {
							defer func() {
								new_count += 1
							}()
							return new_count
						}() < wscount {
							(*next_new_state).offset = -next_state_offset
							(*next_new_state).count = int32(0)
							(*next_new_state).data = (charcount - int32(1))
							next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
						} else {
							return (-int32(19))
						}
						if repeat_state_offset >= int32(0) {
							if func() int32 {
								defer func() {
									new_count += 1
								}()
								return new_count
							}() < wscount {
								(*next_new_state).offset = -repeat_state_offset
								(*next_new_state).count = int32(0)
								(*next_new_state).data = (charcount - int32(1))
								next_new_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_new_state)) + (uintptr)(1)*unsafe.Sizeof(*next_new_state))))
							} else {
								return (-int32(19))
							}
						}
					}
				} else if rc != -int32(1) {
					return rc
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_363:
			{
				rrc = int32(0)
				if pcre_callout != nil {
					var cb pcre_callout_block
					cb.version = int32(1)
					cb.callout_number = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code)))))))
					cb.offset_vector = offsets
					cb.subject = (*byte)(unsafe.Pointer(start_subject))
					cb.subject_length = (int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
					cb.start_match = (int32((int64(uintptr(unsafe.Pointer(current_subject))) - int64(uintptr(unsafe.Pointer(start_subject))))))
					cb.current_position = (int32((int64(uintptr(unsafe.Pointer(ptr))) - int64(uintptr(unsafe.Pointer(start_subject))))))
					cb.pattern_position = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(2))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(code)))))))))
					cb.next_item_length = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(code)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(code)))))))))
					cb.capture_top = int32(1)
					cb.capture_last = -int32(1)
					cb.callout_data = (*md).callout_data
					cb.mark = nil
					if (func() int32 {
						tempVar := pcre_callout(&cb)
						rrc = tempVar
						return tempVar
					}()) < int32(0) {
						return rrc
					}
				}
				if rrc == int32(0) {
					if func() int32 {
						defer func() {
							active_count += 1
						}()
						return active_count
					}() < wscount {
						(*next_active_state).offset = (state_offset + int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_OP_lengths[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CALLOUT)*unsafe.Sizeof(*tempVar))
						}()))))))
						(*next_active_state).count = int32(0)
						next_active_state = ((*stateblock)(unsafe.Pointer(uintptr(unsafe.Pointer(next_active_state)) + (uintptr)(1)*unsafe.Sizeof(*next_active_state))))
					} else {
						return (-int32(19))
					}
				}
			}
			goto SW_GENERATED_LABEL_170
		SW_GENERATED_LABEL_364:
			{
				return (-int32(16))
			}
		SW_GENERATED_LABEL_170:
			;
		NEXT_ACTIVE_STATE:
			;
			continue
		}
		if new_count <= int32(0) {
			if ((((rlevel == int32(1)) && (int32((could_continue)) != 0)) && (forced_fail != *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(1))*unsafe.Sizeof(*workspace)))))) && ((((*md).moptions & int32(134217728)) != int32(0)) || ((((*md).moptions & int32(32768)) != int32(0)) && (match_count < int32(0))))) && ((int32((partial_newline)) != 0) || ((int64(uintptr(unsafe.Pointer(ptr))) >= int64(uintptr(unsafe.Pointer(end_subject)))) && (int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))))) {
				match_count = -int32(12)
			}
			break
		}
		ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(clen)*unsafe.Sizeof(*ptr))))
	}
	return match_count
}

// pcre_dfa_exec - transpiled function from  /root/Documents/pcre/pcre_dfa_exec.c:3178
/*************************************************
*    Execute a Regular Expression - DFA engine   *
*************************************************/ //
/* This external function applies a compiled re to a subject string using a DFA
engine. This function calls the internal function multiple times if the pattern
is not anchored.

Arguments:
  argument_re     points to the compiled expression
  extra_data      points to extra data or is NULL
  subject         points to the subject string
  length          length of subject string (may contain binary zeros)
  start_offset    where to start in the subject string
  options         option bits
  offsets         vector of match offsets
  offsetcount     size of same
  workspace       workspace vector
  wscount         size of same

Returns:          > 0 => number of match offset pairs placed in offsets
                  = 0 => offsets overflowed; longest matches are present
                   -1 => failed to match
                 < -1 => some kind of unexpected problem
*/ //
/* Plausibility checks */ //
/* Check that the first field in the block is the magic number. If it is not,
return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to
REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which
means that the pattern is likely compiled with different endianness. */ //
/* If restarting after a partial match, do some sanity checks on the contents
of the workspace. */ //
/* Set up study, callout, and table data */ //
/* Set some local values */ //
/* PCRE_UTF(16|32) have the same value as PCRE_UTF8. */ //
/* The remaining fixed data for passing around. */ //
/* If the BSR option is not set at match time, copy what was set
at compile time. */ //
/* Handle different types of newline. The three bits give eight cases. If
nothing is set at run time, whatever was used at compile time applies. */ //
/* Compile-time default */ //
/* Check a UTF-8 string if required. Unfortunately there's no way of passing
back the character offset. */ //
/* If the exec call supplied NULL for tables, use the inbuilt ones. This
is a feature that makes it possible to save compiled regex and re-use them
in other programs later. */ //
/* The "must be at the start of a line" flags are used in a loop when finding
where to start. */ //
/* Set up the first character to match, if available. The first_byte value is
never set for an anchored regular expression, but the anchoring may be forced
at run time, so we have to test for anchoring. The first char may be unset for
an unanchored pattern, of course. If there's no first char and the pattern was
studied, there may be a bitmap of possible first characters. */ //
/* For anchored or unanchored matches, there may be a "last known required
character" set. */ //
/* Call the main matching function, looping for a non-anchored regex after a
failed match. If not restarting, perform certain optimizations at the start of
a match. */ //
/* If firstline is TRUE, the start of the match is constrained to the first
   line of a multiline string. Implement this by temporarily adjusting
   end_subject so that we stop scanning at a newline. If the match fails at
   the newline, later code breaks this loop. */ //
/* There are some optimizations that avoid running the match if a known
   starting point is not found. However, there is an option that disables
   these, for testing and for ensuring that all callouts do actually occur.
   The option can be set in the regex by (*NO_START_OPT) or passed in
   match-time options. */ //
/* Advance to a known first pcre_uchar (i.e. data item) */ //
/* Or to just after a linebreak for a multiline match if possible */ //
/* If we have just passed a CR and the newline option is ANY or
   ANYCRLF, and we are now at a LF, advance the match position by one
   more character. */ //
/* Advance to a non-unique first pcre_uchar after study */ //
/* Restore fudged end_subject */ //
/* The following two optimizations are disabled for partial matching or if
   disabling is explicitly requested (and of course, by the test above, this
   code is not obeyed when restarting after a partial match). */ //
/* If the pattern was studied, a minimum subject length may be set. This
   is a lower bound; no actual string of that length may actually match the
   pattern. Although the value is, strictly, in characters, we treat it as
   in pcre_uchar units to avoid spending too much time in this optimization.
*/ //
/* If req_char is set, we know that that pcre_uchar must appear in the
   subject for the match to succeed. If the first pcre_uchar is set,
   req_char must be later in the subject; otherwise the test starts at the
   match point. This optimization can save a huge amount of work in patterns
   with nested unlimited repeats that aren't going to match. Writing
   separate code for cased/caseless versions makes it go faster, as does
   using an autoincrement and backing off on a match.

   HOWEVER: when the subject string is very, very long, searching to its end
   can take a long time, and give bad performance on quite ordinary
   patterns. This showed up when somebody was matching /^C/ on a 32-megabyte
   string... so we don't do this when the string is sufficiently long. */ //
/* We don't need to repeat the search if we haven't yet reached the
   place we found it at last time. */ //
/* If we can't find the required pcre_uchar, break the matching loop,
   which will cause a return or PCRE_ERROR_NOMATCH. */ //
/* If we have found the required pcre_uchar, save the point where we
   found it, so that we don't search again next time round the loop if
   the start hasn't passed this point yet. */ //
/* End of optimizations that are done when not restarting */ //
/* OK, now we can do the business */ //
/* fixed match data */ //
/* this subexpression's code */ //
/* where we currently are */ //
/* start offset in subject */ //
/* offset vector */ //
/* size of same */ //
/* workspace vector */ //
/* size of same */ //
/* function recurse level */ //
/* Anything other than "no match" means we are done, always; otherwise, carry
on only if not anchored. */ //
/* Advance to the next subject character unless we are at the end of a line
and firstline is set. */ //
/* If we have just passed a CR and we are now at a LF, and the pattern does
not contain any explicit matches for \r or \n, and the newline option is CRLF
or ANY or ANYCRLF, advance the match position by one more character. */ //
/* "Bumpalong" loop */ //
//
func pcre_dfa_exec(argument_re *pcre, extra_data *pcre_extra, subject *byte, length int32, start_offset int32, options int32, offsets *int32, offsetcount int32, workspace *int32, wscount int32) int32 {
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(argument_re))
	var match_block dfa_match_data
	var md *dfa_match_data = &match_block
	var utf BOOL
	var anchored BOOL
	var startline BOOL
	var firstline BOOL
	var current_subject *pcre_uchar
	var end_subject *pcre_uchar
	var study *pcre_study_data = nil
	var req_char_ptr *pcre_uchar
	var start_bits *pcre_uint8 = nil
	var has_first_char BOOL = BOOL((int32(0)))
	var has_req_char BOOL = BOOL((int32(0)))
	var first_char pcre_uchar = pcre_uchar(int32(0))
	var first_char2 pcre_uchar = pcre_uchar(int32(0))
	var req_char pcre_uchar = pcre_uchar(int32(0))
	var req_char2 pcre_uchar = pcre_uchar(int32(0))
	var newline int32
	if (options & ^(((((((((((((int32(16) | int32(128)) | int32(256)) | int32(1024)) | int32(268435456)) | int32(8192)) | int32(134217728)) | int32(32768)) | int32(65536)) | int32(131072)) | (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) | int32(8388608)) | int32(16777216)) | int32(67108864))) != int32(0) {
		return (-int32(3))
	}
	if (((re == nil) || (subject == nil)) || (workspace == nil)) || ((offsets == nil) && (offsetcount > int32(0))) {
		return (-int32(2))
	}
	if offsetcount < int32(0) {
		return (-int32(15))
	}
	if wscount < int32(20) {
		return (-int32(19))
	}
	if length < int32(0) {
		return (-int32(32))
	}
	if (start_offset < int32(0)) || (start_offset > length) {
		return (-int32(24))
	}
	if uint32((pcre_uint32((*re).magic_number))) != uint32(1346589253) {
		return func() int32 {
			if uint32((pcre_uint32((*re).magic_number))) == uint32(1163019088) {
				return (-int32(29))
			} else {
				return (-int32(4))
			}
		}()
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		return (-int32(28))
	}
	if (options & int32(131072)) != int32(0) {
		if (((*workspace & -int32(2)) != int32(0)) || (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(1))*unsafe.Sizeof(*workspace)))) < int32(1))) || (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(workspace)) + (uintptr)(int32(1))*unsafe.Sizeof(*workspace)))) > ((wscount - int32(2)) / int32((16 / 4)))) {
			return (-int32(30))
		}
	}
	(*md).tables = (*re).tables
	(*md).callout_data = nil
	if extra_data != nil {
		var flags uint32 = (*extra_data).flags
		if (flags & uint32(int32(1))) != uint32(int32(0)) {
			study = (*pcre_study_data)((*extra_data).study_data)
		}
		if (flags & uint32(int32(2))) != uint32(int32(0)) {
			return (-int32(18))
		}
		if (flags & uint32(int32(16))) != uint32(int32(0)) {
			return (-int32(18))
		}
		if (flags & uint32(int32(4))) != uint32(int32(0)) {
			(*md).callout_data = (*extra_data).callout_data
		}
		if (flags & uint32(int32(8))) != uint32(int32(0)) {
			(*md).tables = (*pcre_uint8)(unsafe.Pointer((*extra_data).tables))
		}
	}
	current_subject = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(subject))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
	}()))
	end_subject = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(subject))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(length)*unsafe.Sizeof(*tempVar))
	}()))
	req_char_ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(int32(1))*unsafe.Sizeof(*current_subject))))
	utf = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(2048))))) != pcre_uint32((uint32(int32(0)))))]))
	anchored = BOOL((map[bool]int32{false: 0, true: 1}[(((options & (int32(16) | int32(131072))) != int32(0)) || ((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0))))))]))
	(*md).start_code = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*pcre_uchar)(unsafe.Pointer(argument_re))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
		}()))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint16((pcre_uint16((*re).name_count))))*int32(uint16((pcre_uint16((*re).name_entry_size))))))*unsafe.Sizeof(*tempVar))
	}()))
	(*md).start_subject = (*pcre_uchar)(unsafe.Pointer(subject))
	(*md).end_subject = end_subject
	(*md).start_offset = start_offset
	(*md).moptions = options
	(*md).poptions = int32(uint32((pcre_uint32((*re).options))))
	if ((*md).moptions & (int32(8388608) | int32(16777216))) == int32(0) {
		if (pcre_uint32((*re).options) & pcre_uint32((uint32((int32(8388608) | int32(16777216)))))) != pcre_uint32((uint32(int32(0)))) {
			(*md).moptions |= int32(uint32((pcre_uint32((*re).options) & pcre_uint32((uint32((int32(8388608) | int32(16777216))))))))
		}
	}
	switch func() uint32 {
		if (map[bool]int32{false: 0, true: 1}[((options & (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) == int32(0))]) != 0 {
			return uint32((pcre_uint32((*re).options)))
		} else {
			return uint32((pcre_uint32(options)))
		}
	}() & uint32((((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) {
	case uint32(int32(0)):
		{
			newline = int32(10)
		}
	case uint32(int32(1048576)):
		{
			newline = int32('\r')
		}
	case uint32(int32(2097152)):
		{
			newline = int32('\n')
		}
	case uint32((int32(1048576) + int32(2097152))):
		{
			newline = int32((('\r' << uint64(int32(8))) | '\n'))
		}
	case uint32(int32(4194304)):
		{
			newline = -int32(1)
		}
	case uint32(int32(5242880)):
		{
			newline = -int32(2)
		}
	default:
		{
			return (-int32(23))
		}
	}
	if newline == -int32(2) {
		(*md).nltype = int32(2)
	} else if newline < int32(0) {
		(*md).nltype = int32(1)
	} else {
		(*md).nltype = int32(0)
		if newline > int32(255) {
			(*md).nllen = int32(2)
			*&(*md).nl[0] = pcre_uchar((uint8(((newline >> uint64(int32(8))) & int32(255)))))
			*((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := &(*md).nl[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) = pcre_uchar((uint8((newline & int32(255)))))
		} else {
			(*md).nllen = int32(1)
			*&(*md).nl[0] = pcre_uchar((uint8(newline)))
		}
	}
	if (int32((utf)) != 0) && ((options & int32(8192)) == int32(0)) {
		var erroroffset int32
		var errorcode int32 = _pcre_valid_utf((*pcre_uchar)(unsafe.Pointer(subject)), length, &erroroffset)
		if errorcode != int32(0) {
			if offsetcount >= int32(2) {
				*offsets = erroroffset
				*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = errorcode
			}
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((errorcode <= int32(5)) && ((options & int32(134217728)) != int32(0)))]) != 0 {
					return (-int32(25))
				} else {
					return (-int32(10))
				}
			}()
		}
		if ((start_offset > int32(0)) && (start_offset < length)) && ((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(subject)))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
		}()))))) & int32(192)) == int32(128)) {
			return (-int32(11))
		}
	}
	if (*md).tables == nil {
		(*md).tables = &_pcre_default_tables[0]
	}
	startline = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(256))))) != pcre_uint32((uint32(int32(0)))))]))
	firstline = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(262144))))) != pcre_uint32((uint32(int32(0)))))]))
	if int32((NotBOOL(BOOL(anchored)))) != 0 {
		if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))) {
			has_first_char = BOOL((int32(1)))
			first_char2 = pcre_uchar(pcre_uint16(((*re).first_char)))
			first_char = first_char2
			if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(32))))) != pcre_uint32((uint32(int32(0)))) {
				first_char2 = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*md).tables
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(256))*unsafe.Sizeof(*tempVar))
					}()))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((first_char))))*unsafe.Sizeof(*tempVar))
				}()))))))
			}
		} else {
			if ((int32((NotBOOL(BOOL(startline)))) != 0) && (study != nil)) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0))))) {
				start_bits = &(*study).start_bits[0]
			}
		}
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(64))))) != pcre_uint32((uint32(int32(0)))) {
		has_req_char = BOOL((int32(1)))
		req_char2 = pcre_uchar(pcre_uint16(((*re).req_char)))
		req_char = req_char2
		if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(128))))) != pcre_uint32((uint32(int32(0)))) {
			req_char2 = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := ((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := (*md).tables
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(256))*unsafe.Sizeof(*tempVar))
				}()))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((req_char))))*unsafe.Sizeof(*tempVar))
			}()))))))
		}
	}
	for {
		var rc int32
		if (options & int32(131072)) == int32(0) {
			var save_end_subject *pcre_uchar = end_subject
			if int32((BOOL(firstline))) != 0 {
				var t *pcre_uchar = current_subject
				if int32((BOOL(utf))) != 0 {
					for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((t), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(t))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*t))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*t))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0) {
						t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
						for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*t))) & int32(192)) == int32(128)) {
							t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
						}
					}
				} else {
					for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (noarch.NotInt32((func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
							return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((t), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
						} else {
							return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(t))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
							}())))))) && (int32(uint8((*t))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*t))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := &(*md).nl[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))))))])
						}
					}())) != 0) {
						t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
					}
				}
				end_subject = t
			}
			if ((uint32(options) | uint32((pcre_uint32((*re).options)))) & uint32(int32(67108864))) == uint32(int32(0)) {
				if int32((BOOL(has_first_char))) != 0 {
					if int32(uint8((first_char))) != int32(uint8((first_char2))) {
						var csc pcre_uchar
						for ((int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((func() pcre_uchar {
							tempVar := *current_subject
							csc = tempVar
							return tempVar
						}()))) != int32(uint8((first_char))))) && (int32(uint8((csc))) != int32(uint8((first_char2)))) {
							current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
						}
					} else {
						for (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((*current_subject))) != int32(uint8((first_char)))) {
							current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
						}
					}
				} else if int32((BOOL(startline))) != 0 {
					if int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).start_subject
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
					}()))))) {
						if int32((BOOL(utf))) != 0 {
							for (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (noarch.NotInt32((func() int32 {
								if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
									return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((current_subject), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
								} else {
									return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(current_subject))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*md).start_subject
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
									}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(int32(uint8(((*md).nllen))))*unsafe.Sizeof(*current_subject))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(int32(uint8(((*md).nllen))))*unsafe.Sizeof(*current_subject) + (uintptr)(int32(1))*unsafe.Sizeof(*current_subject))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := &(*md).nl[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
									}()))))))))])
								}
							}())) != 0) {
								current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
								for (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*current_subject))) & int32(192)) == int32(128)) {
									current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
								}
							}
						} else {
							for (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (noarch.NotInt32((func() int32 {
								if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
									return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((current_subject), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
								} else {
									return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(current_subject))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*md).start_subject
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
									}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(int32(uint8(((*md).nllen))))*unsafe.Sizeof(*current_subject))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*current_subject) + (uintptr)(int32(1))*unsafe.Sizeof(*current_subject))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := &(*md).nl[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
									}()))))))))])
								}
							}())) != 0) {
								current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
							}
						}
						if (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(1)*unsafe.Sizeof(*current_subject))))))) == int32('\r')) && (((*md).nltype == int32(1)) || ((*md).nltype == int32(2)))) && (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject))))) && (int32(uint8((*current_subject))) == int32('\n')) {
							current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
						}
					}
				} else if start_bits != nil {
					for int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject))) {
						var c pcre_uint32 = pcre_uint32((uint32(uint8((*current_subject)))))
						if (int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*start_bits))))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0) {
							break
						}
						current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
					}
				}
			}
			end_subject = save_end_subject
			if (((uint32(options) | uint32((pcre_uint32((*re).options)))) & uint32(int32(67108864))) == uint32(int32(0))) && ((options & (int32(134217728) | int32(32768))) == int32(0)) {
				if ((study != nil) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(2))))) != pcre_uint32((uint32(int32(0)))))) && (pcre_uint32((int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(current_subject))))))) < pcre_uint32((*study).minlength)) {
					return (-int32(1))
				}
				if (int32((has_req_char)) != 0) && ((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(current_subject)))) < int64(int32(1000))) {
					var p *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(func() int32 {
						if int32((BOOL(has_first_char))) != 0 {
							return int32(1)
						} else {
							return int32(0)
						}
					}())*unsafe.Sizeof(*current_subject))))
					if int64(uintptr(unsafe.Pointer(p))) > int64(uintptr(unsafe.Pointer(req_char_ptr))) {
						if int32(uint8((req_char))) != int32(uint8((req_char2))) {
							for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(end_subject))) {
								var pp pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
									}()
									return p
								}())))))
								if (pp == pcre_uint32((uint32(uint8((req_char)))))) || (pp == pcre_uint32((uint32(uint8((req_char2)))))) {
									p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - (uintptr)(1)*unsafe.Sizeof(*p))))
									break
								}
							}
						} else {
							for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(end_subject))) {
								if int32(uint8((*func() *pcre_uchar {
									defer func() {
										p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
									}()
									return p
								}()))) == int32(uint8((req_char))) {
									p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - (uintptr)(1)*unsafe.Sizeof(*p))))
									break
								}
							}
						}
						if int64(uintptr(unsafe.Pointer(p))) >= int64(uintptr(unsafe.Pointer(end_subject))) {
							break
						}
						req_char_ptr = p
					}
				}
			}
		}
		(*md).start_used_ptr = current_subject
		(*md).recursive = nil
		rc = internal_dfa_exec(md, (*md).start_code, current_subject, start_offset, offsets, offsetcount, workspace, wscount, int32(0))
		if (rc != -int32(1)) || (int32((anchored)) != 0) {
			if (rc == -int32(12)) && (offsetcount >= int32(2)) {
				*offsets = (int32((int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
				*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
				if offsetcount > int32(2) {
					*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(2))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer(current_subject))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
				}
			}
			return rc
		}
		if (int32((firstline)) != 0) && (func() int32 {
			if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
				return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((current_subject), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
			} else {
				return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(current_subject))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*md).end_subject
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
				}())))))) && (int32(uint8((*current_subject))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*current_subject))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := &(*md).nl[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
				}()))))))))])
			}
		}() != 0) {
			break
		}
		current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
		if int32((BOOL(utf))) != 0 {
			for (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*current_subject))) & int32(192)) == int32(128)) {
				current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
			}
		}
		if int64(uintptr(unsafe.Pointer(current_subject))) > int64(uintptr(unsafe.Pointer(end_subject))) {
			break
		}
		if ((((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) - (uintptr)(1)*unsafe.Sizeof(*current_subject))))))) == int32('\r')) && (int64(uintptr(unsafe.Pointer(current_subject))) < int64(uintptr(unsafe.Pointer(end_subject))))) && (int32(uint8((*current_subject))) == int32('\n'))) && ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(2048))))) == pcre_uint32((uint32(int32(0)))))) && ((((*md).nltype == int32(1)) || ((*md).nltype == int32(2))) || ((*md).nllen == int32(2))) {
			current_subject = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(current_subject)) + (uintptr)(1)*unsafe.Sizeof(*current_subject))))
		}
	}
	return (-int32(1))
}

var rep_min []byte = []byte{byte(int32(0)), byte(int32(0)), byte(int32(1)), byte(int32(1)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(1)), byte(int32(0))}
var rep_max []byte = []byte{byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(1)), byte(int32(1)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(0)), byte(int32(1))}

// match_ref - transpiled function from  /root/Documents/pcre/pcre_exec.c:164
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2018 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains pcre_exec(), the externally visible function that does
pattern matching using an NFA algorithm, trying to mimic Perl as closely as
possible. There are also some static supporting functions. */ //
/* Undefine some potentially clashing cpp symbols */ //
/* The md->capture_last field uses the lower 16 bits for the last captured
substring (which can never be greater than 65535) and a bit in the top half
to mean "capture vector overflowed". This odd way of doing things was
implemented when it was realized that preserving and restoring the overflow bit
whenever the last capture number was saved/restored made for a neater
interface, and doing it this way saved on (a) another variable, which would
have increased the stack frame size (a big NO-NO in PCRE) and (b) another
separate set of save/restore instructions. The following defines are used in
implementing this. */ //
/* Values for setting in md->match_function_type to indicate two special types
of call to match(). We do it this way to save on using another stack variable,
as stack usage is to be discouraged. */ //
/* Non-error returns from the match() function. Error returns are externally
defined PCRE_ERROR_xxx codes, which are all negative. */ //
/* Special internal returns from the match() function. Make them sufficiently
negative to avoid the external error codes. */ //
/* The next 5 must be kept together and in sequence so that a test that checks
for any one of them can use a range. */ //
/* Maximum number of ints of offset to save on the stack for recursive calls.
If the offset vector is bigger, malloc is used. This should be a multiple of 3,
because the offset vector is always a multiple of 3 long. */ //
/* Min and max values for the common repeats; for the maxima, 0 => infinity */ //
/*************************************************
*          Match a back-reference                *
*************************************************/ //
/* Normally, if a back reference hasn't been set, the length that is passed is
negative, so the match always fails. However, in JavaScript compatibility mode,
the length passed is zero. Note that in caseless UTF-8 mode, the number of
subject bytes matched may be different to the number of reference bytes.

Arguments:
  offset      index into the offset vector
  eptr        pointer into the subject
  length      length of reference to be matched (number of bytes)
  md          points to match data block
  caseless    TRUE if caseless

Returns:      >= 0 the number of subject bytes matched
              -1 no match
              -2 partial match; always given if at end subject
*/ //
/* Always fail if reference not set (and not JavaScript compatible - in that
case the length is passed as zero). */ //
/* Separate the caseless case for speed. In UTF-8 mode we can only do this
properly if Unicode properties are supported. Otherwise, we can check only
ASCII characters. */ //
/* Match characters up to the end of the reference. NOTE: the number of
   data units matched may differ, because in UTF-8 there are some characters
   whose upper and lower case versions code have different numbers of bytes.
   For example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65
   (3 bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a
   sequence of two of the latter. It is important, therefore, to check the
   length along the reference, not along the subject (earlier code did this
   wrong). */ //
/* Partial match */ //
/* The same code works when not in UTF-8 mode and in UTF-8 mode when there
is no UCP support. */ //
/* Partial match */ //
/* In the caseful case, we can just compare the bytes, whether or not we
are in UTF-8 mode. */ //
/* Partial match */ //
//
func match_ref(offset int32, eptr *pcre_uchar, length int32, md *match_data, caseless BOOL) int32 {
	var eptr_start *pcre_uchar = eptr
	var p *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*md).start_subject
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(*((*int32)(func() unsafe.Pointer {
			tempVar := (*md).offset_vector
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
		}())))*unsafe.Sizeof(*tempVar))
	}()))
	var utf BOOL = BOOL((*md).utf)
	if length < int32(0) {
		return -int32(1)
	}
	if int32((BOOL(caseless))) != 0 {
		if int32((BOOL(utf))) != 0 {
			var endptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(length)*unsafe.Sizeof(*p))))
			for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(endptr))) {
				var c pcre_uint32
				var d pcre_uint32
				var ur *ucd_record
				if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					return -int32(2)
				}
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}())))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
					}
				}
				d = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}()
					return p
				}())))))
				if d >= pcre_uint32((uint32(int32(192)))) {
					if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
							}()
							return p
						}()))) & int32(63))))))
					} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63))))))
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))
					} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63))))))
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))
					} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))))) & int32(63))))))
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(4))*unsafe.Sizeof(*p))))
					} else {
						d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(4))*unsafe.Sizeof(*p))))))) & int32(63))))))
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(5))*unsafe.Sizeof(*p))))
					}
				}
				ur = ((*ucd_record)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_records[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage1[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((d)))))/int32(128)))*unsafe.Sizeof(*tempVar))
						}())))))*int32(128))+(int32(uint32((pcre_uint32((d)))))%int32(128))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*tempVar))
				}()))
				if (c != d) && (c != (d + pcre_uint32((uint32(int32((pcre_int32((*ur).other_case)))))))) {
					var pp *pcre_uint32 = ((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_caseless_sets[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*ur).caseset)))))*unsafe.Sizeof(*tempVar))
					}()))
					for {
						if c < *pp {
							return -int32(1)
						}
						if c == *func() *pcre_uint32 {
							defer func() {
								pp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pp)) + (uintptr)(1)*unsafe.Sizeof(*pp))))
							}()
							return pp
						}() {
							break
						}
					}
				}
			}
		} else {
			for func() int32 {
				defer func() {
					length -= 1
				}()
				return length
			}() > int32(0) {
				var cc pcre_uint32
				var cp pcre_uint32
				if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					return -int32(2)
				}
				cc = pcre_uint32((uint32(uint8((*eptr)))))
				cp = pcre_uint32((uint32(uint8((*p)))))
				if int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).lcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cp))))*unsafe.Sizeof(*tempVar))
				}()))))) != int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).lcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
				}()))))) {
					return -int32(1)
				}
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
				eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
			}
		}
	} else {
		for func() int32 {
			defer func() {
				length -= 1
			}()
			return length
		}() > int32(0) {
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				return -int32(2)
			}
			if int32(uint8((*func() *pcre_uchar {
				defer func() {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
				}()
				return p
			}()))) != int32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}()))) {
				return -int32(1)
			}
		}
	}
	return (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer(eptr_start))))))
}

const RM1 int32 = 1
const RM2 int32 = 2
const RM3 int32 = 3
const RM4 int32 = 4
const RM5 int32 = 5
const RM6 int32 = 6
const RM7 int32 = 7
const RM8 int32 = 8
const RM9 int32 = 9
const RM10 int32 = 10
const RM11 int32 = 11
const RM12 int32 = 12
const RM13 int32 = 13
const RM14 int32 = 14
const RM15 int32 = 15
const RM16 int32 = 16
const RM17 int32 = 17
const RM18 int32 = 18
const RM19 int32 = 19
const RM20 int32 = 20
const RM21 int32 = 21
const RM22 int32 = 22
const RM23 int32 = 23
const RM24 int32 = 24
const RM25 int32 = 25
const RM26 int32 = 26
const RM27 int32 = 27
const RM28 int32 = 28
const RM29 int32 = 29
const RM30 int32 = 30
const RM31 int32 = 31
const RM32 int32 = 32
const RM33 int32 = 33
const RM34 int32 = 34
const RM35 int32 = 35
const RM36 int32 = 36
const RM37 int32 = 37
const RM38 int32 = 38
const RM39 int32 = 39
const RM40 int32 = 40
const RM41 int32 = 41
const RM42 int32 = 42
const RM43 int32 = 43
const RM44 int32 = 44
const RM45 int32 = 45
const RM46 int32 = 46
const RM47 int32 = 47
const RM48 int32 = 48
const RM49 int32 = 49
const RM50 int32 = 50
const RM51 int32 = 51
const RM52 int32 = 52
const RM53 int32 = 53
const RM54 int32 = 54
const RM55 int32 = 55
const RM56 int32 = 56
const RM57 int32 = 57
const RM58 int32 = 58
const RM59 int32 = 59
const RM60 int32 = 60
const RM61 int32 = 61
const RM62 int32 = 62
const RM63 int32 = 63
const RM64 int32 = 64
const RM65 int32 = 65
const RM66 int32 = 66
const RM67 int32 = 67

// match - transpiled function from  /root/Documents/pcre/pcre_exec.c:512
/***************************************************************************
****************************************************************************
                   RECURSION IN THE match() FUNCTION

The match() function is highly recursive, though not every recursive call
increases the recursive depth. Nevertheless, some regular expressions can cause
it to recurse to a great depth. I was writing for Unix, so I just let it call
itself recursively. This uses the stack for saving everything that has to be
saved for a recursive call. On Unix, the stack can be large, and this works
fine.

It turns out that on some non-Unix-like systems there are problems with
programs that use a lot of stack. (This despite the fact that every last chip
has oodles of memory these days, and techniques for extending the stack have
been known for decades.) So....

There is a fudge, triggered by defining NO_RECURSE, which avoids recursive
calls by keeping local variables that need to be preserved in blocks of memory
obtained from malloc() instead instead of on the stack. Macros are used to
achieve this so that the actual code doesn't look very different to what it
always used to.

The original heap-recursive code used longjmp(). However, it seems that this
can be very slow on some operating systems. Following a suggestion from Stan
Switzer, the use of longjmp() has been abolished, at the cost of having to
provide a unique number for each call to RMATCH. There is no way of generating
a sequence of numbers at compile time in C. I have given them names, to make
them stand out more clearly.

Crude tests on x86 Linux show a small speedup of around 5-8%. However, on
FreeBSD, avoiding longjmp() more than halves the time taken to run the standard
tests. Furthermore, not using longjmp() means that local dynamic variables
don't have indeterminate values; this has meant that the frame size can be
reduced because the result can be "passed back" by straight setting of the
variable instead of being passed in the frame.
****************************************************************************
***************************************************************************/ //
/* Numbers for RMATCH calls. When this list is changed, the code at HEAP_RETURN
below must be updated in sync.  */ //
/* These versions of the macros use the stack, as normal. There are debugging
versions and production versions. Note that the "rw" argument of RMATCH isn't
actually used in this definition. */ //
/***************************************************************************
***************************************************************************/ //
/*************************************************
*         Match from current position            *
*************************************************/ //
/* This function is called recursively in many circumstances. Whenever it
returns a negative (error) response, the outer incarnation must also return the
same response. */ //
/* These macros pack up tests that are used for partial matching, and which
appear several times in the code. We set the "hit end" flag if the pointer is
at the end of the subject and also past the start of the subject (i.e.
something has been matched). For hard partial matching, we then return
immediately. The second one is used when we already know we are past the end of
the subject. */ //
/* Performance note: It might be tempting to extract commonly used fields from
the md structure (e.g. utf, end_subject) into individual variables to improve
performance. Tests using gcc on a SPARC disproved this; in the first case, it
made performance worse.

Arguments:
   eptr        pointer to current character in subject
   ecode       pointer to current position in compiled code
   mstart      pointer to the current match start position (can be modified
                 by encountering \K)
   offset_top  current top pointer
   md          pointer to "static" info for the match
   eptrb       pointer to chain of blocks containing eptr at start of
                 brackets - for testing for empty matches
   rdepth      the recursion depth

Returns:       MATCH_MATCH if matched            )  these values are >= 0
               MATCH_NOMATCH if failed to match  )
               a negative MATCH_xxx value for PRUNE, SKIP, etc
               a negative PCRE_ERROR_xxx value if aborted by an error condition
                 (e.g. stopped by repeated call or recursion limit)
*/ //
/* These variables do not need to be preserved over recursion in this function,
so they can be ordinary variables in all cases. Mark some of them with
"register" because they are used a lot in loops. */ //
/* Returns from recursive calls */ //
/* Used for loops not involving calls to RMATCH() */ //
/* Character values not kept over RMATCH() calls */ //
/* Local copy of UTF flag for speed */ //
/* Quantifier options */ //
/* When recursion is not being used, all "local" variables that have to be
preserved over calls to RMATCH() are part of a "frame". We set up the top-level
frame on the stack here; subsequent instantiations are obtained from the heap
whenever RMATCH() does a "recursion". See the macro definitions above. Putting
the top-level on the stack rather than malloc-ing them all gives a performance
boost in many cases where there is not much "recursion". */ //
/* Many of the following variables are used only in small blocks of the code.
My normal style of coding would have declared them within each of those blocks.
However, in order to accommodate the version of this code that uses an external
"stack" implemented on the heap, it is easier to declare them all here, so the
declarations can be cut out in a block. The only declarations within blocks
below are for variables that do not have to be preserved over a recursive call
to RMATCH(). */ //
/* There is a special fudge for calling match() in a way that causes it to
measure the size of its basic stack frame when the stack is being used for
recursion. The second argument (ecode) being NULL triggers this behaviour. It
cannot normally ever be NULL. The return is the negated value of the frame
size. */ //
/* To save space on the stack and in the heap frame, I have doubled up on some
of the local variables that are used only in localised parts of the code, but
still need to be preserved over recursive calls of match(). These macros define
the alternative names that are used. */ //
/* These statements are here to stop the compiler complaining about unitialized
variables. */ //
/* This label is used for tail recursion, which is used in a few cases even
when NO_RECURSE is not defined, in order to reduce the amount of stack that is
used. Thanks to Ian Taylor for noticing this possibility and sending the
original patch. */ //
/* OK, now we can get on with the real code of the function. Recursive calls
are specified by the macro RMATCH and RRETURN is used to return. When
NO_RECURSE is *not* defined, these just turn into a recursive call to match()
and a "return", respectively (possibly with some debugging if PCRE_DEBUG is
defined). However, RMATCH isn't like a function call because it's quite a
complicated macro. It has to be used in one particular way. This shouldn't,
however, impact performance when true recursion is being used. */ //
/* Local copy of the flag */ //
/* First check that we haven't called match() too many times, or that we
haven't exceeded the recursive call limit. */ //
/* At the start of a group with an unlimited repeat that may match an empty
string, the variable md->match_function_type is set to MATCH_CBEGROUP. It is
done this way to save having to use another function argument, which would take
up space on the stack. See also MATCH_CONDASSERT below.

When MATCH_CBEGROUP is set, add the current subject pointer to the chain of
such remembered pointers, to be checked when we hit the closing ket, in order
to break infinite loops that match no characters. When match() is called in
other circumstances, don't add to the chain. The MATCH_CBEGROUP feature must
NOT be used with tail recursion, because the memory block that is used is on
the stack, so a new one may be required for each match(). */ //
/* Now start processing the opcodes. */ //
/* In case previously set by assertion */ //
/* A return of MATCH_SKIP_ARG means that matching failed at SKIP with an
   argument, and we must check whether that argument matches this MARK's
   argument. It is passed back in md->start_match_ptr (an overloading of that
   variable). If it does match, we reset that variable to the current subject
   position and return MATCH_SKIP. Otherwise, pass back the return code
   unaltered. */ //
/* In case previously set by assertion */ //
/* Pass back current position */ //
/* Note that, for Perl compatibility, SKIP with an argument does NOT set
   nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
   not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
   that failed and any that precede it (either they also failed, or were not
   triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
   SKIP_ARG gets to top level, the match is re-run with md->ignore_skip_arg
   set to the count of the one that failed. */ //
/* Pass back the current skip name by overloading md->start_match_ptr and
   returning the special MATCH_SKIP_ARG return code. This will either be
   caught by a matching MARK, or get to the top, where it causes a rematch
   with md->ignore_skip_arg set to the value of md->skip_arg_count. */ //
/* For THEN (and THEN_ARG) we pass back the address of the opcode, so that
   the branch in which it occurs can be determined. Overload the start of
   match pointer to do this. */ //
/* In case previously set by assertion */ //
/* Handle an atomic group that does not contain any capturing parentheses.
   This can be handled like an assertion. Prior to 8.13, all atomic groups
   were handled this way. In 8.13, the code was changed as below for ONCE, so
   that backups pass through the group and thereby reset captured values.
   However, this uses a lot more stack, so in 8.20, atomic groups that do not
   contain any captures generate OP_ONCE_NC, which can be handled in the old,
   less stack intensive way.

   Check the alternative branches in turn - the matching won't pass the KET
   for this kind of subpattern. If any one branch matches, we carry on as at
   the end of a normal bracket, leaving the subject pointer, but resetting
   the start-of-match value in case it was changed by \K. */ //
/* Note: _not_ MATCH_ACCEPT */ //
/* If hit the end of the group (which could be repeated), fail */ //
/* Continue as from after the group, updating the offsets high water
   mark, since extracts may have been taken. */ //
/* For a non-repeating ket, just continue at this level. This also
   happens for a repeating ket if no characters were matched in the group.
   This is the forcible breaking of infinite loops as implemented in Perl
   5.005. */ //
/* The repeating kets try the rest of the pattern or restart from the
   preceding bracket, in the appropriate order. The second "call" of match()
   uses tail recursion, to avoid using another stack frame. */ //
/* OP_KETRMAX */ //
/* Control never gets here */ //
/* Handle a capturing bracket, other than those that are possessive with an
   unlimited repeat. If there is space in the offset vector, save the current
   subject position in the working slot at the top of the vector. We mustn't
   change the current values of the data slot, because they may be set from a
   previous iteration of this group, and be referred to by a reference inside
   the group. A failure to match might occur after the group has succeeded,
   if something later on doesn't match. For this reason, we need to restore
   the working value and also the values of the final offsets, in case they
   were set by a previous iteration of the same bracket.

   If there isn't enough space in the offset vector, treat this as if it were
   a non-capturing bracket. Don't worry about setting the flag for the error
   case here; that is handled in the code for KET. */ //
/* Backing up through an atomic group */ //
/* If we backed up to a THEN, check whether it is within the current
   branch by comparing the address of the THEN that is passed back with
   the end of the branch. If it is within the current branch, and the
   branch is one of two or more alternatives (it either starts or ends
   with OP_ALT), we have reached the limit of THEN's action, so convert
   the return code to NOMATCH, which will cause normal backtracking to
   happen from now on. Otherwise, THEN is passed back to an outer
   alternative. This implements Perl's treatment of parenthesized groups,
   where a group not containing | does not affect the current alternative,
   that is, (X) is NOT the same as (X|(*F)). */ //
/* Anything other than NOMATCH is passed back. */ //
/* At this point, rrc will be one of MATCH_ONCE or MATCH_NOMATCH. */ //
/* FALL THROUGH ... Insufficient room for saving captured contents. Treat
   as a non-capturing bracket. */ //
/* VVVVVVVVVVVVVVVVVVVVVVVVV */ //
/* VVVVVVVVVVVVVVVVVVVVVVVVV */ //
/* VVVVVVVVVVVVVVVVVVVVVVVVV */ //
/* VVVVVVVVVVVVVVVVVVVVVVVVV */ //
/* Non-capturing or atomic group, except for possessive with unlimited
   repeat and ONCE group with no captures. Loop for all the alternatives.

   When we get to the final alternative within the brackets, we used to return
   the result of a recursive call to match() whatever happened so it was
   possible to reduce stack usage by turning this into a tail recursion,
   except in the case of a possibly empty group. However, now that there is
   the possiblity of (*THEN) occurring in the final alternative, this
   optimization is no longer always possible.

   We can optimize if we know there are no (*THEN)s in the pattern; at present
   this is the best that can be done.

   MATCH_ONCE is returned when the end of an atomic group is successfully
   reached, but subsequent matching fails. It passes back up the tree (causing
   captured values to be reset) until the original atomic group level is
   reached. This is tested by comparing md->once_target with the start of the
   group. At this point, the return is converted into MATCH_NOMATCH so that
   previous backup points can be taken. */ //
/* If this is not a possibly empty group, and there are no (*THEN)s in
   the pattern, and this is the final alternative, optimize as described
   above. */ //
/* In all other cases, we have to make another call to match(). */ //
/* See comment in the code for capturing groups above about handling
   THEN. */ //
/* If not at start, find it */ //
/* Handle possessive capturing brackets with an unlimited repeat. We come
   here from BRAZERO with allow_zero set TRUE. The offset_vector values are
   handled similarly to the normal case above. However, the matching is
   different. The end of these brackets will always be OP_KETRPOS, which
   returns MATCH_KETRPOS without going further in the pattern. By this means
   we can handle the group by iteration rather than recursion, thereby
   reducing the amount of stack needed. */ //
/* Each time round the loop, save the current subject position for use
   when the group matches. For MATCH_MATCH, the group has matched, so we
   restart it with a new subject starting position, remembering that we had
   at least one match. For MATCH_NOMATCH, carry on with the alternatives, as
   usual. If we haven't matched any alternatives in any iteration, check to
   see if a previous iteration matched. If so, the group has matched;
   continue from afterwards. Otherwise it has failed; restore the previous
   capture values before returning NOMATCH. */ //
/* In case \K changed it */ //
/* Matched an empty string */ //
/* See comment in the code for capturing groups above about handling
   THEN. */ //
/* Non-capturing possessive bracket with unlimited repeat. We come here
   from BRAZERO with allow_zero = TRUE. The code is similar to the above,
   without the capturing complication. It is written out separately for speed
   and cleanliness. */ //
/* In case \K reset it */ //
/* Matched an empty string */ //
/* See comment in the code for capturing groups above about handling
   THEN. */ //
/* Control never reaches here. */ //
/* Conditional group: compilation checked that there are no more than two
   branches. If the condition is false, skipping the first branch takes us
   past the end of the item if there is only one branch, but that's exactly
   what we want. */ //
/* The variable codelink will be added to ecode when the condition is
   false, to get to the second branch. Setting it to the offset to the ALT
   or KET, then incrementing ecode achieves this effect. We now have ecode
   pointing to the condition or callout. */ //
/* Offset to the second branch */ //
/* From this opcode */ //
/* Because of the way auto-callout works during compile, a callout item is
   inserted between OP_COND and an assertion condition. */ //
/* Version 1 of the callout block */ //
/* Internal change requires this for API compatibility. */ //
/* Advance ecode past the callout, so it now points to the condition. We
   must adjust codelink so that the value of ecode+codelink is unchanged. */ //
/* Test the various possible conditions */ //
/* Numbered group recursion test */ //
/* Not recursing => FALSE */ //
/* Recursion group number*/ //
/* Duplicate named group recursion test */ //
/* Numbered group used test */ //
/* Doubled ref number */ //
/* Duplicate named group used test */ //
/* DEFINE - always false */ //
/* From optimized (?!) condition */ //
/* The condition is an assertion. Call match() to evaluate it - setting
   md->match_function_type to MATCH_CONDASSERT causes it to stop at the end
   of an assertion. */ //
/* Captures may have happened */ //
/* Advance ecode past the assertion to the start of the first branch,
   but adjust it so that the general choosing code below works. If the
   assertion has a quantifier that allows zero repeats we must skip over
   the BRAZERO. This is a lunatic thing to do, but somebody did! */ //
/* PCRE doesn't allow the effect of (*THEN) to escape beyond an
   assertion; it is therefore treated as NOMATCH. Any other return is an
   error. */ //
/* Need braces because of following else */ //
/* Choose branch according to the condition */ //
/* We are now at the branch that is to be obeyed. As there is only one, we
   can use tail recursion to avoid using another stack frame, except when
   there is unlimited repeat of a possibly empty group. In the latter case, a
   recursive call to match() is always required, unless the second alternative
   doesn't exist, in which case we can just plough on. Note that, for
   compatibility with Perl, the | in a conditional group is NOT treated as
   creating two alternatives. If a THEN is encountered in the branch, it
   propagates out to the enclosing alternative (unless nested in a deeper set
   of alternatives, of course). */ //
/* Condition false & no alternative; continue after the group. */ //
/* Before OP_ACCEPT there may be any number of OP_CLOSE opcodes,
   to close any currently open capturing brackets. */ //
/* Must be less than 65536 */ //
/* If this group is at or above the current highwater mark, ensure that
   any groups between the current high water mark and this group are marked
   unset and then update the high water mark. */ //
/* End of the pattern, either real or forced. */ //
/* If we have matched an empty string, fail if not in an assertion and not
   in a recursion if either PCRE_NOTEMPTY is set, or if PCRE_NOTEMPTY_ATSTART
   is set and we have matched at the start of the subject. In both cases,
   backtracking will then try other alternatives, if any. */ //
/* Otherwise, we have a match. */ //
/* Record where we ended */ //
/* and how many extracts were taken */ //
/* and the start (\K can modify) */ //
/* For some reason, the macros don't work properly if an expression is
   given as the argument to RRETURN when the heap is in use. */ //
/* Assertion brackets. Check the alternative branches in turn - the
   matching won't pass the KET for an assertion. If any one branch matches,
   the assertion is true. Lookbehind assertions have an OP_REVERSE item at the
   start of each branch to move the current point backwards, so the code at
   this level is identical to the lookahead case. When the assertion is part
   of a condition, we want to return immediately afterwards. The caller of
   this incarnation of the match() function will have set MATCH_CONDASSERT in
   md->match_function type, and one of these opcodes will be the first opcode
   that is processed. We use a local variable that is preserved over calls to
   match() to remember this case. */ //
/* Loop for each branch */ //
/* A match means that the assertion is true; break out of the loop
   that matches its alternatives. */ //
/* In case \K reset it */ //
/* If not matched, restore the previous mark setting. */ //
/* See comment in the code for capturing groups above about handling
   THEN. */ //
/* Anything other than NOMATCH causes the entire assertion to fail,
   passing back the return code. This includes COMMIT, SKIP, PRUNE and an
   uncaptured THEN, which means they take their normal effect. This
   consistent approach does not always have exactly the same effect as in
   Perl. */ //
/* Continue for next alternative */ //
/* If we have tried all the alternative branches, the assertion has
   failed. If not, we broke out after a match. */ //
/* If checking an assertion for a condition, return MATCH_MATCH. */ //
/* Continue from after a successful assertion, updating the offsets high
   water mark, since extracts may have been taken during the assertion. */ //
/* Negative assertion: all branches must fail to match for the assertion to
   succeed. */ //
/* Loop for each alternative branch. */ //
/* Always restore the mark setting */ //
/* A successful match means */ //
/* the assertion has failed. */ //
/* Carry on with next branch */ //
/* See comment in the code for capturing groups above about handling
   THEN. */ //
/* Otherwise fall through. */ //
/* COMMIT, SKIP, PRUNE, and an uncaptured THEN cause the whole
   assertion to fail to match, without considering any more alternatives.
   Failing to match means the assertion is true. This is a consistent
   approach, but does not always have the same effect as in Perl. */ //
/* Break out of alternation loop */ //
/* Anything else is an error */ //
/* Continue with next branch */ //
/* All branches in the assertion failed to match. */ //
/* Condition assertion */ //
/* Continue with current branch */ //
/* Move the subject pointer back. This occurs only at the start of
   each branch of a lookbehind assertion. If we are too close to the start to
   move back, this match function fails. When working with UTF-8 we move
   back a number of characters, not bytes. */ //
/* No UTF-8 support, or not in UTF-8 mode: count is byte count */ //
/* Save the earliest consulted character, then skip to next op code */ //
/* The callout item calls an external function, if one is provided, passing
   details of the match so far. This is mainly for debugging, though the
   function is able to force a failure. */ //
/* Version 1 of the callout block */ //
/* Internal change requires this for API compatibility. */ //
/* Recursion either matches the current regex, or some subexpression. The
   offset data is the offset to the starting bracket from the start of the
   whole pattern. (This is so that it works from duplicated subpatterns.)

   The state of the capturing groups is preserved over recursion, and
   re-instated afterwards. We don't know how many are started and not yet
   finished (offset_top records the completed total) so we just have to save
   all the potential data. There may be up to 65535 such values, which is too
   large to put on the stack, but using malloc for small numbers seems
   expensive. As a compromise, the stack is used when there are no more than
   REC_STACK_SAVE_MAX values to store; otherwise malloc is used.

   There are also other values that have to be saved. We use a chained
   sequence of blocks that actually live on the stack. Thanks to Robin Houston
   for the original version of this logic. It has, however, been hacked around
   a lot, so he is not to blame for the current way it works. */ //
/* Check for repeating a recursion without advancing the subject pointer.
   This should catch convoluted mutual recursions. (Some simple cases are
   caught at compile time.) */ //
/* Add to "recursing stack" */ //
/* Where to continue from afterwards */ //
/* Now save the offset data */ //
/* OK, now we can do the recursion. After processing each alternative,
   restore the offset data and the last captured value. If there were nested
   recursions, md->recursive might be changed, so reset it before looping.
*/ //
/* Set where we got to in the subject, and reset the start in case
   it was changed by \K. This *is* propagated back out of a recursion,
   for Perl compatibility. */ //
/* Exit loop; end processing */ //
/* PCRE does not allow THEN, SKIP, PRUNE or COMMIT to escape beyond a
   recursion; they cause a NOMATCH for the entire recursion. These codes
   are defined in a range that can be tested for. */ //
/* Any return code other than NOMATCH is an error. */ //
/* An alternation is the end of a branch; scan along to find the end of the
   bracketed group and go to there. */ //
/* BRAZERO, BRAMINZERO and SKIPZERO occur just before a bracket group,
   indicating that it may occur zero times. It may repeat infinitely, or not
   at all - i.e. it could be ()* or ()? or even (){0} in the pattern. Brackets
   with fixed upper repeat limits are compiled as a number of copies, with the
   optional ones preceded by BRAZERO or BRAMINZERO. */ //
/* BRAPOSZERO occurs before a possessive bracket group. Don't do anything
   here; just jump to the group, with allow_zero set TRUE. */ //
/* End of a group, repeated or non-repeating. */ //
/* If this was a group that remembered the subject start, in order to break
   infinite repeats of empty string matches, retrieve the subject start from
   the chain. Otherwise, set it NULL. */ //
/* Value at start of group */ //
/* Backup to previous group */ //
/* If we are at the end of an assertion group or a non-capturing atomic
   group, stop matching and return MATCH_MATCH, but record the current high
   water mark for use by positive assertions. We also need to record the match
   start in case it was changed by \K. */ //
/* For ONCE_NC */ //
/* Sets md->mark */ //
/* For capturing groups we have to check the group number back at the start
   and if necessary complete handling an extraction by setting the offsets and
   bumping the high water mark. Whole-pattern recursion is coded as a recurse
   into group 0, so it won't be picked up here. Instead, we catch it when the
   OP_END is reached. Other recursion is handled here. We just have to record
   the current subject position and start match pointer and give a MATCH
   return. */ //
/* Handle a recursively called group. */ //
/* Deal with capturing */ //
/* If offset is greater than offset_top, it means that we are
   "skipping" a capturing group, and that group's offsets must be marked
   unset. In earlier versions of PCRE, all the offsets were unset at the
   start of matching, but this doesn't work because atomic groups and
   assertions can cause a value to be set that should later be unset.
   Example: matching /(?>(a))b|(a)c/ against "ac". This sets group 1 as
   part of the atomic group, but this is not on the final matching path,
   so must be unset when 2 is set. (If there is no group 2, there is no
   problem, because offset_top will then be 2, indicating no capture.) */ //
/* Now make the extraction */ //
/* OP_KETRPOS is a possessive repeating ket. Remember the current position,
   and return the MATCH_KETRPOS. This makes it possible to do the repeats one
   at a time from the outer level, thus saving stack. This must precede the
   empty string test - in this case that test is done at the outer level. */ //
/* In case \K reset it */ //
/* For an ordinary non-repeating ket, just continue at this level. This
   also happens for a repeating ket if no characters were matched in the
   group. This is the forcible breaking of infinite loops as implemented in
   Perl 5.005. For a non-repeating atomic group that includes captures,
   establish a backup point by processing the rest of the pattern at a lower
   level. If this results in a NOMATCH return, pass MATCH_ONCE back to the
   original OP_ONCE level, thereby bypassing intermediate backup points, but
   resetting any captures that happened along the way. */ //
/* Level at which to change to MATCH_NOMATCH */ //
/* Carry on at this level */ //
/* The normal repeating kets try the rest of the pattern or restart from
   the preceding bracket, in the appropriate order. In the second case, we can
   use tail recursion to avoid using another stack frame, unless we have an
   an atomic group or an unlimited repeat of a group that can match an empty
   string. */ //
/* Level at which to change to MATCH_NOMATCH */ //
/* Could match an empty string */ //
/* OP_KETRMAX */ //
/* Control never gets here */ //
/* Not multiline mode: start of subject assertion, unless notbol. */ //
/* Start of subject assertion */ //
/* Multiline mode: start of subject unless notbol, or after any newline. */ //
/* Start of match assertion */ //
/* Reset the start of match point */ //
/* Multiline mode: assert before any newline, or before end of subject
   unless noteol is set. */ //
/* Not multiline mode: assert before a terminating newline or before end of
   subject unless noteol is set. */ //
/* ... else fall through for endonly */ //
/* End of subject assertion (\z) */ //
/* End of subject or ending \n assertion (\Z) */ //
/* Either at end of string or \n before end. */ //
/* Word boundary assertions */ //
/* Find out if the previous and current characters are "word" characters.
   It takes a bit more work in UTF-8 mode. Characters > 255 are assumed to
   be "non-word" characters. Remember the earliest consulted character for
   partial matching. */ //
/* Get status of previous character */ //
/* Get status of next character */ //
/* Not in UTF-8 mode, but we may still have PCRE_UCP set, and for
   consistency with the behaviour of \w we do use it in this case. */ //
/* Get status of previous character */ //
/* Get status of next character */ //
/* Now see if the situation is what we want */ //
/* Match any single character type except newline; have to take care with
   CRLF newlines and partial matching. */ //
/* Fall through */ //
/* Match any single character whatsoever. */ //
/* DO NOT merge the eptr++ here; it must */ //
/* not be updated before SCHECK_PARTIAL. */ //
/* Match a single byte, even in UTF-8 mode. This opcode really does match
   any byte, even newline, independent of the setting of PCRE_DOTALL. */ //
/* DO NOT merge the eptr++ here; it must */ //
/* not be updated before SCHECK_PARTIAL. */ //
/* Byte and multibyte cases */ //
/* Byte and multibyte cases */ //
/* Check the next character by Unicode property. We will get here only
   if the support is in the binary; otherwise a compile-time error occurs. */ //
/* These are specials */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* This should never occur */ //
/* Match an extended Unicode sequence. We will get here only if the support
   is in the binary; otherwise a compile-time error occurs. */ //
/* Match a back reference, possibly repeatedly. Look past the end of the
   item to see if there is repeat information following. The code is similar
   to that for character classes, but repeated for efficiency. Then obey
   similar code to character type repeats - written out again for speed.
   However, if the referenced string is the empty string, always treat
   it as matched, any number of times (otherwise there could be infinite
   loops). If the reference is unset, there are two possibilities:

   (a) In the default, Perl-compatible state, set the length negative;
   this ensures that every attempt at a match fails. We can't just fail
   here, because of the possibility of quantifiers with zero minima.

   (b) If the JavaScript compatibility flag is set, set the length to zero
   so that the back reference matches an empty string.

   Otherwise, set the length to the length of what was matched by the
   referenced subpattern.

   The OP_REF and OP_REFI opcodes are used for a reference to a numbered group
   or to a non-duplicated named group. For a duplicated named group, OP_DNREF
   and OP_DNREFI are used. In this case we must scan the list of groups to
   which the name refers, and use the first one that is set. */ //
/* Setting the default length first and initializing 'offset' avoids
   compiler warnings in the REF_REPEAT code. */ //
/* Doubled ref number */ //
/* Set up for repetition, or handle the non-repeated case */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* No repeat follows */ //
/* Partial match */ //
/* With the main loop */ //
/* Handle repeated back references. If the length of the reference is
   zero, just continue with the main loop. If the length is negative, it
   means the reference is unset in non-Java-compatible mode. If the minimum is
   zero, we can continue at the same level without recursion. For any other
   minimum, carrying on will result in NOMATCH. */ //
/* First, ensure the minimum number of matches are present. We get back
   the length of the reference string explicitly rather than passing the
   address of eptr, so that eptr can be a register variable. */ //
/* Partial match */ //
/* If min = max, continue at the same level without recursion.
   They are not both allowed to be zero. */ //
/* If minimizing, keep trying and advancing the pointer */ //
/* Partial match */ //
/* Control never gets here */ //
/* If maximizing, find the longest string and work backwards */ //
/* Can't use CHECK_PARTIAL because we don't want to update eptr in
   the soft partial matching case. */ //
/* Control never gets here */ //
/* Match a bit-mapped character class, possibly repeatedly. This op code is
   used when all the characters in the class have values in the range 0-255,
   and either the matching is caseful, or the characters are in the range
   0-127 when UTF-8 processing is enabled. The only difference between
   OP_CLASS and OP_NCLASS occurs when a data character outside the range is
   encountered.

   First, look past the end of the item to see if there is repeat information
   following. Then obey similar code to character type repeats - written out
   again for speed. */ //
/* The data variable is saved across frames, so the byte map needs to
   be stored there. */ //
/* Save for matching */ //
/* Advance past the item */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* No repeat follows */ //
/* First, ensure the minimum number of matches are present. */ //
/* Not UTF mode */ //
/* If max == min we can continue with the main loop without the
   need to recurse. */ //
/* If minimizing, keep testing the rest of the expression and advancing
   the pointer while it matches the class. */ //
/* Not UTF mode */ //
/* Control never gets here */ //
/* If maximizing, find the longest possible run, then work backwards. */ //
/* No backtracking */ //
/* Stop if tried at original pos */ //
/* Not UTF mode */ //
/* No backtracking */ //
/* Control never gets here */ //
/* Match an extended character class. In the 8-bit library, this opcode is
   encountered only when UTF-8 mode mode is supported. In the 16-bit and
   32-bit libraries, codepoints greater than 255 may be encountered even when
   UTF is not supported. */ //
/* Save for matching */ //
/* Advance past the item */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* No repeat follows */ //
/* First, ensure the minimum number of matches are present. */ //
/* If max == min we can continue with the main loop without the
   need to recurse. */ //
/* If minimizing, keep testing the rest of the expression and advancing
   the pointer while it matches the class. */ //
/* Control never gets here */ //
/* If maximizing, find the longest possible run, then work backwards. */ //
/* No backtracking */ //
/* Stop if tried at original pos */ //
/* Control never gets here */ //
/* Match a single character, casefully */ //
/* Not SCHECK_PARTIAL() */ //
/* Not UTF mode */ //
/* This one can use SCHECK_PARTIAL() */ //
/* Match a single character, caselessly. If we are at the end of the
   subject, give up immediately. */ //
/* If the pattern character's value is < 128, we have only one byte, and
   we know that its other case must also be one byte long, so we can use the
   fast lookup table. We know that there is at least one byte left in the
   subject. */ //
/* Otherwise we must pick up the subject character. Note that we cannot
   use the value of "length" to check for sufficient bytes left, because the
   other case of the character may have more or fewer bytes.  */ //
/* If we have Unicode property support, we can use it to test the other
   case of the character, if there is one. */ //
/* Not UTF mode */ //
/* Match a single character repeatedly. */ //
/* Fall through */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* Common code for all repeated single-character matches. We first check
   for the minimum number of characters. If the minimum equals the maximum, we
   are done. Otherwise, if minimizing, check the rest of the pattern for a
   match; if there isn't one, advance up to the maximum, one character at a
   time.

   If maximizing, advance up to the maximum number of matching characters,
   until eptr is past the end of the maximum run. If possessive, we are
   then done (no backing up). Otherwise, match at this position; anything
   other than no match is immediately returned. For nomatch, back up one
   character, unless we are matching \R and the last thing matched was
   \r\n, in which case, back up two bytes. When we reach the first optional
   character position, we can save stack by doing a tail recurse.

   The various UTF/non-UTF and caseful/caseless cases are handled separately,
   for speed. */ //
/* Handle multibyte character matching specially here. There is
   support for caseless matching if UCP support is present. */ //
/* Caseless */ //
/* Control never gets here */ //
/* Maximize */ //
/* No backtracking */ //
/* Control never gets here */ //
/* If the length of a UTF-8 character is 1, we fall through here, and
   obey the code as for non-UTF-8 characters below, though in this case the
   value of fc will always be < 128. */ //
/* When not in UTF-8 mode, load a single-byte character. */ //
/* The value of fc at this point is always one character, though we may
   or may not be in UTF mode. The code is duplicated for the caseless and
   caseful cases, for speed, since matching characters is likely to be quite
   common. First, ensure the minimum number of matches are present. If min =
   max, continue at the same level without recursing. Otherwise, if
   minimizing, keep trying the rest of the expression and advancing one
   matching character if failing, up to the maximum. Alternatively, if
   maximizing, find the maximum number of characters and work backwards. */ //
/* Caseless */ //
/* fc must be < 128 if UTF is enabled. */ //
/* Faster than pcre_uchar */ //
/* Faster than pcre_uchar */ //
/* Control never gets here */ //
/* Maximize */ //
/* Faster than pcre_uchar */ //
/* No backtracking */ //
/* Control never gets here */ //
/* Caseful comparisons (includes all multi-byte characters) */ //
/* Control never gets here */ //
/* Maximize */ //
/* No backtracking */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Match a negated single one-byte character. The character we are
   checking can be multibyte. */ //
/* Match a negated single one-byte character repeatedly. This is almost a
   repeat of the code for a repeated single character, but I haven't found a
   nice way of commoning these up that doesn't require a test of the
   positive/negative option for each character match. Maybe that wouldn't add
   very much to the time taken, but character matching *is* what this is all
   about... */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* Common code for all repeated single-byte matches. */ //
/* The code is duplicated for the caseless and caseful cases, for speed,
   since matching characters is likely to be quite common. First, ensure the
   minimum number of matches are present. If min = max, continue at the same
   level without recursing. Otherwise, if minimizing, keep trying the rest of
   the expression and advancing one matching character if failing, up to the
   maximum. Alternatively, if maximizing, find the maximum number of
   characters and work backwards. */ //
/* Caseless */ //
/* Not UTF mode */ //
/* Not UTF mode */ //
/* Control never gets here */ //
/* Maximize case */ //
/* No backtracking */ //
/* Not UTF mode */ //
/* No backtracking */ //
/* Control never gets here */ //
/* Caseful comparisons */ //
/* Not UTF mode */ //
/* Not UTF mode */ //
/* Control never gets here */ //
/* Maximize case */ //
/* No backtracking */ //
/* Not UTF mode */ //
/* No backtracking */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Match a single character type repeatedly; several different opcodes
   share code. This is very similar to the code for single characters, but we
   repeat it in the interests of efficiency. */ //
/* Pick up values from tables; */ //
/* zero for max => infinity */ //
/* Common code for all repeated single character type matches. Note that
   in UTF-8 mode, '.' matches a character of any length, but for the other
   character types, the valid characters are all one-byte long. */ //
/* Code for the character type */ //
/* First, ensure the minimum number of matches are present. Use inline
   code for maximizing the speed, and do the type test once at the start
   (i.e. keep it out of the loop). Separate the UTF-8 code completely as that
   is tidier. Also separate the UCP code, which can be the same for both UTF-8
   and single-bytes. */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* This should not occur */ //
/* Match extended Unicode sequences. We will get here only if the
   support is in the binary; otherwise a compile-time error occurs. */ //
/* Handle all other cases when the coding is UTF-8 */ //
/* Byte and multibyte cases */ //
/* Byte and multibyte cases */ //
/* No need to skip more bytes - we know it's a 1-byte character */ //
/* No need to skip more bytes - we know it's a 1-byte character */ //
/* No need to skip more bytes - we know it's a 1-byte character */ //
/* End switch(ctype) */ //
/* Code for the non-UTF-8 case for minimum matching of operators other
   than OP_PROP and OP_NOTPROP. */ //
/* If min = max, continue at the same level without recursing */ //
/* If minimizing, we have to test the rest of the pattern before each
   subsequent match. Again, separate the UTF-8 case for speed, and also
   separate the UCP cases. */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* Control never gets here */ //
/* This should never occur */ //
/* Match extended Unicode sequences. We will get here only if the
   support is in the binary; otherwise a compile-time error occurs. */ //
/* This is the non-NL case */ //
/* Take care with CRLF partial */ //
/* Not UTF mode */ //
/* This is the non-NL case */ //
/* Take care with CRLF partial */ //
/* Control never gets here */ //
/* If maximizing, it is worth using inline code for speed, doing the type
   test once at the start (i.e. keep it out of the loop). Again, keep the
   UTF-8 and UCP stuff separate. */ //
/* Remember where we started */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* Break the loop */ //
/* Break the loop */ //
/* eptr is now past the end of the maximum run */ //
/* No backtracking */ //
/* Match extended Unicode grapheme clusters. We will get here only if the
   support is in the binary; otherwise a compile-time error occurs. */ //
/* eptr is now past the end of the maximum run */ //
/* No backtracking */ //
/* We use <= pp rather than == pp to detect the start of the run while
   backtracking because the use of \C in UTF mode can cause BACKCHAR to
   move back past pp. This is just palliative; the use of \C in UTF mode
   is fraught with danger. */ //
/* At start of char run */ //
/* Backtracking over an extended grapheme cluster involves inspecting
   the previous two characters (if present) to see if a break is
   permitted between them. */ //
/* At start of char run */ //
/* Take care with CRLF partial */ //
/* Unlimited UTF-8 repeat */ //
/* The byte case is the same as non-UTF8 */ //
/* No backtracking */ //
/* Not UTF mode */ //
/* Take care with CRLF partial */ //
/* No backtracking */ //
/* Control never gets here */ //
/* There's been some horrible disaster. Arrival here can only mean there is
   something seriously wrong in the code above or the OP_xxx definitions. */ //
/* Do not stick any code in here without much thought; it is assumed
that "continue" in the code above comes out to here to repeat the main
loop. */ //
/* End of main loop */ //
/* Control never reaches here */ //
/* When compiling to use the heap rather than the stack for recursive calls to
match(), the RRETURN() macro jumps here. The number that is saved in
frame->Xwhere indicates which label we actually want to return to. */ //
//
func match(eptr *pcre_uchar, ecode *pcre_uchar, mstart *pcre_uchar, offset_top int32, md *match_data, eptrb *eptrblock, rdepth uint32) (c2goDefaultReturn int32) {
	var rrc int32
	var i int32
	var c pcre_uint32
	var utf BOOL
	var minimize BOOL
	var possessive BOOL
	var caseless BOOL
	var condcode int32
	var charptr *pcre_uchar
	var callpat *pcre_uchar
	var data *pcre_uchar
	var next *pcre_uchar
	var pp *pcre_uchar
	var prev *pcre_uchar
	var saved_eptr *pcre_uchar
	var new_recursive recursion_info
	var cur_is_word BOOL
	var condition BOOL
	var prev_is_word BOOL
	var prop_type int32
	var prop_value uint32
	var prop_fail_result int32
	var oclength int32
	var occhars []pcre_uchar = make([]pcre_uchar, 6, 6)
	var codelink int32
	var ctype int32
	var length int32
	var max int32
	var min int32
	var number uint32
	var offset int32
	var op uint32
	var save_capture_last pcre_int32
	var save_offset1 int32
	var save_offset2 int32
	var save_offset3 int32
	var stacksave []int32 = make([]int32, 30, 30)
	var newptrb eptrblock
	if ecode == nil {
		if rdepth == uint32(int32(0)) {
			return match((*pcre_uchar)(unsafe.Pointer(&rdepth)), nil, nil, int32(0), nil, nil, uint32(int32(1)))
		} else {
			var len int32 = (int32((int64(uintptr(unsafe.Pointer((*byte)(unsafe.Pointer(&rdepth))))) - int64(uintptr(unsafe.Pointer((*byte)(unsafe.Pointer(eptr))))))))
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(len > int32(0))]) != 0 {
					return -len
				} else {
					return len
				}
			}()
		}
	}
	prop_value = uint32(int32(0))
	prop_fail_result = int32(0)
TAIL_RECURSE:
	;
	utf = BOOL((*md).utf)
	if func() uint32 {
		tempVar := &(*md).match_call_count
		defer func() {
			*tempVar += 1
		}()
		return *tempVar
	}() >= (*md).match_limit {
		return (-int32(8))
	}
	if rdepth >= (*md).match_limit_recursion {
		return (-int32(21))
	}
	if (*md).match_function_type == int32(2) {
		newptrb.epb_saved_eptr = eptr
		newptrb.epb_prev = eptrb
		eptrb = &newptrb
		(*md).match_function_type = int32(0)
	}
	for {
		possessive = BOOL((int32(0)))
		minimize = possessive
		op = uint32(uint8((*ecode)))
		switch op {
		case uint32(OP_MARK):
			goto SW_GENERATED_LABEL_395
		case uint32(OP_FAIL):
			goto SW_GENERATED_LABEL_396
		case uint32(OP_COMMIT):
			goto SW_GENERATED_LABEL_397
		case uint32(OP_PRUNE):
			goto SW_GENERATED_LABEL_398
		case uint32(OP_PRUNE_ARG):
			goto SW_GENERATED_LABEL_399
		case uint32(OP_SKIP):
			goto SW_GENERATED_LABEL_400
		case uint32(OP_SKIP_ARG):
			goto SW_GENERATED_LABEL_401
		case uint32(OP_THEN):
			goto SW_GENERATED_LABEL_402
		case uint32(OP_THEN_ARG):
			goto SW_GENERATED_LABEL_403
		case uint32(OP_ONCE_NC):
			goto SW_GENERATED_LABEL_404
		case uint32(OP_CBRA):
			goto SW_GENERATED_LABEL_405
		case uint32(OP_SCBRA):
			goto SW_GENERATED_LABEL_406
		case uint32(OP_ONCE):
			goto SW_GENERATED_LABEL_407
		case uint32(OP_BRA):
			goto SW_GENERATED_LABEL_408
		case uint32(OP_SBRA):
			goto SW_GENERATED_LABEL_409
		case uint32(OP_CBRAPOS):
			goto SW_GENERATED_LABEL_410
		case uint32(OP_SCBRAPOS):
			goto SW_GENERATED_LABEL_411
		case uint32(OP_BRAPOS):
			goto SW_GENERATED_LABEL_412
		case uint32(OP_SBRAPOS):
			goto SW_GENERATED_LABEL_413
		case uint32(OP_COND):
			goto SW_GENERATED_LABEL_414
		case uint32(OP_SCOND):
			goto SW_GENERATED_LABEL_415
		case uint32(OP_CLOSE):
			goto SW_GENERATED_LABEL_416
		case uint32(OP_END):
			goto SW_GENERATED_LABEL_417
		case uint32(OP_ACCEPT):
			goto SW_GENERATED_LABEL_418
		case uint32(OP_ASSERT_ACCEPT):
			goto SW_GENERATED_LABEL_419
		case uint32(OP_ASSERT):
			goto SW_GENERATED_LABEL_420
		case uint32(OP_ASSERTBACK):
			goto SW_GENERATED_LABEL_421
		case uint32(OP_ASSERT_NOT):
			goto SW_GENERATED_LABEL_422
		case uint32(OP_ASSERTBACK_NOT):
			goto SW_GENERATED_LABEL_423
		case uint32(OP_REVERSE):
			goto SW_GENERATED_LABEL_424
		case uint32(OP_CALLOUT):
			goto SW_GENERATED_LABEL_425
		case uint32(OP_RECURSE):
			goto SW_GENERATED_LABEL_426
		case uint32(OP_ALT):
			goto SW_GENERATED_LABEL_427
		case uint32(OP_BRAZERO):
			goto SW_GENERATED_LABEL_428
		case uint32(OP_BRAMINZERO):
			goto SW_GENERATED_LABEL_429
		case uint32(OP_SKIPZERO):
			goto SW_GENERATED_LABEL_430
		case uint32(OP_BRAPOSZERO):
			goto SW_GENERATED_LABEL_431
		case uint32(OP_KET):
			goto SW_GENERATED_LABEL_432
		case uint32(OP_KETRMIN):
			goto SW_GENERATED_LABEL_433
		case uint32(OP_KETRMAX):
			goto SW_GENERATED_LABEL_434
		case uint32(OP_KETRPOS):
			goto SW_GENERATED_LABEL_435
		case uint32(OP_CIRC):
			goto SW_GENERATED_LABEL_436
		case uint32(OP_SOD):
			goto SW_GENERATED_LABEL_437
		case uint32(OP_CIRCM):
			goto SW_GENERATED_LABEL_438
		case uint32(OP_SOM):
			goto SW_GENERATED_LABEL_439
		case uint32(OP_SET_SOM):
			goto SW_GENERATED_LABEL_440
		case uint32(OP_DOLLM):
			goto SW_GENERATED_LABEL_441
		case uint32(OP_DOLL):
			goto SW_GENERATED_LABEL_442
		case uint32(OP_EOD):
			goto SW_GENERATED_LABEL_443
		case uint32(OP_EODN):
			goto SW_GENERATED_LABEL_444
		case uint32(OP_NOT_WORD_BOUNDARY):
			goto SW_GENERATED_LABEL_445
		case uint32(OP_WORD_BOUNDARY):
			goto SW_GENERATED_LABEL_446
		case uint32(OP_ANY):
			goto SW_GENERATED_LABEL_447
		case uint32(OP_ALLANY):
			goto SW_GENERATED_LABEL_448
		case uint32(OP_ANYBYTE):
			goto SW_GENERATED_LABEL_449
		case uint32(OP_NOT_DIGIT):
			goto SW_GENERATED_LABEL_450
		case uint32(OP_DIGIT):
			goto SW_GENERATED_LABEL_451
		case uint32(OP_NOT_WHITESPACE):
			goto SW_GENERATED_LABEL_452
		case uint32(OP_WHITESPACE):
			goto SW_GENERATED_LABEL_453
		case uint32(OP_NOT_WORDCHAR):
			goto SW_GENERATED_LABEL_454
		case uint32(OP_WORDCHAR):
			goto SW_GENERATED_LABEL_455
		case uint32(OP_ANYNL):
			goto SW_GENERATED_LABEL_456
		case uint32(OP_NOT_HSPACE):
			goto SW_GENERATED_LABEL_457
		case uint32(OP_HSPACE):
			goto SW_GENERATED_LABEL_458
		case uint32(OP_NOT_VSPACE):
			goto SW_GENERATED_LABEL_459
		case uint32(OP_VSPACE):
			goto SW_GENERATED_LABEL_460
		case uint32(OP_PROP):
			goto SW_GENERATED_LABEL_461
		case uint32(OP_NOTPROP):
			goto SW_GENERATED_LABEL_462
		case uint32(OP_EXTUNI):
			goto SW_GENERATED_LABEL_463
		case uint32(OP_DNREF):
			goto SW_GENERATED_LABEL_464
		case uint32(OP_DNREFI):
			goto SW_GENERATED_LABEL_465
		case uint32(OP_REF):
			goto SW_GENERATED_LABEL_466
		case uint32(OP_REFI):
			goto SW_GENERATED_LABEL_467
		case uint32(OP_NCLASS):
			goto SW_GENERATED_LABEL_468
		case uint32(OP_CLASS):
			goto SW_GENERATED_LABEL_469
		case uint32(OP_XCLASS):
			goto SW_GENERATED_LABEL_470
		case uint32(OP_CHAR):
			goto SW_GENERATED_LABEL_471
		case uint32(OP_CHARI):
			goto SW_GENERATED_LABEL_472
		case uint32(OP_EXACT):
			goto SW_GENERATED_LABEL_473
		case uint32(OP_EXACTI):
			goto SW_GENERATED_LABEL_474
		case uint32(OP_POSUPTO):
			goto SW_GENERATED_LABEL_475
		case uint32(OP_POSUPTOI):
			goto SW_GENERATED_LABEL_476
		case uint32(OP_UPTO):
			goto SW_GENERATED_LABEL_477
		case uint32(OP_UPTOI):
			goto SW_GENERATED_LABEL_478
		case uint32(OP_MINUPTO):
			goto SW_GENERATED_LABEL_479
		case uint32(OP_MINUPTOI):
			goto SW_GENERATED_LABEL_480
		case uint32(OP_POSSTAR):
			goto SW_GENERATED_LABEL_481
		case uint32(OP_POSSTARI):
			goto SW_GENERATED_LABEL_482
		case uint32(OP_POSPLUS):
			goto SW_GENERATED_LABEL_483
		case uint32(OP_POSPLUSI):
			goto SW_GENERATED_LABEL_484
		case uint32(OP_POSQUERY):
			goto SW_GENERATED_LABEL_485
		case uint32(OP_POSQUERYI):
			goto SW_GENERATED_LABEL_486
		case uint32(OP_STAR):
			goto SW_GENERATED_LABEL_487
		case uint32(OP_STARI):
			goto SW_GENERATED_LABEL_488
		case uint32(OP_MINSTAR):
			goto SW_GENERATED_LABEL_489
		case uint32(OP_MINSTARI):
			goto SW_GENERATED_LABEL_490
		case uint32(OP_PLUS):
			goto SW_GENERATED_LABEL_491
		case uint32(OP_PLUSI):
			goto SW_GENERATED_LABEL_492
		case uint32(OP_MINPLUS):
			goto SW_GENERATED_LABEL_493
		case uint32(OP_MINPLUSI):
			goto SW_GENERATED_LABEL_494
		case uint32(OP_QUERY):
			goto SW_GENERATED_LABEL_495
		case uint32(OP_QUERYI):
			goto SW_GENERATED_LABEL_496
		case uint32(OP_MINQUERY):
			goto SW_GENERATED_LABEL_497
		case uint32(OP_MINQUERYI):
			goto SW_GENERATED_LABEL_498
		case uint32(OP_NOT):
			goto SW_GENERATED_LABEL_499
		case uint32(OP_NOTI):
			goto SW_GENERATED_LABEL_500
		case uint32(OP_NOTEXACT):
			goto SW_GENERATED_LABEL_501
		case uint32(OP_NOTEXACTI):
			goto SW_GENERATED_LABEL_502
		case uint32(OP_NOTUPTO):
			goto SW_GENERATED_LABEL_503
		case uint32(OP_NOTUPTOI):
			goto SW_GENERATED_LABEL_504
		case uint32(OP_NOTMINUPTO):
			goto SW_GENERATED_LABEL_505
		case uint32(OP_NOTMINUPTOI):
			goto SW_GENERATED_LABEL_506
		case uint32(OP_NOTPOSSTAR):
			goto SW_GENERATED_LABEL_507
		case uint32(OP_NOTPOSSTARI):
			goto SW_GENERATED_LABEL_508
		case uint32(OP_NOTPOSPLUS):
			goto SW_GENERATED_LABEL_509
		case uint32(OP_NOTPOSPLUSI):
			goto SW_GENERATED_LABEL_510
		case uint32(OP_NOTPOSQUERY):
			goto SW_GENERATED_LABEL_511
		case uint32(OP_NOTPOSQUERYI):
			goto SW_GENERATED_LABEL_512
		case uint32(OP_NOTPOSUPTO):
			goto SW_GENERATED_LABEL_513
		case uint32(OP_NOTPOSUPTOI):
			goto SW_GENERATED_LABEL_514
		case uint32(OP_NOTSTAR):
			goto SW_GENERATED_LABEL_515
		case uint32(OP_NOTSTARI):
			goto SW_GENERATED_LABEL_516
		case uint32(OP_NOTMINSTAR):
			goto SW_GENERATED_LABEL_517
		case uint32(OP_NOTMINSTARI):
			goto SW_GENERATED_LABEL_518
		case uint32(OP_NOTPLUS):
			goto SW_GENERATED_LABEL_519
		case uint32(OP_NOTPLUSI):
			goto SW_GENERATED_LABEL_520
		case uint32(OP_NOTMINPLUS):
			goto SW_GENERATED_LABEL_521
		case uint32(OP_NOTMINPLUSI):
			goto SW_GENERATED_LABEL_522
		case uint32(OP_NOTQUERY):
			goto SW_GENERATED_LABEL_523
		case uint32(OP_NOTQUERYI):
			goto SW_GENERATED_LABEL_524
		case uint32(OP_NOTMINQUERY):
			goto SW_GENERATED_LABEL_525
		case uint32(OP_NOTMINQUERYI):
			goto SW_GENERATED_LABEL_526
		case uint32(OP_TYPEEXACT):
			goto SW_GENERATED_LABEL_527
		case uint32(OP_TYPEUPTO):
			goto SW_GENERATED_LABEL_528
		case uint32(OP_TYPEMINUPTO):
			goto SW_GENERATED_LABEL_529
		case uint32(OP_TYPEPOSSTAR):
			goto SW_GENERATED_LABEL_530
		case uint32(OP_TYPEPOSPLUS):
			goto SW_GENERATED_LABEL_531
		case uint32(OP_TYPEPOSQUERY):
			goto SW_GENERATED_LABEL_532
		case uint32(OP_TYPEPOSUPTO):
			goto SW_GENERATED_LABEL_533
		case uint32(OP_TYPESTAR):
			goto SW_GENERATED_LABEL_534
		case uint32(OP_TYPEMINSTAR):
			goto SW_GENERATED_LABEL_535
		case uint32(OP_TYPEPLUS):
			goto SW_GENERATED_LABEL_536
		case uint32(OP_TYPEMINPLUS):
			goto SW_GENERATED_LABEL_537
		case uint32(OP_TYPEQUERY):
			goto SW_GENERATED_LABEL_538
		case uint32(OP_TYPEMINQUERY):
			goto SW_GENERATED_LABEL_539
		default:
			goto SW_GENERATED_LABEL_540
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_395:
		{
			(*md).nomatch_mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			(*md).mark = nil
			rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
			}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if ((rrc == int32(1)) || (rrc == -int32(999))) && ((*md).mark == nil) {
				(*md).mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			} else if (rrc == -int32(993)) && (noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode))+(uintptr)(int32(2))*unsafe.Sizeof(*ecode)))))), (*byte)(unsafe.Pointer(((*md).start_match_ptr)))) == int32(0)) {
				(*md).start_match_ptr = eptr
				return (-int32(994))
			}
			return rrc
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_396:
		{
			return int32(0)
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_397:
		{
			rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			return (-int32(996))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_398:
		{
			rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			return (-int32(995))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_399:
		{
			(*md).nomatch_mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			(*md).mark = nil
			rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
			}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if ((rrc == int32(1)) || (rrc == -int32(999))) && ((*md).mark == nil) {
				(*md).mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			}
			if rrc != int32(0) {
				return rrc
			}
			return (-int32(995))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_400:
		{
			rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			(*md).start_match_ptr = eptr
			return (-int32(994))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_401:
		{
			(*md).skip_arg_count += uint32(int32(1))
			if (*md).skip_arg_count <= (*md).ignore_skip_arg {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}())))))+int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode)))))))))*unsafe.Sizeof(*ecode))))
				goto SW_GENERATED_LABEL_394
			}
			rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
			}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			(*md).start_match_ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			return (-int32(993))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_402:
		{
			rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			(*md).start_match_ptr = ecode
			return (-int32(992))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_403:
		{
			(*md).nomatch_mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			(*md).mark = nil
			rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
			}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if ((rrc == int32(1)) || (rrc == -int32(999))) && ((*md).mark == nil) {
				(*md).mark = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			}
			if rrc != int32(0) {
				return rrc
			}
			(*md).start_match_ptr = ecode
			return (-int32(992))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_404:
		{
			prev = ecode
			saved_eptr = eptr
			data = (*md).mark
			for {
				rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc == int32(1) {
					mstart = (*md).start_match_ptr
					break
				}
				if rrc == -int32(992) {
					next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
						rrc = int32(0)
					}
				}
				if rrc != int32(0) {
					return rrc
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				(*md).mark = data
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
			if (int32(uint8((*ecode))) != OP_ONCE_NC) && (int32(uint8((*ecode))) != OP_ALT) {
				return int32(0)
			}
			for {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
			offset_top = (*md).end_offset_top
			eptr = (*md).end_match_ptr
			if (int32(uint8((*ecode))) == OP_KET) || (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(saved_eptr)))) {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto SW_GENERATED_LABEL_394
			}
			if int32(uint8((*ecode))) == OP_KETRMIN {
				rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc != int32(0) {
					return rrc
				}
				ecode = prev
				goto TAIL_RECURSE
			} else {
				rrc = match(eptr, prev, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc != int32(0) {
					return rrc
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto TAIL_RECURSE
			}
		}
	SW_GENERATED_LABEL_405:
		;
	SW_GENERATED_LABEL_406:
		{
			number = uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode))))))))))
			offset = int32((number << uint64(int32(1))))
			if offset < (*md).offset_max {
				save_offset1 = *((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
				}()))
				save_offset2 = *((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
				}()))
				save_offset3 = *((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}()))
				save_capture_last = pcre_int32((*md).capture_last)
				data = (*md).mark
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}())) = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				for {
					if op >= uint32(OP_SBRA) {
						(*md).match_function_type = int32(2)
					}
					rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_OP_lengths[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc == -int32(997) {
						break
					}
					if rrc == -int32(992) {
						next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
						if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
							rrc = int32(0)
						}
					}
					if rrc != int32(0) {
						return rrc
					}
					(*md).capture_last = save_capture_last
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					(*md).mark = data
					if int32(uint8((*ecode))) != OP_ALT {
						break
					}
				}
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
				}())) = save_offset1
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
				}())) = save_offset2
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}())) = save_offset3
				return rrc
			}
		}
	SW_GENERATED_LABEL_407:
		;
	SW_GENERATED_LABEL_408:
		;
	SW_GENERATED_LABEL_409:
		{
			for {
				if (op >= uint32(OP_SBRA)) || (op == uint32(OP_ONCE)) {
					(*md).match_function_type = int32(2)
				} else if (int32((NotBOOL(BOOL((*md).hasthen)))) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))))) != OP_ALT) {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_OP_lengths[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*ecode))))
					goto TAIL_RECURSE
				}
				data = (*md).mark
				save_capture_last = pcre_int32((*md).capture_last)
				rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc == -int32(992) {
					next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
						rrc = int32(0)
					}
				}
				if rrc != int32(0) {
					if rrc == -int32(997) {
						var scode *pcre_uchar = ecode
						if int32(uint8((*scode))) != OP_ONCE {
							for int32(uint8((*scode))) == OP_ALT {
								scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))))*unsafe.Sizeof(*scode))))
							}
							scode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(scode)) - (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(scode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((scode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(scode))))))))))*unsafe.Sizeof(*scode))))
						}
						if int64(uintptr(unsafe.Pointer((*md).once_target))) == int64(uintptr(unsafe.Pointer(scode))) {
							rrc = int32(0)
						}
					}
					return rrc
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				(*md).mark = data
				if int32(uint8((*ecode))) != OP_ALT {
					break
				}
				(*md).capture_last = save_capture_last
			}
			return int32(0)
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_410:
		;
	SW_GENERATED_LABEL_411:
		{
			cur_is_word = BOOL((int32(0)))
		}
	POSSESSIVE_CAPTURE:
		{
			number = uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode))))))))))
			offset = int32((number << uint64(int32(1))))
			if offset >= (*md).offset_max {
				goto POSSESSIVE_NON_CAPTURE
			}
			prev_is_word = BOOL((int32(0)))
			codelink = (int32((int64(uintptr(unsafe.Pointer(ecode))) - int64(uintptr(unsafe.Pointer((*md).start_code))))))
			save_offset1 = *((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
			}()))
			save_offset2 = *((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
			}()))
			save_offset3 = *((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
			}()))
			save_capture_last = pcre_int32((*md).capture_last)
			for {
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}())) = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				if op >= uint32(OP_SBRA) {
					(*md).match_function_type = int32(2)
				}
				rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc == -int32(998) {
					offset_top = (*md).end_offset_top
					ecode = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).start_code
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codelink)*unsafe.Sizeof(*tempVar))
					}()))
					save_capture_last = pcre_int32((*md).capture_last)
					prev_is_word = BOOL((int32(1)))
					mstart = (*md).start_match_ptr
					if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).end_match_ptr))) {
						for {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
								break
							}
						}
						break
					}
					eptr = (*md).end_match_ptr
					continue
				}
				if rrc == -int32(992) {
					next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
						rrc = int32(0)
					}
				}
				if rrc != int32(0) {
					return rrc
				}
				(*md).capture_last = save_capture_last
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if int32(uint8((*ecode))) != OP_ALT {
					break
				}
			}
			if int32((NotBOOL(BOOL(prev_is_word)))) != 0 {
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
				}())) = save_offset1
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
				}())) = save_offset2
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}())) = save_offset3
			}
			if (int32((cur_is_word)) != 0) || (int32((prev_is_word)) != 0) {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto SW_GENERATED_LABEL_394
			}
			return int32(0)
		}
	SW_GENERATED_LABEL_412:
		;
	SW_GENERATED_LABEL_413:
		{
			cur_is_word = BOOL((int32(0)))
		}
	POSSESSIVE_NON_CAPTURE:
		{
			prev_is_word = BOOL((int32(0)))
			codelink = (int32((int64(uintptr(unsafe.Pointer(ecode))) - int64(uintptr(unsafe.Pointer((*md).start_code))))))
			save_capture_last = pcre_int32((*md).capture_last)
			for {
				if op >= uint32(OP_SBRA) {
					(*md).match_function_type = int32(2)
				}
				rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*ecode))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc == -int32(998) {
					offset_top = (*md).end_offset_top
					ecode = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).start_code
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(codelink)*unsafe.Sizeof(*tempVar))
					}()))
					prev_is_word = BOOL((int32(1)))
					mstart = (*md).start_match_ptr
					if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).end_match_ptr))) {
						for {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
								break
							}
						}
						break
					}
					eptr = (*md).end_match_ptr
					continue
				}
				if rrc == -int32(992) {
					next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
						rrc = int32(0)
					}
				}
				if rrc != int32(0) {
					return rrc
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if int32(uint8((*ecode))) != OP_ALT {
					break
				}
				(*md).capture_last = save_capture_last
			}
			if (int32((prev_is_word)) != 0) || (int32((cur_is_word)) != 0) {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto SW_GENERATED_LABEL_394
			}
			return int32(0)
		}
	SW_GENERATED_LABEL_414:
		;
	SW_GENERATED_LABEL_415:
		{
			codelink = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			if int32(uint8((*ecode))) == OP_CALLOUT {
				if pcre_callout != nil {
					var cb pcre_callout_block
					cb.version = int32(2)
					cb.callout_number = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode)))))))
					cb.offset_vector = (*md).offset_vector
					cb.subject = (*byte)(unsafe.Pointer((*md).start_subject))
					cb.subject_length = (int32((int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
					cb.start_match = (int32((int64(uintptr(unsafe.Pointer(mstart))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
					cb.current_position = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
					cb.pattern_position = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(2))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
					cb.next_item_length = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
					cb.capture_top = (offset_top / int32(2))
					cb.capture_last = int32((pcre_int32((*md).capture_last) & pcre_int32((int32(65535)))))
					if cb.capture_last == int32(0) {
						cb.capture_last = -int32(1)
					}
					cb.callout_data = (*md).callout_data
					cb.mark = (*uint8)(unsafe.Pointer((*md).nomatch_mark))
					if (func() int32 {
						tempVar := pcre_callout(&cb)
						rrc = tempVar
						return tempVar
					}()) > int32(0) {
						return int32(0)
					}
					if rrc < int32(0) {
						return rrc
					}
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CALLOUT)*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*ecode))))
				codelink -= int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CALLOUT)*unsafe.Sizeof(*tempVar))
				}())))))
			}
			condition = BOOL((int32(0)))
			switch func() int32 {
				condcode = int32(uint8((*ecode)))
				return condcode
			}() {
			case OP_RREF:
				{
					if (*md).recursive != nil {
						var recno uint32 = uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))
						condition = BOOL((map[bool]int32{false: 0, true: 1}[((recno == uint32(int32(65535))) || (recno == (*(*md).recursive).group_num))]))
					}
				}
			case OP_DNRREF:
				{
					if (*md).recursive != nil {
						var count int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
						var slot *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).name_table
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*uint32((*md).name_entry_size))))*unsafe.Sizeof(*tempVar))
						}()))
						for func() int32 {
							defer func() {
								count -= 1
							}()
							return count
						}() > int32(0) {
							var recno uint32 = uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot))))))))))
							condition = BOOL((map[bool]int32{false: 0, true: 1}[(recno == (*(*md).recursive).group_num)]))
							if int32((BOOL(condition))) != 0 {
								break
							}
							slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*md).name_entry_size)*unsafe.Sizeof(*slot))))
						}
					}
				}
			case OP_CREF:
				{
					offset = int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))) << uint64(int32(1))))
					condition = BOOL((map[bool]int32{false: 0, true: 1}[((offset < offset_top) && (*((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
					}())) >= int32(0)))]))
				}
			case OP_DNCREF:
				{
					var count int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					var slot *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).name_table
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*uint32((*md).name_entry_size))))*unsafe.Sizeof(*tempVar))
					}()))
					for func() int32 {
						defer func() {
							count -= 1
						}()
						return count
					}() > int32(0) {
						offset = int32((uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot)))))))))) << uint64(int32(1))))
						condition = BOOL((map[bool]int32{false: 0, true: 1}[((offset < offset_top) && (*((*int32)(func() unsafe.Pointer {
							tempVar := (*md).offset_vector
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
						}())) >= int32(0)))]))
						if int32((BOOL(condition))) != 0 {
							break
						}
						slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*md).name_entry_size)*unsafe.Sizeof(*slot))))
					}
				}
			case OP_DEF:
				fallthrough
			case OP_FAIL:
				{
				}
			default:
				{
					(*md).match_function_type = int32(1)
					rrc = match(eptr, ecode, mstart, offset_top, md, nil, (rdepth + uint32(int32(1))))
					if rrc == int32(1) {
						if (*md).end_offset_top > offset_top {
							offset_top = (*md).end_offset_top
						}
						condition = BOOL((int32(1)))
						if int32(uint8((*ecode))) == OP_BRAZERO {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
						for int32(uint8((*ecode))) == OP_ALT {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
						}
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(1)+int32(2))-int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_OP_lengths[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(condcode)*unsafe.Sizeof(*tempVar))
						}())))))))*unsafe.Sizeof(*ecode))))
					} else if (rrc != int32(0)) && (rrc != -int32(992)) {
						return rrc
					}
					break
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(func() int32 {
				if int32((BOOL(condition))) != 0 {
					return int32(uint8((pcre_uint8(*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_OP_lengths[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(condcode)*unsafe.Sizeof(*tempVar))
					}()))))))
				} else {
					return codelink
				}
			}())*unsafe.Sizeof(*ecode))))
			if (int32((condition)) != 0) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) - (uintptr)(3)*unsafe.Sizeof(*ecode))))))) == OP_ALT) {
				if op != uint32(OP_SCOND) {
					goto TAIL_RECURSE
				}
				(*md).match_function_type = int32(2)
				rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				return rrc
			} else {
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_416:
		{
			number = uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))
			offset = int32((number << uint64(int32(1))))
			(*md).capture_last = pcre_int32((int32(((uint32(int32((pcre_int32((*md).capture_last)))) & uint32(4294901760)) | number))))
			if offset >= (*md).offset_max {
				(*md).capture_last |= pcre_int32((int32(65536)))
			} else {
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
				}())) = *((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
				}()))
				*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
				}())) = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				if offset >= offset_top {
					var iptr *int32 = ((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset_top)*unsafe.Sizeof(*tempVar))
					}()))
					var iend *int32 = ((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
					}()))
					for int64(uintptr(unsafe.Pointer(iptr))) < int64(uintptr(unsafe.Pointer(iend))) {
						*func() *int32 {
							defer func() {
								iptr = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(iptr)) + (uintptr)(1)*unsafe.Sizeof(*iptr))))
							}()
							return iptr
						}() = -int32(1)
					}
					offset_top = (offset + int32(2))
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_417:
		;
	SW_GENERATED_LABEL_418:
		;
	SW_GENERATED_LABEL_419:
		{
			if (((int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(mstart)))) && (op != uint32(OP_ASSERT_ACCEPT))) && ((*md).recursive == nil)) && ((int32((BOOL((*md).notempty))) != 0) || ((int32((BOOL((*md).notempty_atstart))) != 0) && (int64(uintptr(unsafe.Pointer(mstart))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*md).start_subject
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).start_offset)*unsafe.Sizeof(*tempVar))
			}())))))))) {
				return int32(0)
			}
			(*md).end_match_ptr = eptr
			(*md).end_offset_top = offset_top
			(*md).start_match_ptr = mstart
			rrc = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(op == uint32(OP_END))]) != 0 {
					return int32(1)
				} else {
					return (-int32(999))
				}
			}()
			return rrc
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_420:
		;
	SW_GENERATED_LABEL_421:
		{
			data = (*md).mark
			if (*md).match_function_type == int32(1) {
				condition = BOOL((int32(1)))
				(*md).match_function_type = int32(0)
			} else {
				condition = BOOL((int32(0)))
			}
			for {
				rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())), mstart, offset_top, md, nil, (rdepth + uint32(int32(1))))
				if (rrc == int32(1)) || (rrc == -int32(999)) {
					mstart = (*md).start_match_ptr
					break
				}
				(*md).mark = data
				if rrc == -int32(992) {
					next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
					if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
						rrc = int32(0)
					}
				}
				if rrc != int32(0) {
					return rrc
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
			if int32(uint8((*ecode))) == OP_KET {
				return int32(0)
			}
			if int32((BOOL(condition))) != 0 {
				return int32(1)
			}
			for {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			offset_top = (*md).end_offset_top
			continue
		}
	SW_GENERATED_LABEL_422:
		;
	SW_GENERATED_LABEL_423:
		{
			data = (*md).mark
			if (*md).match_function_type == int32(1) {
				condition = BOOL((int32(1)))
				(*md).match_function_type = int32(0)
			} else {
				condition = BOOL((int32(0)))
			}
			for {
				rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())), mstart, offset_top, md, nil, (rdepth + uint32(int32(1))))
				(*md).mark = data
				switch rrc {
				case int32(1):
					fallthrough
				case (-int32(999)):
					{
						return int32(0)
					}
				case int32(0):
					{
					}
				case (-int32(992)):
					{
						next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
						if (int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) < int64(uintptr(unsafe.Pointer(next)))) && ((int32(uint8((*ecode))) == OP_ALT) || (int32(uint8((*next))) == OP_ALT)) {
							rrc = int32(0)
							break
						}
					}
					fallthrough
				case (-int32(996)):
					fallthrough
				case (-int32(994)):
					fallthrough
				case (-int32(993)):
					fallthrough
				case (-int32(995)):
					{
						for {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
								break
							}
						}
						goto NEG_ASSERT_TRUE
					}
					fallthrough
				default:
					{
						return rrc
					}
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
		}
	NEG_ASSERT_TRUE:
		{
			if int32((BOOL(condition))) != 0 {
				return int32(1)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			continue
		}
	SW_GENERATED_LABEL_424:
		{
			if int32((BOOL(utf))) != 0 {
				i = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
				for func() int32 {
					defer func() {
						i -= 1
					}()
					return i
				}() > int32(0) {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
					if int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).start_subject))) {
						return int32(0)
					}
					for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
				}
			} else {
				eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*eptr))))
				if int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).start_subject))) {
					return int32(0)
				}
			}
			if int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) {
				(*md).start_used_ptr = eptr
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_425:
		{
			if pcre_callout != nil {
				var cb pcre_callout_block
				cb.version = int32(2)
				cb.callout_number = int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode)))))))
				cb.offset_vector = (*md).offset_vector
				cb.subject = (*byte)(unsafe.Pointer((*md).start_subject))
				cb.subject_length = (int32((int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				cb.start_match = (int32((int64(uintptr(unsafe.Pointer(mstart))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				cb.current_position = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
				cb.pattern_position = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(2))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(2)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
				cb.next_item_length = ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(2)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))
				cb.capture_top = (offset_top / int32(2))
				cb.capture_last = int32((pcre_int32((*md).capture_last) & pcre_int32((int32(65535)))))
				if cb.capture_last == int32(0) {
					cb.capture_last = -int32(1)
				}
				cb.callout_data = (*md).callout_data
				cb.mark = (*uint8)(unsafe.Pointer((*md).nomatch_mark))
				if (func() int32 {
					tempVar := pcre_callout(&cb)
					rrc = tempVar
					return tempVar
				}()) > int32(0) {
					return int32(0)
				}
				if rrc < int32(0) {
					return rrc
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(2)+(int32(2)*int32(2))))*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_426:
		{
			var ri *recursion_info
			var recno uint32
			callpat = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*md).start_code
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*tempVar))
			}()))
			recno = func() uint32 {
				if (map[bool]int32{false: 0, true: 1}[(int64(uintptr(unsafe.Pointer(callpat))) == int64(uintptr(unsafe.Pointer((*md).start_code))))]) != 0 {
					return uint32(int32(0))
				} else {
					return uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(callpat)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(callpat))))))))))
				}
			}()
			for ri = (*md).recursive; ri != nil; ri = (*ri).prevrec {
				if (recno == (*ri).group_num) && (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*ri).subject_position)))) {
					return (-int32(26))
				}
			}
			new_recursive.group_num = recno
			new_recursive.saved_capture_last = int32((pcre_int32((*md).capture_last)))
			new_recursive.subject_position = eptr
			new_recursive.prevrec = (*md).recursive
			(*md).recursive = &new_recursive
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			new_recursive.saved_max = (*md).offset_end
			if new_recursive.saved_max <= int32(30) {
				new_recursive.offset_save = &stacksave[0]
			} else {
				new_recursive.offset_save = (*int32)(pcre_malloc(size_t((uint32(new_recursive.saved_max) * 4))))
				if new_recursive.offset_save == nil {
					return (-int32(6))
				}
			}
			noarch.Memcpy(unsafe.Pointer(new_recursive.offset_save), unsafe.Pointer((*md).offset_vector), int32((uint32(new_recursive.saved_max) * 4)))
			condition = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*callpat))) >= OP_SBRA)]))
			for {
				if int32((BOOL(condition))) != 0 {
					(*md).match_function_type = int32(2)
				}
				rrc = match(eptr, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(callpat)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*callpat))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*callpat)))), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				noarch.Memcpy(unsafe.Pointer((*md).offset_vector), unsafe.Pointer(new_recursive.offset_save), int32((uint32(new_recursive.saved_max) * 4)))
				(*md).capture_last = pcre_int32((new_recursive.saved_capture_last))
				(*md).recursive = new_recursive.prevrec
				if (rrc == int32(1)) || (rrc == -int32(999)) {
					if int64(uintptr(unsafe.Pointer(new_recursive.offset_save))) != int64(uintptr(unsafe.Pointer(&stacksave[0]))) {
						pcre_free(unsafe.Pointer(new_recursive.offset_save))
					}
					eptr = (*md).end_match_ptr
					mstart = (*md).start_match_ptr
					goto RECURSION_MATCHED
				}
				if (rrc >= -int32(996)) && (rrc <= -int32(992)) {
					if int64(uintptr(unsafe.Pointer(new_recursive.offset_save))) != int64(uintptr(unsafe.Pointer(&stacksave[0]))) {
						pcre_free(unsafe.Pointer(new_recursive.offset_save))
					}
					return int32(0)
				}
				if rrc != int32(0) {
					if int64(uintptr(unsafe.Pointer(new_recursive.offset_save))) != int64(uintptr(unsafe.Pointer(&stacksave[0]))) {
						pcre_free(unsafe.Pointer(new_recursive.offset_save))
					}
					return rrc
				}
				(*md).recursive = &new_recursive
				callpat = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(callpat)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)(int32(1))*unsafe.Sizeof(*(callpat))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((callpat))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(callpat))))))))))*unsafe.Sizeof(*callpat))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*callpat))) == OP_ALT)])) != 0 {
					break
				}
			}
			(*md).recursive = new_recursive.prevrec
			if int64(uintptr(unsafe.Pointer(new_recursive.offset_save))) != int64(uintptr(unsafe.Pointer(&stacksave[0]))) {
				pcre_free(unsafe.Pointer(new_recursive.offset_save))
			}
			return int32(0)
		}
		goto SW_GENERATED_LABEL_394
	RECURSION_MATCHED:
		{
			goto SW_GENERATED_LABEL_394
		}
	SW_GENERATED_LABEL_427:
		{
			for {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_ALT)])) != 0 {
					break
				}
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_428:
		{
			next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
			rrc = match(eptr, next, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			for {
				next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)(int32(1))*unsafe.Sizeof(*(next))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(next))))))))))*unsafe.Sizeof(*next))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*next))) == OP_ALT)])) != 0 {
					break
				}
			}
			ecode = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(int32(1))*unsafe.Sizeof(*next))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_429:
		{
			next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
			for {
				next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)(int32(1))*unsafe.Sizeof(*(next))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(next))))))))))*unsafe.Sizeof(*next))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*next))) == OP_ALT)])) != 0 {
					break
				}
			}
			rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(int32(1))*unsafe.Sizeof(*next))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
			if rrc != int32(0) {
				return rrc
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_430:
		{
			next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
			for {
				next = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)(int32(1))*unsafe.Sizeof(*(next))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((next))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(next))))))))))*unsafe.Sizeof(*next))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*next))) == OP_ALT)])) != 0 {
					break
				}
			}
			ecode = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(next)) + (uintptr)(int32(1))*unsafe.Sizeof(*next))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_431:
		{
			op = uint32(uint8((*func() *pcre_uchar {
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				return ecode
			}())))
			cur_is_word = BOOL((int32(1)))
			if (op == uint32(OP_CBRAPOS)) || (op == uint32(OP_SCBRAPOS)) {
				goto POSSESSIVE_CAPTURE
			}
			goto POSSESSIVE_NON_CAPTURE
		}
	SW_GENERATED_LABEL_432:
		;
	SW_GENERATED_LABEL_433:
		;
	SW_GENERATED_LABEL_434:
		;
	SW_GENERATED_LABEL_435:
		{
			prev = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) - (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
			if (int32(uint8((*prev))) >= OP_SBRA) || (int32(uint8((*prev))) == OP_ONCE) {
				saved_eptr = (*eptrb).epb_saved_eptr
				eptrb = (*eptrb).epb_prev
			} else {
				saved_eptr = nil
			}
			if ((int32(uint8((*prev))) >= OP_ASSERT) && (int32(uint8((*prev))) <= OP_ASSERTBACK_NOT)) || (int32(uint8((*prev))) == OP_ONCE_NC) {
				(*md).end_match_ptr = eptr
				(*md).end_offset_top = offset_top
				(*md).start_match_ptr = mstart
				return int32(1)
			}
			if (((int32(uint8((*prev))) == OP_CBRA) || (int32(uint8((*prev))) == OP_SCBRA)) || (int32(uint8((*prev))) == OP_CBRAPOS)) || (int32(uint8((*prev))) == OP_SCBRAPOS) {
				number = uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((prev))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(prev)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((prev))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(prev))))))))))
				offset = int32((number << uint64(int32(1))))
				if ((*md).recursive != nil) && ((*(*md).recursive).group_num == number) {
					(*md).end_match_ptr = eptr
					(*md).start_match_ptr = mstart
					return int32(1)
				}
				(*md).capture_last = pcre_int32((int32(((uint32(int32((pcre_int32((*md).capture_last)))) & uint32(4294901760)) | number))))
				if offset >= (*md).offset_max {
					(*md).capture_last |= pcre_int32((int32(65536)))
				} else {
					if offset > offset_top {
						var iptr *int32 = ((*int32)(func() unsafe.Pointer {
							tempVar := (*md).offset_vector
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset_top)*unsafe.Sizeof(*tempVar))
						}()))
						var iend *int32 = ((*int32)(func() unsafe.Pointer {
							tempVar := (*md).offset_vector
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
						}()))
						for int64(uintptr(unsafe.Pointer(iptr))) < int64(uintptr(unsafe.Pointer(iend))) {
							*func() *int32 {
								defer func() {
									iptr = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(iptr)) + (uintptr)(1)*unsafe.Sizeof(*iptr))))
								}()
								return iptr
							}() = -int32(1)
						}
					}
					*((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
					}())) = *((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32((*md).offset_end)-number)))*unsafe.Sizeof(*tempVar))
					}()))
					*((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
					}())) = (int32((int64(uintptr(unsafe.Pointer(eptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
					if offset_top <= offset {
						offset_top = (offset + int32(2))
					}
				}
			}
			if int32(uint8((*ecode))) == OP_KETRPOS {
				(*md).start_match_ptr = mstart
				(*md).end_match_ptr = eptr
				(*md).end_offset_top = offset_top
				return (-int32(998))
			}
			if (int32(uint8((*ecode))) == OP_KET) || (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(saved_eptr)))) {
				if int32(uint8((*prev))) == OP_ONCE {
					rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					(*md).once_target = prev
					return (-int32(997))
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto SW_GENERATED_LABEL_394
			}
			if int32(uint8((*ecode))) == OP_KETRMIN {
				rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if rrc != int32(0) {
					return rrc
				}
				if int32(uint8((*prev))) == OP_ONCE {
					rrc = match(eptr, prev, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					(*md).once_target = prev
					return (-int32(997))
				}
				if int32(uint8((*prev))) >= OP_SBRA {
					rrc = match(eptr, prev, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					return rrc
				}
				ecode = prev
				goto TAIL_RECURSE
			} else {
				rrc = match(eptr, prev, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
				if (rrc == -int32(997)) && (int64(uintptr(unsafe.Pointer((*md).once_target))) == int64(uintptr(unsafe.Pointer(prev)))) {
					rrc = int32(0)
				}
				if rrc != int32(0) {
					return rrc
				}
				if int32(uint8((*prev))) == OP_ONCE {
					rrc = match(eptr, ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}())), mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					(*md).once_target = prev
					return (-int32(997))
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
				goto TAIL_RECURSE
			}
		}
	SW_GENERATED_LABEL_436:
		{
			if (int32((BOOL((*md).notbol))) != 0) && (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).start_subject)))) {
				return int32(0)
			}
		}
	SW_GENERATED_LABEL_437:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) != int64(uintptr(unsafe.Pointer((*md).start_subject))) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_438:
		{
			if (int32((BOOL((*md).notbol))) != 0) && (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).start_subject)))) {
				return int32(0)
			}
			if (int64(uintptr(unsafe.Pointer(eptr))) != int64(uintptr(unsafe.Pointer((*md).start_subject)))) && ((int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).end_subject)))) || (noarch.NotInt32((func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
					return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((eptr), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
				} else {
					return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).start_subject
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
					}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*eptr) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := &(*md).nl[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}()))))))))])
				}
			}())) != 0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_439:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) != int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*md).start_subject
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).start_offset)*unsafe.Sizeof(*tempVar))
			}()))))) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_440:
		{
			mstart = eptr
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_441:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if noarch.NotInt32((func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}())) != 0 {
					if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					return int32(0)
				}
			} else {
				if int32((BOOL((*md).noteol))) != 0 {
					return int32(0)
				}
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_442:
		{
			if int32((BOOL((*md).noteol))) != 0 {
				return int32(0)
			}
			if int32((NotBOOL(BOOL((*md).endonly)))) != 0 {
				goto ASSERT_NL_OR_EOS
			}
		}
	SW_GENERATED_LABEL_443:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				return int32(0)
			}
			if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
				(*md).hitend = BOOL((int32(1)))
				if (*md).partial > int32(1) {
					return (-int32(12))
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_444:
		;
	ASSERT_NL_OR_EOS:
		{
			if (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((noarch.NotInt32((func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
					return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
				} else {
					return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).end_subject
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
					}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := &(*md).nl[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}()))))))))])
				}
			}())) != 0) || (int64(uintptr(unsafe.Pointer(eptr))) != int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*md).end_subject
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
			}()))))))) {
				if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
				(*md).hitend = BOOL((int32(1)))
				if (*md).partial > int32(1) {
					return (-int32(12))
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto SW_GENERATED_LABEL_394
		}
	SW_GENERATED_LABEL_445:
		;
	SW_GENERATED_LABEL_446:
		{
			if int32((BOOL(utf))) != 0 {
				if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).start_subject))) {
					prev_is_word = BOOL((int32(0)))
				} else {
					var lastptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))
					for (int32(uint8((*lastptr))) & int32(192)) == int32(128) {
						lastptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) - (uintptr)(1)*unsafe.Sizeof(*lastptr))))
					}
					if int64(uintptr(unsafe.Pointer(lastptr))) < int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) {
						(*md).start_used_ptr = lastptr
					}
					c = pcre_uint32((uint32(uint8((*lastptr)))))
					if c >= pcre_uint32((uint32(int32(192)))) {
						if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*lastptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*lastptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*lastptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*lastptr))))))) & int32(63))))))
						} else {
							c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*lastptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(lastptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*lastptr))))))) & int32(63))))))
						}
					}
					if int32((BOOL((*md).use_ucp))) != 0 {
						if c == pcre_uint32((uint32('_'))) {
							prev_is_word = BOOL((int32(1)))
						} else {
							var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							prev_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]))
						}
					} else {
						prev_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := (*md).ctypes
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(16)) != int32(0)))]))
					}
				}
				if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					cur_is_word = BOOL((int32(0)))
				} else {
					c = pcre_uint32((uint32(uint8((*eptr)))))
					if c >= pcre_uint32((uint32(int32(192)))) {
						if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						} else {
							c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						}
					}
					if int32((BOOL((*md).use_ucp))) != 0 {
						if c == pcre_uint32((uint32('_'))) {
							cur_is_word = BOOL((int32(1)))
						} else {
							var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							cur_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]))
						}
					} else {
						cur_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := (*md).ctypes
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(16)) != int32(0)))]))
					}
				}
			} else {
				if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer((*md).start_subject))) {
					prev_is_word = BOOL((int32(0)))
				} else {
					if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer((*md).start_used_ptr))) {
						(*md).start_used_ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))
					}
					if int32((BOOL((*md).use_ucp))) != 0 {
						c = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr)))))))))
						if c == pcre_uint32((uint32('_'))) {
							prev_is_word = BOOL((int32(1)))
						} else {
							var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							prev_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]))
						}
					} else {
						prev_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := (*md).ctypes
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & int32(16)) != int32(0)))]))
					}
				}
				if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					cur_is_word = BOOL((int32(0)))
				} else if int32((BOOL((*md).use_ucp))) != 0 {
					c = pcre_uint32((uint32(uint8((*eptr)))))
					if c == pcre_uint32((uint32('_'))) {
						cur_is_word = BOOL((int32(1)))
					} else {
						var cat int32 = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).chartype)))))*unsafe.Sizeof(*tempVar))
						}())))))
						cur_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((cat == ucp_L) || (cat == ucp_N))]))
					}
				} else {
					cur_is_word = BOOL((map[bool]int32{false: 0, true: 1}[((int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*md).ctypes
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
					}()))))) & int32(16)) != int32(0)))]))
				}
			}
			if func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((*func() *pcre_uchar {
					defer func() {
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					}()
					return ecode
				}()))) == OP_WORD_BOUNDARY)]) != 0 {
					return map[bool]int32{false: 0, true: 1}[(cur_is_word == prev_is_word)]
				} else {
					return map[bool]int32{false: 0, true: 1}[(cur_is_word != prev_is_word)]
				}
			}() != 0 {
				return int32(0)
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_447:
		{
			if (func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
					return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
				} else {
					return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*md).end_subject
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
					}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := &(*md).nl[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
					}()))))))))])
				}
			}()) != 0 {
				return int32(0)
			}
			if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*md).end_subject
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}()))))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
				(*md).hitend = BOOL((int32(1)))
				if (*md).partial > int32(1) {
					return (-int32(12))
				}
			}
		}
	SW_GENERATED_LABEL_448:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
			if int32((BOOL(utf))) != 0 {
				for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_449:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_450:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(4)) != int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_451:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(4)) == int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_452:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(1)) != int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_453:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(1)) == int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_454:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(16)) != int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_455:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			if (c > pcre_uint32((uint32(int32(255))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := (*md).ctypes
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}()))))) & int32(16)) == int32(0)) {
				return int32(0)
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_456:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			switch pcre_uint32(c) {
			default:
				{
					return int32(0)
				}
			case pcre_uint32('\r'):
				{
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
					} else if int32(uint8((*eptr))) == int32('\n') {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
				}
			case pcre_uint32('\n'):
				{
				}
			case pcre_uint32('\v'):
				fallthrough
			case pcre_uint32('\f'):
				fallthrough
			case pcre_uint32((uint8('\u0085'))):
				fallthrough
			case pcre_uint32(int32(8232)):
				fallthrough
			case pcre_uint32(int32(8233)):
				{
					if int32((BOOL((*md).bsr_anycrlf))) != 0 {
						return int32(0)
					}
					break
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_457:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			switch pcre_uint32(c) {
			case pcre_uint32('\t'):
				fallthrough
			case pcre_uint32(' '):
				fallthrough
			case pcre_uint32((uint8('\u00a0'))):
				fallthrough
			case pcre_uint32(int32(5760)):
				fallthrough
			case pcre_uint32(int32(6158)):
				fallthrough
			case pcre_uint32(int32(8192)):
				fallthrough
			case pcre_uint32(int32(8193)):
				fallthrough
			case pcre_uint32(int32(8194)):
				fallthrough
			case pcre_uint32(int32(8195)):
				fallthrough
			case pcre_uint32(int32(8196)):
				fallthrough
			case pcre_uint32(int32(8197)):
				fallthrough
			case pcre_uint32(int32(8198)):
				fallthrough
			case pcre_uint32(int32(8199)):
				fallthrough
			case pcre_uint32(int32(8200)):
				fallthrough
			case pcre_uint32(int32(8201)):
				fallthrough
			case pcre_uint32(int32(8202)):
				fallthrough
			case pcre_uint32(int32(8239)):
				fallthrough
			case pcre_uint32(int32(8287)):
				fallthrough
			case pcre_uint32(int32(12288)):
				{
					return int32(0)
				}
			default:
				{
					break
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_458:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			switch pcre_uint32(c) {
			case pcre_uint32('\t'):
				fallthrough
			case pcre_uint32(' '):
				fallthrough
			case pcre_uint32((uint8('\u00a0'))):
				fallthrough
			case pcre_uint32(int32(5760)):
				fallthrough
			case pcre_uint32(int32(6158)):
				fallthrough
			case pcre_uint32(int32(8192)):
				fallthrough
			case pcre_uint32(int32(8193)):
				fallthrough
			case pcre_uint32(int32(8194)):
				fallthrough
			case pcre_uint32(int32(8195)):
				fallthrough
			case pcre_uint32(int32(8196)):
				fallthrough
			case pcre_uint32(int32(8197)):
				fallthrough
			case pcre_uint32(int32(8198)):
				fallthrough
			case pcre_uint32(int32(8199)):
				fallthrough
			case pcre_uint32(int32(8200)):
				fallthrough
			case pcre_uint32(int32(8201)):
				fallthrough
			case pcre_uint32(int32(8202)):
				fallthrough
			case pcre_uint32(int32(8239)):
				fallthrough
			case pcre_uint32(int32(8287)):
				fallthrough
			case pcre_uint32(int32(12288)):
				{
				}
			default:
				{
					return int32(0)
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_459:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			switch pcre_uint32(c) {
			case pcre_uint32('\n'):
				fallthrough
			case pcre_uint32('\v'):
				fallthrough
			case pcre_uint32('\f'):
				fallthrough
			case pcre_uint32('\r'):
				fallthrough
			case pcre_uint32((uint8('\u0085'))):
				fallthrough
			case pcre_uint32(int32(8232)):
				fallthrough
			case pcre_uint32(int32(8233)):
				{
					return int32(0)
				}
			default:
				{
					break
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_460:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			switch pcre_uint32(c) {
			case pcre_uint32('\n'):
				fallthrough
			case pcre_uint32('\v'):
				fallthrough
			case pcre_uint32('\f'):
				fallthrough
			case pcre_uint32('\r'):
				fallthrough
			case pcre_uint32((uint8('\u0085'))):
				fallthrough
			case pcre_uint32(int32(8232)):
				fallthrough
			case pcre_uint32(int32(8233)):
				{
				}
			default:
				{
					return int32(0)
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_461:
		;
	SW_GENERATED_LABEL_462:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}()
				return eptr
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
				}
			}
			{
				var cp *pcre_uint32
				var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_records[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage1[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
						}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*tempVar))
				}()))
				switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode)))))))) {
				case int32(0):
					{
						if op == uint32(OP_NOTPROP) {
							return int32(0)
						}
					}
				case int32(1):
					{
						if (((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt)) == (op == uint32(OP_NOTPROP)) {
							return int32(0)
						}
					}
				case int32(2):
					{
						if (uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) != uint32((*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
						}()))))) == (op == uint32(OP_PROP)) {
							return int32(0)
						}
					}
				case int32(3):
					{
						if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) != int32(uint8((pcre_uint8((*prop).chartype))))) == (op == uint32(OP_PROP)) {
							return int32(0)
						}
					}
				case int32(4):
					{
						if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) != int32(uint8((pcre_uint8((*prop).script))))) == (op == uint32(OP_PROP)) {
							return int32(0)
						}
					}
				case int32(5):
					{
						if ((*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
						}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
						}())) == pcre_uint32((uint32(ucp_N))))) == (op == uint32(OP_NOTPROP)) {
							return int32(0)
						}
					}
				case int32(6):
					fallthrough
				case int32(7):
					{
						switch pcre_uint32(c) {
						case pcre_uint32('\t'):
							fallthrough
						case pcre_uint32(' '):
							fallthrough
						case pcre_uint32((uint8('\u00a0'))):
							fallthrough
						case pcre_uint32(int32(5760)):
							fallthrough
						case pcre_uint32(int32(6158)):
							fallthrough
						case pcre_uint32(int32(8192)):
							fallthrough
						case pcre_uint32(int32(8193)):
							fallthrough
						case pcre_uint32(int32(8194)):
							fallthrough
						case pcre_uint32(int32(8195)):
							fallthrough
						case pcre_uint32(int32(8196)):
							fallthrough
						case pcre_uint32(int32(8197)):
							fallthrough
						case pcre_uint32(int32(8198)):
							fallthrough
						case pcre_uint32(int32(8199)):
							fallthrough
						case pcre_uint32(int32(8200)):
							fallthrough
						case pcre_uint32(int32(8201)):
							fallthrough
						case pcre_uint32(int32(8202)):
							fallthrough
						case pcre_uint32(int32(8239)):
							fallthrough
						case pcre_uint32(int32(8287)):
							fallthrough
						case pcre_uint32(int32(12288)):
							fallthrough
						case pcre_uint32('\n'):
							fallthrough
						case pcre_uint32('\v'):
							fallthrough
						case pcre_uint32('\f'):
							fallthrough
						case pcre_uint32('\r'):
							fallthrough
						case pcre_uint32((uint8('\u0085'))):
							fallthrough
						case pcre_uint32(int32(8232)):
							fallthrough
						case pcre_uint32(int32(8233)):
							{
								if op == uint32(OP_NOTPROP) {
									return int32(0)
								}
							}
						default:
							{
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
								}())) == pcre_uint32((uint32(ucp_Z)))) == (op == uint32(OP_NOTPROP)) {
									return int32(0)
								}
								break
							}
						}
					}
				case int32(8):
					{
						if (((*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
						}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucp_gentype[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
						}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_'))))) == (op == uint32(OP_NOTPROP)) {
							return int32(0)
						}
					}
				case int32(9):
					{
						cp = ((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_caseless_sets[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
						}()))
						for {
							if c < *cp {
								if op == uint32(OP_PROP) {
									return int32(0)
								} else {
									break
								}
							}
							if c == *func() *pcre_uint32 {
								defer func() {
									cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
								}()
								return cp
							}() {
								if op == uint32(OP_PROP) {
									break
								} else {
									return int32(0)
								}
							}
						}
					}
				case int32(10):
					{
						if (((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344)))))) == (op == uint32(OP_NOTPROP)) {
							return int32(0)
						}
					}
				default:
					{
						return (-int32(14))
					}
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_463:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			} else {
				var lgb int32
				var rgb int32
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}())))))
				if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
					}
				}
				lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_records[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage2[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage1[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
						}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
					}()))))))*unsafe.Sizeof(*tempVar))
				}()))).gbprop))))
				for int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					var len int32 = int32(1)
					if int32((NotBOOL(BOOL(utf)))) != 0 {
						c = pcre_uint32((uint32(uint8((*eptr)))))
					} else {
						c = pcre_uint32((uint32(uint8((*eptr)))))
						if c >= pcre_uint32((uint32(int32(192)))) {
							if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += 1
							} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(2)
							} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(3)
							} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(4)
							} else {
								c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(5)
							}
						}
					}
					rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).gbprop))))
					if (*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gbtable[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
					}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
						break
					}
					lgb = rgb
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
				}
			}
			if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
				(*md).hitend = BOOL((int32(1)))
				if (*md).partial > int32(1) {
					return (-int32(12))
				}
			}
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_464:
		;
	SW_GENERATED_LABEL_465:
		{
			caseless = BOOL((map[bool]int32{false: 0, true: 1}[(op == uint32(OP_DNREFI))]))
			{
				var count int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
				var slot *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*md).name_table
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*uint32((*md).name_entry_size))))*unsafe.Sizeof(*tempVar))
				}()))
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*ecode))))
				length = func() int32 {
					if int32((BOOL(((*md).jscript_compat)))) != 0 {
						return int32(0)
					} else {
						return -int32(1)
					}
				}()
				offset = int32(0)
				for func() int32 {
					defer func() {
						count -= 1
					}()
					return count
				}() > int32(0) {
					offset = int32((uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot)))))))))) << uint64(int32(1))))
					if (offset < offset_top) && (*((*int32)(func() unsafe.Pointer {
						tempVar := (*md).offset_vector
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
					}())) >= int32(0)) {
						length = (*((*int32)(func() unsafe.Pointer {
							tempVar := (*md).offset_vector
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
						}())) - *((*int32)(func() unsafe.Pointer {
							tempVar := (*md).offset_vector
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
						}())))
						break
					}
					slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)((*md).name_entry_size)*unsafe.Sizeof(*slot))))
				}
			}
			goto REF_REPEAT
		}
	SW_GENERATED_LABEL_466:
		;
	SW_GENERATED_LABEL_467:
		{
			caseless = BOOL((map[bool]int32{false: 0, true: 1}[(op == uint32(OP_REFI))]))
			offset = int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))) << uint64(int32(1))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			if (offset >= offset_top) || (*((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
			}())) < int32(0)) {
				length = func() int32 {
					if int32((BOOL(((*md).jscript_compat)))) != 0 {
						return int32(0)
					} else {
						return -int32(1)
					}
				}()
			} else {
				length = (*((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((offset+int32(1)))*unsafe.Sizeof(*tempVar))
				}())) - *((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(offset)*unsafe.Sizeof(*tempVar))
				}())))
			}
		}
	REF_REPEAT:
		{
			switch int32(uint8((pcre_uchar(*ecode)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				{
					c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}()
						return ecode
					}()))) - OP_CRSTAR))))
					minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
					min = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_min[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					max = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_max[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					if max == int32(0) {
						max = int32(2147483647)
					}
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				{
					minimize = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_CRMINRANGE)]))
					min = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					if max == int32(0) {
						max = int32(2147483647)
					}
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*ecode))))
				}
			default:
				{
					if (func() int32 {
						tempVar := match_ref(offset, eptr, length, md, BOOL(caseless))
						length = tempVar
						return tempVar
					}()) < int32(0) {
						if length == -int32(2) {
							eptr = (*md).end_subject
						}
						if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(length)*unsafe.Sizeof(*eptr))))
					continue
				}
			}
			if length == int32(0) {
				continue
			}
			if (length < int32(0)) && (min == int32(0)) {
				continue
			}
			for i = int32(1); i <= min; i++ {
				var slength int32
				if (func() int32 {
					tempVar := match_ref(offset, eptr, length, md, BOOL(caseless))
					slength = tempVar
					return tempVar
				}()) < int32(0) {
					if slength == -int32(2) {
						eptr = (*md).end_subject
					}
					if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					return int32(0)
				}
				eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(slength)*unsafe.Sizeof(*eptr))))
			}
			if min == max {
				continue
			}
			if int32((BOOL(minimize))) != 0 {
				for i = min; ; i++ {
					var slength int32
					rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					if i >= max {
						return int32(0)
					}
					if (func() int32 {
						tempVar := match_ref(offset, eptr, length, md, BOOL(caseless))
						slength = tempVar
						return tempVar
					}()) < int32(0) {
						if slength == -int32(2) {
							eptr = (*md).end_subject
						}
						if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(slength)*unsafe.Sizeof(*eptr))))
				}
			} else {
				pp = eptr
				for i = min; i < max; i++ {
					var slength int32
					if (func() int32 {
						tempVar := match_ref(offset, eptr, length, md, BOOL(caseless))
						slength = tempVar
						return tempVar
					}()) < int32(0) {
						if ((slength == -int32(2)) && ((*md).partial != int32(0))) && (int64(uintptr(unsafe.Pointer((*md).end_subject))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						break
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(slength)*unsafe.Sizeof(*eptr))))
				}
				for int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer(pp))) {
					rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(length)*unsafe.Sizeof(*eptr))))
				}
				return int32(0)
			}
		}
	SW_GENERATED_LABEL_468:
		;
	SW_GENERATED_LABEL_469:
		{
			data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32((uint32(int32(1))+(uint32(int32(32))/1))))*unsafe.Sizeof(*ecode))))
			switch int32(uint8((pcre_uchar(*ecode)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSPLUS:
				fallthrough
			case OP_CRPOSQUERY:
				{
					c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}()
						return ecode
					}()))) - OP_CRSTAR))))
					if c < pcre_uint32((uint32((OP_CRPOSSTAR - OP_CRSTAR)))) {
						minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
					} else {
						possessive = BOOL((int32(1)))
					}
					min = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_min[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					max = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_max[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					if max == int32(0) {
						max = int32(2147483647)
					}
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					minimize = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_CRMINRANGE)]))
					possessive = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_CRPOSRANGE)]))
					min = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					if max == int32(0) {
						max = int32(2147483647)
					}
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*ecode))))
				}
			default:
				{
					max = int32(1)
					min = max
					break
				}
			}
			if int32((BOOL(utf))) != 0 {
				for i = int32(1); i <= min; i++ {
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}())))))
					if c >= pcre_uint32((uint32(int32(192)))) {
						if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}()))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
						} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
						} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
						} else {
							c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
						}
					}
					if c > pcre_uint32((uint32(int32(255)))) {
						if op == uint32(OP_CLASS) {
							return int32(0)
						}
					} else if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
						return int32(0)
					}
				}
			} else {
				for i = int32(1); i <= min; i++ {
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}())))))
					if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
					}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
						return int32(0)
					}
				}
			}
			if min == max {
				continue
			}
			if int32((BOOL(minimize))) != 0 {
				if int32((BOOL(utf))) != 0 {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						if c >= pcre_uint32((uint32(int32(192)))) {
							if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}()))) & int32(63))))))
							} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
							} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
							} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
							} else {
								c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
							}
						}
						if c > pcre_uint32((uint32(int32(255)))) {
							if op == uint32(OP_CLASS) {
								return int32(0)
							}
						} else if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
							return int32(0)
						}
					}
				} else {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
							return int32(0)
						}
					}
				}
			} else {
				pp = eptr
				if int32((BOOL(utf))) != 0 {
					for i = min; i < max; i++ {
						var len int32 = int32(1)
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							break
						}
						c = pcre_uint32((uint32(uint8((*eptr)))))
						if c >= pcre_uint32((uint32(int32(192)))) {
							if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += 1
							} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(2)
							} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(3)
							} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(4)
							} else {
								c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								len += int32(5)
							}
						}
						if c > pcre_uint32((uint32(int32(255)))) {
							if op == uint32(OP_CLASS) {
								break
							}
						} else if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
							break
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if int64(uintptr(unsafe.Pointer(func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))) <= int64(uintptr(unsafe.Pointer(pp))) {
							break
						}
						for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				} else {
					for i = min; i < max; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							break
						}
						c = pcre_uint32((uint32(uint8((*eptr)))))
						if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := ((*pcre_uint8)(unsafe.Pointer(data)))
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
						}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) == int32(0) {
							break
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer(pp))) {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
				}
				return int32(0)
			}
		}
	SW_GENERATED_LABEL_470:
		{
			data = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode))))))))))*unsafe.Sizeof(*ecode))))
			switch int32(uint8((pcre_uchar(*ecode)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSPLUS:
				fallthrough
			case OP_CRPOSQUERY:
				{
					c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}()
						return ecode
					}()))) - OP_CRSTAR))))
					if c < pcre_uint32((uint32((OP_CRPOSSTAR - OP_CRSTAR)))) {
						minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
					} else {
						possessive = BOOL((int32(1)))
					}
					min = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_min[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					max = int32(*((*byte)(func() unsafe.Pointer {
						tempVar := &rep_max[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))
					if max == int32(0) {
						max = int32(2147483647)
					}
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					minimize = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_CRMINRANGE)]))
					possessive = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_CRPOSRANGE)]))
					min = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
					if max == int32(0) {
						max = int32(2147483647)
					}
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*ecode))))
				}
			default:
				{
					max = int32(1)
					min = max
					break
				}
			}
			for i = int32(1); i <= min; i++ {
				if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
					if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					return int32(0)
				}
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}())))))
				if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
					}
				}
				if int32((NotBOOL(_pcre_xclass(pcre_uint32(c), data, BOOL(utf))))) != 0 {
					return int32(0)
				}
			}
			if min == max {
				continue
			}
			if int32((BOOL(minimize))) != 0 {
				for i = min; ; i++ {
					rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					if i >= max {
						return int32(0)
					}
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}())))))
					if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
						if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}()))) & int32(63))))))
						} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
						} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
						} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
						} else {
							c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
						}
					}
					if int32((NotBOOL(_pcre_xclass(pcre_uint32(c), data, BOOL(utf))))) != 0 {
						return int32(0)
					}
				}
			} else {
				pp = eptr
				for i = min; i < max; i++ {
					var len int32 = int32(1)
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						break
					}
					c = pcre_uint32((uint32(uint8((*eptr)))))
					if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
						if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							len += 1
						} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							len += int32(2)
						} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							len += int32(3)
						} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							len += int32(4)
						} else {
							c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							len += int32(5)
						}
					}
					if int32((NotBOOL(_pcre_xclass(pcre_uint32(c), data, BOOL(utf))))) != 0 {
						break
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
				}
				if int32((BOOL(possessive))) != 0 {
					continue
				}
				for {
					rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
					if rrc != int32(0) {
						return rrc
					}
					if int64(uintptr(unsafe.Pointer(func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) <= int64(uintptr(unsafe.Pointer(pp))) {
						break
					}
					if int32((BOOL(utf))) != 0 {
						for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				}
				return int32(0)
			}
		}
	SW_GENERATED_LABEL_471:
		{
			if int32((BOOL(utf))) != 0 {
				length = int32(1)
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				c = pcre_uint32((uint32(uint8((*ecode)))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += 1
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(2)
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(3)
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(4)
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(5))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(5)
					}
				}
				if length > int32((int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer(eptr))))) {
					if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					return int32(0)
				}
				for func() int32 {
					defer func() {
						length -= 1
					}()
					return length
				}() > int32(0) {
					if int32(uint8((*func() *pcre_uchar {
						defer func() {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}()
						return ecode
					}()))) != int32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))) {
						return int32(0)
					}
				}
			} else {
				if (int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer(eptr)))) < int64(int32(1)) {
					if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
						(*md).hitend = BOOL((int32(1)))
						if (*md).partial > int32(1) {
							return (-int32(12))
						}
					}
					return int32(0)
				}
				if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) != int32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}()))) {
					return int32(0)
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_472:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			if int32((BOOL(utf))) != 0 {
				length = int32(1)
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				c = pcre_uint32((uint32(uint8((*ecode)))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += 1
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(2)
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(3)
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(4)
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(5))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(5)
					}
				}
				if c < pcre_uint32((uint32(int32(128)))) {
					var cc pcre_uint32 = pcre_uint32((uint32(uint8((*eptr)))))
					if int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := (*md).lcc
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}()))))) != int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := ((*md).lcc)
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
					}()))))) {
						return int32(0)
					}
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				} else {
					var dc pcre_uint32
					dc = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}())))))
					if dc >= pcre_uint32((uint32(int32(192)))) {
						if (dc & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
							dc = (((dc & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}()))) & int32(63))))))
						} else if (dc & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
							dc = ((((dc & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
						} else if (dc & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
							dc = (((((dc & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
						} else if (dc & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
							dc = ((((((dc & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
						} else {
							dc = (((((((dc & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
						}
					}
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(length)*unsafe.Sizeof(*ecode))))
					if c != dc {
						if dc != pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).other_case)))))) {
							return int32(0)
						}
					}
				}
			} else {
				if int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).lcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))))*unsafe.Sizeof(*tempVar))
				}()))))) != int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).lcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
				}()))))) {
					return int32(0)
				}
				eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_473:
		;
	SW_GENERATED_LABEL_474:
		{
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			min = max
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATCHAR
		}
	SW_GENERATED_LABEL_475:
		;
	SW_GENERATED_LABEL_476:
		{
			possessive = BOOL((int32(1)))
		}
	SW_GENERATED_LABEL_477:
		;
	SW_GENERATED_LABEL_478:
		;
	SW_GENERATED_LABEL_479:
		;
	SW_GENERATED_LABEL_480:
		{
			min = int32(0)
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[((int32(uint8((*ecode))) == OP_MINUPTO) || (int32(uint8((*ecode))) == OP_MINUPTOI))]))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATCHAR
		}
	SW_GENERATED_LABEL_481:
		;
	SW_GENERATED_LABEL_482:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATCHAR
		}
	SW_GENERATED_LABEL_483:
		;
	SW_GENERATED_LABEL_484:
		{
			possessive = BOOL((int32(1)))
			min = int32(1)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATCHAR
		}
	SW_GENERATED_LABEL_485:
		;
	SW_GENERATED_LABEL_486:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(1)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATCHAR
		}
	SW_GENERATED_LABEL_487:
		;
	SW_GENERATED_LABEL_488:
		;
	SW_GENERATED_LABEL_489:
		;
	SW_GENERATED_LABEL_490:
		;
	SW_GENERATED_LABEL_491:
		;
	SW_GENERATED_LABEL_492:
		;
	SW_GENERATED_LABEL_493:
		;
	SW_GENERATED_LABEL_494:
		;
	SW_GENERATED_LABEL_495:
		;
	SW_GENERATED_LABEL_496:
		;
	SW_GENERATED_LABEL_497:
		;
	SW_GENERATED_LABEL_498:
		{
			c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
				defer func() {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				}()
				return ecode
			}()))) - func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(op < uint32(OP_STARI))]) != 0 {
					return OP_STAR
				} else {
					return OP_STARI
				}
			}()))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
			min = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_min[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			max = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_max[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			if max == int32(0) {
				max = int32(2147483647)
			}
		}
	REPEATCHAR:
		{
			if int32((BOOL(utf))) != 0 {
				length = int32(1)
				charptr = ecode
				c = pcre_uint32((uint32(uint8((*ecode)))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += 1
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(2)
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(3)
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(4)
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(5))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						length += int32(5)
					}
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(length)*unsafe.Sizeof(*ecode))))
				if length > int32(1) {
					var othercase pcre_uint32
					if (op >= uint32(OP_STARI)) && ((func() pcre_uint32 {
						tempVar := pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).other_case))))))
						othercase = tempVar
						return tempVar
					}()) != c) {
						oclength = int32(_pcre_ord2utf(pcre_uint32(othercase), &occhars[0]))
					} else {
						oclength = int32(0)
					}
					for i = int32(1); i <= min; i++ {
						if (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(length)*unsafe.Sizeof(*tempVar))
						}())))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(charptr), int32(uint32((length)))) == int32(0)) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(length)*unsafe.Sizeof(*eptr))))
						} else if ((oclength > int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(oclength)*unsafe.Sizeof(*tempVar))
						}()))))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(&occhars[0]), int32(uint32((oclength)))) == int32(0)) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(oclength)*unsafe.Sizeof(*eptr))))
						} else {
							if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
					}
					if min == max {
						continue
					}
					if int32((BOOL(minimize))) != 0 {
						for i = min; ; i++ {
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							if i >= max {
								return int32(0)
							}
							if (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(length)*unsafe.Sizeof(*tempVar))
							}())))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(charptr), int32(uint32((length)))) == int32(0)) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(length)*unsafe.Sizeof(*eptr))))
							} else if ((oclength > int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(oclength)*unsafe.Sizeof(*tempVar))
							}()))))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(&occhars[0]), int32(uint32((oclength)))) == int32(0)) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(oclength)*unsafe.Sizeof(*eptr))))
							} else {
								if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
						}
					} else {
						pp = eptr
						for i = min; i < max; i++ {
							if (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(length)*unsafe.Sizeof(*tempVar))
							}())))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(charptr), int32(uint32((length)))) == int32(0)) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(length)*unsafe.Sizeof(*eptr))))
							} else if ((oclength > int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(oclength)*unsafe.Sizeof(*tempVar))
							}()))))))) && (noarch.Memcmp(unsafe.Pointer(eptr), unsafe.Pointer(&occhars[0]), int32(uint32((oclength)))) == int32(0)) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(oclength)*unsafe.Sizeof(*eptr))))
							} else {
								if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
						}
						if int32((BOOL(possessive))) != 0 {
							continue
						}
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					}
				}
			} else {
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					}()
					return ecode
				}())))))
			}
			if op >= uint32(OP_STARI) {
				number = uint32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := (*md).fcc
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
				}())))))
				for i = int32(1); i <= min; i++ {
					var cc pcre_uint32
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					cc = pcre_uint32((uint32(uint8((*eptr)))))
					if (c != cc) && (number != uint32((cc))) {
						return int32(0)
					}
					eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
				}
				if min == max {
					continue
				}
				if int32((BOOL(minimize))) != 0 {
					for i = min; ; i++ {
						var cc pcre_uint32
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						cc = pcre_uint32((uint32(uint8((*eptr)))))
						if (c != cc) && (number != uint32((cc))) {
							return int32(0)
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
				} else {
					pp = eptr
					for i = min; i < max; i++ {
						var cc pcre_uint32
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							break
						}
						cc = pcre_uint32((uint32(uint8((*eptr)))))
						if (c != cc) && (number != uint32((cc))) {
							break
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						if rrc != int32(0) {
							return rrc
						}
					}
				}
			} else {
				for i = int32(1); i <= min; i++ {
					if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
						if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
						return int32(0)
					}
					if c != pcre_uint32((uint32(uint8((*func() *pcre_uchar {
						defer func() {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}()
						return eptr
					}()))))) {
						return int32(0)
					}
				}
				if min == max {
					continue
				}
				if int32((BOOL(minimize))) != 0 {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						if c != pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))))) {
							return int32(0)
						}
					}
				} else {
					pp = eptr
					for i = min; i < max; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							break
						}
						if c != pcre_uint32((uint32(uint8((*eptr))))) {
							break
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						if rrc != int32(0) {
							return rrc
						}
					}
				}
			}
		}
	SW_GENERATED_LABEL_499:
		;
	SW_GENERATED_LABEL_500:
		{
			if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
				if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
					(*md).hitend = BOOL((int32(1)))
					if (*md).partial > int32(1) {
						return (-int32(12))
					}
				}
				return int32(0)
			}
			if int32((BOOL(utf))) != 0 {
				var ch pcre_uint32
				var och pcre_uint32
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				ch = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					}()
					return ecode
				}())))))
				if ch >= pcre_uint32((uint32(int32(192)))) {
					if (ch & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						ch = (((ch & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
							}()
							return ecode
						}()))) & int32(63))))))
					} else if (ch & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						ch = ((((ch & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
					} else if (ch & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						ch = (((((ch & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))
					} else if (ch & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						ch = ((((((ch & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))
					} else {
						ch = (((((((ch & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(5))*unsafe.Sizeof(*ecode))))
					}
				}
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}())))))
				if c >= pcre_uint32((uint32(int32(192)))) {
					if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))) & int32(63))))))
					} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
					} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
					} else {
						c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
					}
				}
				if op == uint32(OP_NOT) {
					if ch == c {
						return int32(0)
					}
				} else {
					if ch > pcre_uint32((uint32(int32(127)))) {
						och = pcre_uint32((int32(uint32((pcre_uint32(ch)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((ch)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((ch)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).other_case))))))
					} else {
						och = pcre_uint32((uint32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
							tempVar := ((*md).fcc)
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((ch))))*unsafe.Sizeof(*tempVar))
						}())))))))
					}
					if (ch == c) || (och == c) {
						return int32(0)
					}
				}
			} else {
				var ch pcre_uint32 = pcre_uint32((uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode)))))))))
				c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}()
					return eptr
				}())))))
				if (ch == c) || ((op == uint32(OP_NOTI)) && (uint32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).fcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((ch))))*unsafe.Sizeof(*tempVar))
				}()))))) == uint32((c)))) {
					return int32(0)
				}
				ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
			}
		}
		goto SW_GENERATED_LABEL_394
	SW_GENERATED_LABEL_501:
		;
	SW_GENERATED_LABEL_502:
		{
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			min = max
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_503:
		;
	SW_GENERATED_LABEL_504:
		;
	SW_GENERATED_LABEL_505:
		;
	SW_GENERATED_LABEL_506:
		{
			min = int32(0)
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[((int32(uint8((*ecode))) == OP_NOTMINUPTO) || (int32(uint8((*ecode))) == OP_NOTMINUPTOI))]))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_507:
		;
	SW_GENERATED_LABEL_508:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_509:
		;
	SW_GENERATED_LABEL_510:
		{
			possessive = BOOL((int32(1)))
			min = int32(1)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_511:
		;
	SW_GENERATED_LABEL_512:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(1)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_513:
		;
	SW_GENERATED_LABEL_514:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATNOTCHAR
		}
	SW_GENERATED_LABEL_515:
		;
	SW_GENERATED_LABEL_516:
		;
	SW_GENERATED_LABEL_517:
		;
	SW_GENERATED_LABEL_518:
		;
	SW_GENERATED_LABEL_519:
		;
	SW_GENERATED_LABEL_520:
		;
	SW_GENERATED_LABEL_521:
		;
	SW_GENERATED_LABEL_522:
		;
	SW_GENERATED_LABEL_523:
		;
	SW_GENERATED_LABEL_524:
		;
	SW_GENERATED_LABEL_525:
		;
	SW_GENERATED_LABEL_526:
		{
			c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
				defer func() {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				}()
				return ecode
			}()))) - func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(op >= uint32(OP_NOTSTARI))]) != 0 {
					return OP_NOTSTARI
				} else {
					return OP_NOTSTAR
				}
			}()))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
			min = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_min[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			max = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_max[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			if max == int32(0) {
				max = int32(2147483647)
			}
		}
	REPEATNOTCHAR:
		{
			c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
				defer func() {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				}()
				return ecode
			}())))))
			if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
				if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
						defer func() {
							ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
						}()
						return ecode
					}()))) & int32(63))))))
				} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))
				} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
					c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))
				} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
					c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))
				} else {
					c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*ecode))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(1))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(2))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(3))*unsafe.Sizeof(*ecode))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(4))*unsafe.Sizeof(*ecode))))))) & int32(63))))))
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(int32(5))*unsafe.Sizeof(*ecode))))
				}
			}
			if op >= uint32(OP_NOTSTARI) {
				if (int32((utf)) != 0) && (c > pcre_uint32((uint32(int32(127))))) {
					number = uint32((pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_records[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_stage2[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage1[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
							}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
						}()))))))*unsafe.Sizeof(*tempVar))
					}()))).other_case))))))))
				} else {
					number = uint32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := ((*md).fcc)
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
					}())))))
				}
				if int32((BOOL(utf))) != 0 {
					var d pcre_uint32
					for i = int32(1); i <= min; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						d = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						if d >= pcre_uint32((uint32(int32(192)))) {
							if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}()))) & int32(63))))))
							} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
							} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
							} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
							} else {
								d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
							}
						}
						if (c == d) || (number == uint32((d))) {
							return int32(0)
						}
					}
				} else {
					for i = int32(1); i <= min; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						if (c == pcre_uint32((uint32(uint8((*eptr)))))) || (number == uint32(uint8((*eptr)))) {
							return int32(0)
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
					}
				}
				if min == max {
					continue
				}
				if int32((BOOL(minimize))) != 0 {
					if int32((BOOL(utf))) != 0 {
						var d pcre_uint32
						for i = min; ; i++ {
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							if i >= max {
								return int32(0)
							}
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							d = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}())))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
										defer func() {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}()
										return eptr
									}()))) & int32(63))))))
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
								}
							}
							if (c == d) || (number == uint32((d))) {
								return int32(0)
							}
						}
					} else {
						for i = min; ; i++ {
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							if i >= max {
								return int32(0)
							}
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							if (c == pcre_uint32((uint32(uint8((*eptr)))))) || (number == uint32(uint8((*eptr)))) {
								return int32(0)
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				} else {
					pp = eptr
					if int32((BOOL(utf))) != 0 {
						var d pcre_uint32
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							d = pcre_uint32((uint32(uint8((*eptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if (c == d) || (number == uint32((d))) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
						if int32((BOOL(possessive))) != 0 {
							continue
						}
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					} else {
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (c == pcre_uint32((uint32(uint8((*eptr)))))) || (number == uint32(uint8((*eptr)))) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
						if int32((BOOL(possessive))) != 0 {
							continue
						}
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				}
			} else {
				if int32((BOOL(utf))) != 0 {
					var d pcre_uint32
					for i = int32(1); i <= min; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						d = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						if d >= pcre_uint32((uint32(int32(192)))) {
							if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}()))) & int32(63))))))
							} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
							} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
							} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
							} else {
								d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
							}
						}
						if c == d {
							return int32(0)
						}
					}
				} else {
					for i = int32(1); i <= min; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						if c == pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}()))))) {
							return int32(0)
						}
					}
				}
				if min == max {
					continue
				}
				if int32((BOOL(minimize))) != 0 {
					if int32((BOOL(utf))) != 0 {
						var d pcre_uint32
						for i = min; ; i++ {
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							if i >= max {
								return int32(0)
							}
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							d = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}())))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
										defer func() {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}()
										return eptr
									}()))) & int32(63))))))
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
								}
							}
							if c == d {
								return int32(0)
							}
						}
					} else {
						for i = min; ; i++ {
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							if i >= max {
								return int32(0)
							}
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							if c == pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}()))))) {
								return int32(0)
							}
						}
					}
				} else {
					pp = eptr
					if int32((BOOL(utf))) != 0 {
						var d pcre_uint32
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							d = pcre_uint32((uint32(uint8((*eptr)))))
							if d >= pcre_uint32((uint32(int32(192)))) {
								if (d & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((d & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (d & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((d & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (d & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									d = (((((d & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (d & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									d = ((((((d & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									d = (((((((d & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if c == d {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
						if int32((BOOL(possessive))) != 0 {
							continue
						}
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					} else {
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if c == pcre_uint32((uint32(uint8((*eptr))))) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
						if int32((BOOL(possessive))) != 0 {
							continue
						}
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
							if rrc != int32(0) {
								return rrc
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				}
			}
		}
	SW_GENERATED_LABEL_527:
		{
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			min = max
			minimize = BOOL((int32(1)))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_528:
		;
	SW_GENERATED_LABEL_529:
		{
			min = int32(0)
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ecode))) == OP_TYPEMINUPTO)]))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_530:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_531:
		{
			possessive = BOOL((int32(1)))
			min = int32(1)
			max = int32(2147483647)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_532:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(1)
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_533:
		{
			possessive = BOOL((int32(1)))
			min = int32(0)
			max = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ecode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ecode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ecode)))))))))))
			ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*ecode))))
			goto REPEATTYPE
		}
	SW_GENERATED_LABEL_534:
		;
	SW_GENERATED_LABEL_535:
		;
	SW_GENERATED_LABEL_536:
		;
	SW_GENERATED_LABEL_537:
		;
	SW_GENERATED_LABEL_538:
		;
	SW_GENERATED_LABEL_539:
		{
			c = pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
				defer func() {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				}()
				return ecode
			}()))) - OP_TYPESTAR))))
			minimize = BOOL((map[bool]int32{false: 0, true: 1}[((c & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0)))))]))
			min = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_min[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			max = int32(*((*byte)(func() unsafe.Pointer {
				tempVar := &rep_max[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
			}())))
			if max == int32(0) {
				max = int32(2147483647)
			}
		}
	REPEATTYPE:
		{
			ctype = int32(uint8((*func() *pcre_uchar {
				defer func() {
					ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
				}()
				return ecode
			}())))
			if (ctype == OP_PROP) || (ctype == OP_NOTPROP) {
				prop_fail_result = map[bool]int32{false: 0, true: 1}[(ctype == OP_NOTPROP)]
				prop_type = int32(uint8((*func() *pcre_uchar {
					defer func() {
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					}()
					return ecode
				}())))
				prop_value = uint32(uint8((*func() *pcre_uchar {
					defer func() {
						ecode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ecode)) + (uintptr)(1)*unsafe.Sizeof(*ecode))))
					}()
					return ecode
				}())))
			} else {
				prop_type = -int32(1)
			}
			if min > int32(0) {
				if prop_type >= int32(0) {
					switch prop_type {
					case int32(0):
						{
							if prop_fail_result != 0 {
								return int32(0)
							}
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
							}
						}
					case int32(1):
						{
							for i = int32(1); i <= min; i++ {
								var chartype int32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								chartype = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype))))
								if (((chartype == ucp_Lu) || (chartype == ucp_Ll)) || (chartype == ucp_Lt)) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(2):
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())) == pcre_uint32((prop_value))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(3):
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))) == prop_value) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(4):
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).script)))) == prop_value) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(5):
						{
							for i = int32(1); i <= min; i++ {
								var category int32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())))))
								if ((category == ucp_L) || (category == ucp_N)) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(6):
						fallthrough
					case int32(7):
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									fallthrough
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										if prop_fail_result != 0 {
											return int32(0)
										}
									}
								default:
									{
										if (*((*pcre_uint32)(func() unsafe.Pointer {
											tempVar := &_pcre_ucp_gentype[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_records[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
													tempVar := &_pcre_ucd_stage2[0]
													return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
														tempVar := &_pcre_ucd_stage1[0]
														return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
													}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
												}()))))))*unsafe.Sizeof(*tempVar))
											}()))).chartype)))))*unsafe.Sizeof(*tempVar))
										}())) == pcre_uint32((uint32(ucp_Z)))) == (prop_fail_result != 0) {
											return int32(0)
										}
										break
									}
								}
							}
						}
					case int32(8):
						{
							for i = int32(1); i <= min; i++ {
								var category int32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())))))
								if (((category == ucp_L) || (category == ucp_N)) || (c == pcre_uint32((uint32('_'))))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					case int32(9):
						{
							for i = int32(1); i <= min; i++ {
								var cp *pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								cp = ((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_caseless_sets[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(prop_value))*unsafe.Sizeof(*tempVar))
								}()))
								for {
									if c < *cp {
										if prop_fail_result != 0 {
											break
										} else {
											return int32(0)
										}
									}
									if c == *func() *pcre_uint32 {
										defer func() {
											cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
										}()
										return cp
									}() {
										if prop_fail_result != 0 {
											return int32(0)
										} else {
											break
										}
									}
								}
							}
						}
					case int32(10):
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344)))))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
					default:
						{
							return (-int32(14))
						}
					}
				} else if ctype == OP_EXTUNI {
					for i = int32(1); i <= min; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						} else {
							var lgb int32
							var rgb int32
							c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}())))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
										defer func() {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}()
										return eptr
									}()))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
								}
							}
							lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).gbprop))))
							for int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								var len int32 = int32(1)
								if int32((NotBOOL(BOOL(utf)))) != 0 {
									c = pcre_uint32((uint32(uint8((*eptr)))))
								} else {
									c = pcre_uint32((uint32(uint8((*eptr)))))
									if c >= pcre_uint32((uint32(int32(192)))) {
										if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += 1
										} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(2)
										} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(3)
										} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(4)
										} else {
											c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(5)
										}
									}
								}
								rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).gbprop))))
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gbtable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
								}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
									break
								}
								lgb = rgb
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
						if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
					}
				} else if int32((BOOL(utf))) != 0 {
					switch ctype {
					case OP_ANY:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (func() int32 {
									if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
										return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
									} else {
										return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*md).end_subject
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
										}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := &(*md).nl[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
										}()))))))))])
									}
								}()) != 0 {
									return int32(0)
								}
								if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_ALLANY:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_ANYBYTE:
						{
							if int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(min)*unsafe.Sizeof(*tempVar))
							}()))))) {
								return int32(0)
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(min)*unsafe.Sizeof(*eptr))))
						}
					case OP_ANYNL:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								default:
									{
										return int32(0)
									}
								case pcre_uint32('\r'):
									{
										if (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32(uint8((*eptr))) == int32('\n')) {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}
									}
								case pcre_uint32('\n'):
									{
									}
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										if int32((BOOL((*md).bsr_anycrlf))) != 0 {
											return int32(0)
										}
										break
									}
								}
							}
						}
					case OP_NOT_HSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									{
										return int32(0)
									}
								default:
									{
										break
									}
								}
							}
						}
					case OP_HSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									{
									}
								default:
									{
										return int32(0)
									}
								}
							}
						}
					case OP_NOT_VSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										return int32(0)
									}
								default:
									{
										break
									}
								}
							}
						}
					case OP_VSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
									}
								default:
									{
										return int32(0)
									}
								}
							}
						}
					case OP_NOT_DIGIT:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (c < pcre_uint32((uint32(int32(128))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) != int32(0)) {
									return int32(0)
								}
							}
						}
					case OP_DIGIT:
						{
							for i = int32(1); i <= min; i++ {
								var cc pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								cc = pcre_uint32((uint32(uint8((*eptr)))))
								if (cc >= pcre_uint32((uint32(int32(128))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WHITESPACE:
						{
							for i = int32(1); i <= min; i++ {
								var cc pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								cc = pcre_uint32((uint32(uint8((*eptr)))))
								if (cc < pcre_uint32((uint32(int32(128))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) != int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_WHITESPACE:
						{
							for i = int32(1); i <= min; i++ {
								var cc pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								cc = pcre_uint32((uint32(uint8((*eptr)))))
								if (cc >= pcre_uint32((uint32(int32(128))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WORDCHAR:
						{
							for i = int32(1); i <= min; i++ {
								var cc pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								cc = pcre_uint32((uint32(uint8((*eptr)))))
								if (cc < pcre_uint32((uint32(int32(128))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) != int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_WORDCHAR:
						{
							for i = int32(1); i <= min; i++ {
								var cc pcre_uint32
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								cc = pcre_uint32((uint32(uint8((*eptr)))))
								if (cc >= pcre_uint32((uint32(int32(128))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((cc))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					default:
						{
							return (-int32(14))
						}
					}
				} else {
					switch ctype {
					case OP_ANY:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (func() int32 {
									if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
										return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
									} else {
										return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*md).end_subject
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
										}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := &(*md).nl[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
										}()))))))))])
									}
								}()) != 0 {
									return int32(0)
								}
								if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_ALLANY:
						{
							if int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(min)*unsafe.Sizeof(*tempVar))
							}()))))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(min)*unsafe.Sizeof(*eptr))))
						}
					case OP_ANYBYTE:
						{
							if int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := (*md).end_subject
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)(min)*unsafe.Sizeof(*tempVar))
							}()))))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								return int32(0)
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(min)*unsafe.Sizeof(*eptr))))
						}
					case OP_ANYNL:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))) {
								default:
									{
										return int32(0)
									}
								case '\r':
									{
										if (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32(uint8((*eptr))) == int32('\n')) {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}
									}
								case '\n':
									{
									}
								case '\v':
									fallthrough
								case '\f':
									fallthrough
								case int32((uint8('\u0085'))):
									{
										if int32((BOOL((*md).bsr_anycrlf))) != 0 {
											return int32(0)
										}
										break
									}
								}
							}
						}
					case OP_NOT_HSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))) {
								default:
									{
									}
								case '\t':
									fallthrough
								case ' ':
									fallthrough
								case int32((uint8('\u00a0'))):
									{
										return int32(0)
									}
								}
							}
						}
					case OP_HSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))) {
								default:
									{
										return int32(0)
									}
								case '\t':
									fallthrough
								case ' ':
									fallthrough
								case int32((uint8('\u00a0'))):
									{
										break
									}
								}
							}
						}
					case OP_NOT_VSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))) {
								case '\n':
									fallthrough
								case '\v':
									fallthrough
								case '\f':
									fallthrough
								case '\r':
									fallthrough
								case int32((uint8('\u0085'))):
									{
										return int32(0)
									}
								default:
									{
										break
									}
								}
							}
						}
					case OP_VSPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								switch int32(uint8((pcre_uchar(*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))) {
								default:
									{
										return int32(0)
									}
								case '\n':
									fallthrough
								case '\v':
									fallthrough
								case '\f':
									fallthrough
								case '\r':
									fallthrough
								case int32((uint8('\u0085'))):
									{
										break
									}
								}
							}
						}
					case OP_NOT_DIGIT:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) != int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_DIGIT:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WHITESPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) != int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_WHITESPACE:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WORDCHAR:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) != int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_WORDCHAR:
						{
							for i = int32(1); i <= min; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) == int32(0)) {
									return int32(0)
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					default:
						{
							return (-int32(14))
						}
					}
				}
			}
			if min == max {
				continue
			}
			if int32((BOOL(minimize))) != 0 {
				if prop_type >= int32(0) {
					switch prop_type {
					case int32(0):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if prop_fail_result != 0 {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(1):
						{
							for i = min; ; i++ {
								var chartype int32
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								chartype = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype))))
								if (((chartype == ucp_Lu) || (chartype == ucp_Ll)) || (chartype == ucp_Lt)) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(2):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())) == pcre_uint32((prop_value))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(3):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))) == prop_value) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(4):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).script)))) == prop_value) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(5):
						{
							for i = min; ; i++ {
								var category int32
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())))))
								if ((category == ucp_L) || (category == ucp_N)) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(6):
						fallthrough
					case int32(7):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									fallthrough
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										if prop_fail_result != 0 {
											return int32(0)
										}
									}
								default:
									{
										if (*((*pcre_uint32)(func() unsafe.Pointer {
											tempVar := &_pcre_ucp_gentype[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_records[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
													tempVar := &_pcre_ucd_stage2[0]
													return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
														tempVar := &_pcre_ucd_stage1[0]
														return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
													}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
												}()))))))*unsafe.Sizeof(*tempVar))
											}()))).chartype)))))*unsafe.Sizeof(*tempVar))
										}())) == pcre_uint32((uint32(ucp_Z)))) == (prop_fail_result != 0) {
											return int32(0)
										}
										break
									}
								}
							}
						}
						fallthrough
					case int32(8):
						{
							for i = min; ; i++ {
								var category int32
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gentype[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_records[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage2[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage1[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
											}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
										}()))))))*unsafe.Sizeof(*tempVar))
									}()))).chartype)))))*unsafe.Sizeof(*tempVar))
								}())))))
								if (((category == ucp_L) || (category == ucp_N)) || (c == pcre_uint32((uint32('_'))))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					case int32(9):
						{
							for i = min; ; i++ {
								var cp *pcre_uint32
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								cp = ((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_caseless_sets[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(prop_value))*unsafe.Sizeof(*tempVar))
								}()))
								for {
									if c < *cp {
										if prop_fail_result != 0 {
											break
										} else {
											return int32(0)
										}
									}
									if c == *func() *pcre_uint32 {
										defer func() {
											cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
										}()
										return cp
									}() {
										if prop_fail_result != 0 {
											return int32(0)
										} else {
											break
										}
									}
								}
							}
						}
						fallthrough
					case int32(10):
						{
							for i = min; ; i++ {
								rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
								if rrc != int32(0) {
									return rrc
								}
								if i >= max {
									return int32(0)
								}
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									return int32(0)
								}
								c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}())))))
								if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
											defer func() {
												eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
											}()
											return eptr
										}()))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
									}
								}
								if (((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344)))))) == (prop_fail_result != 0) {
									return int32(0)
								}
							}
						}
						fallthrough
					default:
						{
							return (-int32(14))
						}
					}
				} else if ctype == OP_EXTUNI {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						} else {
							var lgb int32
							var rgb int32
							c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}())))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
										defer func() {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}()
										return eptr
									}()))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
								}
							}
							lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).gbprop))))
							for int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								var len int32 = int32(1)
								if int32((NotBOOL(BOOL(utf)))) != 0 {
									c = pcre_uint32((uint32(uint8((*eptr)))))
								} else {
									c = pcre_uint32((uint32(uint8((*eptr)))))
									if c >= pcre_uint32((uint32(int32(192)))) {
										if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += 1
										} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(2)
										} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(3)
										} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(4)
										} else {
											c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(5)
										}
									}
								}
								rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).gbprop))))
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gbtable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
								}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
									break
								}
								lgb = rgb
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
						if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
					}
				} else if int32((BOOL(utf))) != 0 {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						if (ctype == OP_ANY) && (func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
							} else {
								return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*md).end_subject
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
								}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := &(*md).nl[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))))))))])
							}
						}() != 0) {
							return int32(0)
						}
						c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						if c >= pcre_uint32((uint32(int32(192)))) {
							if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
									defer func() {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}()
									return eptr
								}()))) & int32(63))))))
							} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
							} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
								c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
							} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
								c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
							} else {
								c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
							}
						}
						switch ctype {
						case OP_ANY:
							{
								if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
							}
						case OP_ALLANY:
							fallthrough
						case OP_ANYBYTE:
							{
							}
						case OP_ANYNL:
							{
								switch pcre_uint32(c) {
								default:
									{
										return int32(0)
									}
								case pcre_uint32('\r'):
									{
										if (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32(uint8((*eptr))) == int32('\n')) {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}
									}
								case pcre_uint32('\n'):
									{
									}
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										if int32((BOOL((*md).bsr_anycrlf))) != 0 {
											return int32(0)
										}
										break
									}
								}
							}
						case OP_NOT_HSPACE:
							{
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									{
										return int32(0)
									}
								default:
									{
										break
									}
								}
							}
						case OP_HSPACE:
							{
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									{
									}
								default:
									{
										return int32(0)
									}
								}
							}
						case OP_NOT_VSPACE:
							{
								switch pcre_uint32(c) {
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										return int32(0)
									}
								default:
									{
										break
									}
								}
							}
						case OP_VSPACE:
							{
								switch pcre_uint32(c) {
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
									}
								default:
									{
										return int32(0)
									}
								}
							}
						case OP_NOT_DIGIT:
							{
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_DIGIT:
							{
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) == int32(0)) {
									return int32(0)
								}
							}
						case OP_NOT_WHITESPACE:
							{
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_WHITESPACE:
							{
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) == int32(0)) {
									return int32(0)
								}
							}
						case OP_NOT_WORDCHAR:
							{
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_WORDCHAR:
							{
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) == int32(0)) {
									return int32(0)
								}
							}
						default:
							{
								return (-int32(14))
							}
						}
					}
				} else {
					for i = min; ; i++ {
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						if i >= max {
							return int32(0)
						}
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							return int32(0)
						}
						if (ctype == OP_ANY) && (func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
							} else {
								return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*md).end_subject
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
								}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := &(*md).nl[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))))))))])
							}
						}() != 0) {
							return int32(0)
						}
						c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
							defer func() {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}()
							return eptr
						}())))))
						switch ctype {
						case OP_ANY:
							{
								if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (c == pcre_uint32((uint32(uint8((*&(*md).nl[0])))))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
							}
						case OP_ALLANY:
							fallthrough
						case OP_ANYBYTE:
							{
							}
						case OP_ANYNL:
							{
								switch pcre_uint32(c) {
								default:
									{
										return int32(0)
									}
								case pcre_uint32('\r'):
									{
										if (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32(uint8((*eptr))) == int32('\n')) {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}
									}
								case pcre_uint32('\n'):
									{
									}
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									{
										if int32((BOOL((*md).bsr_anycrlf))) != 0 {
											return int32(0)
										}
										break
									}
								}
							}
						case OP_NOT_HSPACE:
							{
								switch pcre_uint32(c) {
								default:
									{
									}
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									{
										return int32(0)
									}
								}
							}
						case OP_HSPACE:
							{
								switch pcre_uint32(c) {
								default:
									{
										return int32(0)
									}
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									{
										break
									}
								}
							}
						case OP_NOT_VSPACE:
							{
								switch pcre_uint32(c) {
								default:
									{
									}
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									{
										return int32(0)
									}
								}
							}
						case OP_VSPACE:
							{
								switch pcre_uint32(c) {
								default:
									{
										return int32(0)
									}
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									{
										break
									}
								}
							}
						case OP_NOT_DIGIT:
							{
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_DIGIT:
							{
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) == int32(0)) {
									return int32(0)
								}
							}
						case OP_NOT_WHITESPACE:
							{
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_WHITESPACE:
							{
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) == int32(0)) {
									return int32(0)
								}
							}
						case OP_NOT_WORDCHAR:
							{
								if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) != int32(0)) {
									return int32(0)
								}
							}
						case OP_WORDCHAR:
							{
								if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) == int32(0)) {
									return int32(0)
								}
							}
						default:
							{
								return (-int32(14))
							}
						}
					}
				}
			} else {
				pp = eptr
				if prop_type >= int32(0) {
					switch prop_type {
					case int32(0):
						goto SW_GENERATED_LABEL_366
					case int32(1):
						goto SW_GENERATED_LABEL_367
					case int32(2):
						goto SW_GENERATED_LABEL_368
					case int32(3):
						goto SW_GENERATED_LABEL_369
					case int32(4):
						goto SW_GENERATED_LABEL_370
					case int32(5):
						goto SW_GENERATED_LABEL_371
					case int32(6):
						goto SW_GENERATED_LABEL_372
					case int32(7):
						goto SW_GENERATED_LABEL_373
					case int32(8):
						goto SW_GENERATED_LABEL_374
					case int32(9):
						goto SW_GENERATED_LABEL_375
					case int32(10):
						goto SW_GENERATED_LABEL_376
					default:
						goto SW_GENERATED_LABEL_377
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_366:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if prop_fail_result != 0 {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_367:
					{
						for i = min; i < max; i++ {
							var chartype int32
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							chartype = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).chartype))))
							if (((chartype == ucp_Lu) || (chartype == ucp_Ll)) || (chartype == ucp_Lt)) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_368:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((prop_value))) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_369:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).chartype)))) == prop_value) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_370:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if (uint32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).script)))) == prop_value) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_371:
					{
						for i = min; i < max; i++ {
							var category int32
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							if ((category == ucp_L) || (category == ucp_N)) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_372:
					;
				SW_GENERATED_LABEL_373:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							switch pcre_uint32(c) {
							case pcre_uint32('\t'):
								fallthrough
							case pcre_uint32(' '):
								fallthrough
							case pcre_uint32((uint8('\u00a0'))):
								fallthrough
							case pcre_uint32(int32(5760)):
								fallthrough
							case pcre_uint32(int32(6158)):
								fallthrough
							case pcre_uint32(int32(8192)):
								fallthrough
							case pcre_uint32(int32(8193)):
								fallthrough
							case pcre_uint32(int32(8194)):
								fallthrough
							case pcre_uint32(int32(8195)):
								fallthrough
							case pcre_uint32(int32(8196)):
								fallthrough
							case pcre_uint32(int32(8197)):
								fallthrough
							case pcre_uint32(int32(8198)):
								fallthrough
							case pcre_uint32(int32(8199)):
								fallthrough
							case pcre_uint32(int32(8200)):
								fallthrough
							case pcre_uint32(int32(8201)):
								fallthrough
							case pcre_uint32(int32(8202)):
								fallthrough
							case pcre_uint32(int32(8239)):
								fallthrough
							case pcre_uint32(int32(8287)):
								fallthrough
							case pcre_uint32(int32(12288)):
								fallthrough
							case pcre_uint32('\n'):
								fallthrough
							case pcre_uint32('\v'):
								fallthrough
							case pcre_uint32('\f'):
								fallthrough
							case pcre_uint32('\r'):
								fallthrough
							case pcre_uint32((uint8('\u0085'))):
								fallthrough
							case pcre_uint32(int32(8232)):
								fallthrough
							case pcre_uint32(int32(8233)):
								{
									if prop_fail_result != 0 {
										goto ENDLOOP99
									}
								}
							default:
								{
									if (*((*pcre_uint32)(func() unsafe.Pointer {
										tempVar := &_pcre_ucp_gentype[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_records[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
												tempVar := &_pcre_ucd_stage2[0]
												return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
													tempVar := &_pcre_ucd_stage1[0]
													return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
												}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
											}()))))))*unsafe.Sizeof(*tempVar))
										}()))).chartype)))))*unsafe.Sizeof(*tempVar))
									}())) == pcre_uint32((uint32(ucp_Z)))) == (prop_fail_result != 0) {
										goto ENDLOOP99
									}
									break
								}
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
				ENDLOOP99:
					{
						goto SW_GENERATED_LABEL_365
					}
				SW_GENERATED_LABEL_374:
					{
						for i = min; i < max; i++ {
							var category int32
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							category = int32(uint32((*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).chartype)))))*unsafe.Sizeof(*tempVar))
							}())))))
							if (((category == ucp_L) || (category == ucp_N)) || (c == pcre_uint32((uint32('_'))))) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_375:
					{
						for i = min; i < max; i++ {
							var cp *pcre_uint32
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							cp = ((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_caseless_sets[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(prop_value))*unsafe.Sizeof(*tempVar))
							}()))
							for {
								if c < *cp {
									if prop_fail_result != 0 {
										break
									} else {
										goto GOT_MAX
									}
								}
								if c == *func() *pcre_uint32 {
									defer func() {
										cp = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(cp)) + (uintptr)(1)*unsafe.Sizeof(*cp))))
									}()
									return cp
								}() {
									if prop_fail_result != 0 {
										goto GOT_MAX
									} else {
										break
									}
								}
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
				GOT_MAX:
					{
						goto SW_GENERATED_LABEL_365
					}
				SW_GENERATED_LABEL_376:
					{
						for i = min; i < max; i++ {
							var len int32 = int32(1)
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += 1
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(2)
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(3)
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(4)
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									len += int32(5)
								}
							}
							if (((((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) || ((c >= pcre_uint32((uint32(int32(160))))) && (c <= pcre_uint32((uint32(int32(55295))))))) || (c >= pcre_uint32((uint32(int32(57344)))))) == (prop_fail_result != 0) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_365
				SW_GENERATED_LABEL_377:
					{
						return (-int32(14))
					}
				SW_GENERATED_LABEL_365:
					;
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						if int32((BOOL(utf))) != 0 {
							for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					}
				} else if ctype == OP_EXTUNI {
					for i = min; i < max; i++ {
						if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							break
						} else {
							var lgb int32
							var rgb int32
							c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}()
								return eptr
							}())))))
							if (int32((utf)) != 0) && (c >= pcre_uint32((uint32(int32(192))))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
										defer func() {
											eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										}()
										return eptr
									}()))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*eptr))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))
								}
							}
							lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).gbprop))))
							for int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								var len int32 = int32(1)
								if int32((NotBOOL(BOOL(utf)))) != 0 {
									c = pcre_uint32((uint32(uint8((*eptr)))))
								} else {
									c = pcre_uint32((uint32(uint8((*eptr)))))
									if c >= pcre_uint32((uint32(int32(192)))) {
										if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += 1
										} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(2)
										} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
											c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(3)
										} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
											c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(4)
										} else {
											c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
											len += int32(5)
										}
									}
								}
								rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_records[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage2[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
											tempVar := &_pcre_ucd_stage1[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
										}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
									}()))))))*unsafe.Sizeof(*tempVar))
								}()))).gbprop))))
								if (*((*pcre_uint32)(func() unsafe.Pointer {
									tempVar := &_pcre_ucp_gbtable[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
								}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
									break
								}
								lgb = rgb
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
						if (((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
							(*md).hitend = BOOL((int32(1)))
							if (*md).partial > int32(1) {
								return (-int32(12))
							}
						}
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						var lgb int32
						var rgb int32
						var fptr *pcre_uchar
						if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						if int32((NotBOOL(BOOL(utf)))) != 0 {
							c = pcre_uint32((uint32(uint8((*eptr)))))
						} else {
							for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if c >= pcre_uint32((uint32(int32(192)))) {
								if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
									c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
									c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								} else {
									c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
								}
							}
						}
						rgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_records[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_stage2[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage1[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
								}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
							}()))))))*unsafe.Sizeof(*tempVar))
						}()))).gbprop))))
						for {
							if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
								goto TAIL_RECURSE
							}
							fptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))
							if int32((NotBOOL(BOOL(utf)))) != 0 {
								c = pcre_uint32((uint32(uint8((*fptr)))))
							} else {
								for (int32(uint8((*fptr))) & int32(192)) == int32(128) {
									fptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) - (uintptr)(1)*unsafe.Sizeof(*fptr))))
								}
								c = pcre_uint32((uint32(uint8((*fptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*fptr))))))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*fptr))))))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*fptr))))))) & int32(63))))))
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*fptr))))))) & int32(63))))))
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*fptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(fptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*fptr))))))) & int32(63))))))
									}
								}
							}
							lgb = int32(uint8((pcre_uint8((*((*ucd_record)(func() unsafe.Pointer {
								tempVar := &_pcre_ucd_records[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
									tempVar := &_pcre_ucd_stage2[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
										tempVar := &_pcre_ucd_stage1[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
									}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
								}()))))))*unsafe.Sizeof(*tempVar))
							}()))).gbprop))))
							if (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gbtable[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(lgb)*unsafe.Sizeof(*tempVar))
							}())) & pcre_uint32((uint32((int32(1) << uint64(rgb)))))) == pcre_uint32((uint32(int32(0)))) {
								break
							}
							eptr = fptr
							rgb = lgb
						}
					}
				} else if int32((BOOL(utf))) != 0 {
					switch ctype {
					case OP_ANY:
						{
							for i = min; i < max; i++ {
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								if (func() int32 {
									if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
										return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
									} else {
										return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := (*md).end_subject
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
										}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
											tempVar := &(*md).nl[0]
											return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
										}()))))))))])
									}
								}()) != 0 {
									break
								}
								if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_ALLANY:
						{
							if max < int32(2147483647) {
								for i = min; i < max; i++ {
									if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
										if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
											(*md).hitend = BOOL((int32(1)))
											if (*md).partial > int32(1) {
												return (-int32(12))
											}
										}
										break
									}
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									for (int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && ((int32(uint8((*eptr))) & int32(192)) == int32(128)) {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}
								}
							} else {
								eptr = (*md).end_subject
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
							}
						}
					case OP_ANYBYTE:
						{
							c = pcre_uint32((uint32((max - min))))
							if c > pcre_uint32((uint32((int32((int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer(eptr))))))))) {
								eptr = (*md).end_subject
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
							} else {
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_ANYNL:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if c == pcre_uint32((uint32('\r'))) {
									if int64(uintptr(unsafe.Pointer(func() *pcre_uchar {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
										return eptr
									}()))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
										break
									}
									if int32(uint8((*eptr))) == int32('\n') {
										eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									}
								} else {
									if (c != pcre_uint32((uint32('\n')))) && ((int32((BOOL((*md).bsr_anycrlf))) != 0) || (((((c != pcre_uint32((uint32('\v')))) && (c != pcre_uint32((uint32('\f'))))) && (c != pcre_uint32((uint32(uint8('\u0085')))))) && (c != pcre_uint32((uint32(int32(8232)))))) && (c != pcre_uint32((uint32(int32(8233))))))) {
										break
									}
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
								}
							}
						}
					case OP_NOT_HSPACE:
						fallthrough
					case OP_HSPACE:
						{
							for i = min; i < max; i++ {
								var gotspace BOOL
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\t'):
									fallthrough
								case pcre_uint32(' '):
									fallthrough
								case pcre_uint32((uint8('\u00a0'))):
									fallthrough
								case pcre_uint32(int32(5760)):
									fallthrough
								case pcre_uint32(int32(6158)):
									fallthrough
								case pcre_uint32(int32(8192)):
									fallthrough
								case pcre_uint32(int32(8193)):
									fallthrough
								case pcre_uint32(int32(8194)):
									fallthrough
								case pcre_uint32(int32(8195)):
									fallthrough
								case pcre_uint32(int32(8196)):
									fallthrough
								case pcre_uint32(int32(8197)):
									fallthrough
								case pcre_uint32(int32(8198)):
									fallthrough
								case pcre_uint32(int32(8199)):
									fallthrough
								case pcre_uint32(int32(8200)):
									fallthrough
								case pcre_uint32(int32(8201)):
									fallthrough
								case pcre_uint32(int32(8202)):
									fallthrough
								case pcre_uint32(int32(8239)):
									fallthrough
								case pcre_uint32(int32(8287)):
									fallthrough
								case pcre_uint32(int32(12288)):
									{
										gotspace = BOOL((int32(1)))
									}
								default:
									{
										gotspace = BOOL((int32(0)))
										break
									}
								}
								if gotspace == BOOL((map[bool]int32{false: 0, true: 1}[(ctype == OP_NOT_HSPACE)])) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_VSPACE:
						fallthrough
					case OP_VSPACE:
						{
							for i = min; i < max; i++ {
								var gotspace BOOL
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								switch pcre_uint32(c) {
								case pcre_uint32('\n'):
									fallthrough
								case pcre_uint32('\v'):
									fallthrough
								case pcre_uint32('\f'):
									fallthrough
								case pcre_uint32('\r'):
									fallthrough
								case pcre_uint32((uint8('\u0085'))):
									fallthrough
								case pcre_uint32(int32(8232)):
									fallthrough
								case pcre_uint32(int32(8233)):
									{
										gotspace = BOOL((int32(1)))
									}
								default:
									{
										gotspace = BOOL((int32(0)))
										break
									}
								}
								if gotspace == BOOL((map[bool]int32{false: 0, true: 1}[(ctype == OP_NOT_VSPACE)])) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_DIGIT:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) != int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_DIGIT:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(4)) == int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WHITESPACE:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) != int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_WHITESPACE:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(1)) == int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_NOT_WORDCHAR:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c < pcre_uint32((uint32(int32(256))))) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) != int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					case OP_WORDCHAR:
						{
							for i = min; i < max; i++ {
								var len int32 = int32(1)
								if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
										(*md).hitend = BOOL((int32(1)))
										if (*md).partial > int32(1) {
											return (-int32(12))
										}
									}
									break
								}
								c = pcre_uint32((uint32(uint8((*eptr)))))
								if c >= pcre_uint32((uint32(int32(192)))) {
									if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += 1
									} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(2)
									} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
										c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(3)
									} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
										c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(4)
									} else {
										c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*eptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*eptr))))))) & int32(63))))))
										len += int32(5)
									}
								}
								if (c >= pcre_uint32((uint32(int32(256))))) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
									tempVar := (*md).ctypes
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
								}()))))) & int32(16)) == int32(0)) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(len)*unsafe.Sizeof(*eptr))))
							}
						}
					default:
						{
							return (-int32(14))
						}
					}
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						if int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						for (int32(uint8((*eptr))) & int32(192)) == int32(128) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
						if (((ctype == OP_ANYNL) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer(pp))))) && (int32(uint8((*eptr))) == int32('\n'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))))) == int32('\r')) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				} else {
					switch ctype {
					case OP_ANY:
						goto SW_GENERATED_LABEL_379
					case OP_ALLANY:
						goto SW_GENERATED_LABEL_380
					case OP_ANYBYTE:
						goto SW_GENERATED_LABEL_381
					case OP_ANYNL:
						goto SW_GENERATED_LABEL_382
					case OP_NOT_HSPACE:
						goto SW_GENERATED_LABEL_383
					case OP_HSPACE:
						goto SW_GENERATED_LABEL_384
					case OP_NOT_VSPACE:
						goto SW_GENERATED_LABEL_385
					case OP_VSPACE:
						goto SW_GENERATED_LABEL_386
					case OP_NOT_DIGIT:
						goto SW_GENERATED_LABEL_387
					case OP_DIGIT:
						goto SW_GENERATED_LABEL_388
					case OP_NOT_WHITESPACE:
						goto SW_GENERATED_LABEL_389
					case OP_WHITESPACE:
						goto SW_GENERATED_LABEL_390
					case OP_NOT_WORDCHAR:
						goto SW_GENERATED_LABEL_391
					case OP_WORDCHAR:
						goto SW_GENERATED_LABEL_392
					default:
						goto SW_GENERATED_LABEL_393
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_379:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (func() int32 {
								if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
									return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(eptr))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((eptr), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
								} else {
									return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(eptr))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := (*md).end_subject
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
									}())))))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*eptr))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
										tempVar := &(*md).nl[0]
										return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
									}()))))))))])
								}
							}()) != 0 {
								break
							}
							if (((((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*eptr))))))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))))) && ((*md).nltype == int32(0))) && ((*md).nllen == int32(2))) && (int32(uint8((*eptr))) == int32(uint8((*&(*md).nl[0])))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_380:
					;
				SW_GENERATED_LABEL_381:
					{
						c = pcre_uint32((uint32((max - min))))
						if c > pcre_uint32((uint32((int32((int64(uintptr(unsafe.Pointer((*md).end_subject))) - int64(uintptr(unsafe.Pointer(eptr))))))))) {
							eptr = (*md).end_subject
							if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
								(*md).hitend = BOOL((int32(1)))
								if (*md).partial > int32(1) {
									return (-int32(12))
								}
							}
						} else {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_382:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							c = pcre_uint32((uint32(uint8((*eptr)))))
							if c == pcre_uint32((uint32('\r'))) {
								if int64(uintptr(unsafe.Pointer(func() *pcre_uchar {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									return eptr
								}()))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
									break
								}
								if int32(uint8((*eptr))) == int32('\n') {
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							} else {
								if (c != pcre_uint32((uint32('\n')))) && ((int32((BOOL((*md).bsr_anycrlf))) != 0) || (((c != pcre_uint32((uint32('\v')))) && (c != pcre_uint32((uint32('\f'))))) && (c != pcre_uint32((uint32(uint8('\u0085'))))))) {
									break
								}
								eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
							}
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_383:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							switch int32(uint8((pcre_uchar(*eptr)))) {
							default:
								{
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							case '\t':
								fallthrough
							case ' ':
								fallthrough
							case int32((uint8('\u00a0'))):
								{
									goto ENDLOOP00
								}
							}
						}
					}
				ENDLOOP00:
					{
						goto SW_GENERATED_LABEL_378
					}
				SW_GENERATED_LABEL_384:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							switch int32(uint8((pcre_uchar(*eptr)))) {
							default:
								{
									goto ENDLOOP01
								}
								fallthrough
							case '\t':
								fallthrough
							case ' ':
								fallthrough
							case int32((uint8('\u00a0'))):
								{
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									break
								}
							}
						}
					}
				ENDLOOP01:
					{
						goto SW_GENERATED_LABEL_378
					}
				SW_GENERATED_LABEL_385:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							switch int32(uint8((pcre_uchar(*eptr)))) {
							default:
								{
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
								}
							case '\n':
								fallthrough
							case '\v':
								fallthrough
							case '\f':
								fallthrough
							case '\r':
								fallthrough
							case int32((uint8('\u0085'))):
								{
									goto ENDLOOP02
								}
							}
						}
					}
				ENDLOOP02:
					{
						goto SW_GENERATED_LABEL_378
					}
				SW_GENERATED_LABEL_386:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							switch int32(uint8((pcre_uchar(*eptr)))) {
							default:
								{
									goto ENDLOOP03
								}
								fallthrough
							case '\n':
								fallthrough
							case '\v':
								fallthrough
							case '\f':
								fallthrough
							case '\r':
								fallthrough
							case int32((uint8('\u0085'))):
								{
									eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
									break
								}
							}
						}
					}
				ENDLOOP03:
					{
						goto SW_GENERATED_LABEL_378
					}
				SW_GENERATED_LABEL_387:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(4)) != int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_388:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(4)) == int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_389:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(1)) != int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_390:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(1)) == int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_391:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (int32(1) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(16)) != int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_392:
					{
						for i = min; i < max; i++ {
							if int64(uintptr(unsafe.Pointer(eptr))) >= int64(uintptr(unsafe.Pointer((*md).end_subject))) {
								if ((*md).partial != int32(0)) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer((*md).start_used_ptr)))) {
									(*md).hitend = BOOL((int32(1)))
									if (*md).partial > int32(1) {
										return (-int32(12))
									}
								}
								break
							}
							if (noarch.NotInt32(int32(1)) != 0) || ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
								tempVar := (*md).ctypes
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*eptr))))*unsafe.Sizeof(*tempVar))
							}()))))) & int32(16)) == int32(0)) {
								break
							}
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) + (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
					goto SW_GENERATED_LABEL_378
				SW_GENERATED_LABEL_393:
					{
						return (-int32(14))
					}
				SW_GENERATED_LABEL_378:
					;
					if int32((BOOL(possessive))) != 0 {
						continue
					}
					for {
						if int64(uintptr(unsafe.Pointer(eptr))) == int64(uintptr(unsafe.Pointer(pp))) {
							goto TAIL_RECURSE
						}
						rrc = match(eptr, ecode, mstart, offset_top, md, eptrb, (rdepth + uint32(int32(1))))
						if rrc != int32(0) {
							return rrc
						}
						eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						if (((ctype == OP_ANYNL) && (int64(uintptr(unsafe.Pointer(eptr))) > int64(uintptr(unsafe.Pointer(pp))))) && (int32(uint8((*eptr))) == int32('\n'))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))))) == int32('\r')) {
							eptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(eptr)) - (uintptr)(1)*unsafe.Sizeof(*eptr))))
						}
					}
				}
			}
		}
	SW_GENERATED_LABEL_540:
		{
			return (-int32(5))
		}
	SW_GENERATED_LABEL_394:
	}
	return
}

// pcre_exec - transpiled function from  /root/Documents/pcre/pcre_exec.c:6346
/***************************************************************************
****************************************************************************
                   RECURSION IN THE match() FUNCTION

Undefine all the macros that were defined above to handle this. */ //
/* These two are defined as macros in both cases */ //
/***************************************************************************
***************************************************************************/ //
/*************************************************
*         Execute a Regular Expression           *
*************************************************/ //
/* This function applies a compiled re to a subject string and picks out
portions of the string if it matches. Two elements in the vector are set for
each substring: the offsets to the start and end of the substring.

Arguments:
  argument_re     points to the compiled expression
  extra_data      points to extra data or is NULL
  subject         points to the subject string
  length          length of subject string (may contain binary zeros)
  start_offset    where to start in the subject string
  options         option bits
  offsets         points to a vector of ints to be filled in with offsets
  offsetcount     the number of elements in the vector

Returns:          > 0 => success; value is the number of elements filled in
                  = 0 => success, but offsets is not big enough
                   -1 => failed to match
                 < -1 => some kind of unexpected problem
*/ //
/* Check for the special magic call that measures the size of the stack used
per recursive call of match(). Without the funny casting for sizeof, a Windows
compiler gave this error: "unary minus operator applied to unsigned type,
result still unsigned". Hopefully the cast fixes that. */ //
/* Plausibility checks */ //
/* Check that the first field in the block is the magic number. If it is not,
return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to
REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which
means that the pattern is likely compiled with different endianness. */ //
/* These two settings are used in the code for checking a UTF-8 string that
follows immediately afterwards. Other values in the md block are used only
during "normal" pcre_exec() processing, not when the JIT support is in use,
so they are set up later. */ //
/* PCRE_UTF16 has the same value as PCRE_UTF8. */ //
/* Check a UTF-8 string if required. Pass back the character offset and error
code for an invalid string if a results vector is available. */ //
/* Check that a start_offset points to the start of a UTF character. */ //
/* If the pattern was successfully studied with JIT support, run the JIT
executable instead of the rest of this function. Most options must be set at
compile time for the JIT code to be usable. Fallback to the normal code path if
an unsupported flag is set. */ //
/* Carry on with non-JIT matching. This information is for finding all the
numbers associated with a given name, for condition testing. */ //
/* Fish out the optional data from the extra_data structure, first setting
the default values. */ //
/* The table pointer is always in native byte order. */ //
/* The two limit values override the defaults, whatever their value. */ //
/* Limits in the regex override only if they are smaller. */ //
/* If the exec call supplied NULL for tables, use the inbuilt ones. This
is a feature that makes it possible to save compiled regex and re-use them
in other programs later. */ //
/* Set up other data */ //
/* The code starts after the real_pcre block and the capture name table. */ //
/* Some options are unpacked into BOOL variables in the hope that testing
them will be faster than individual option bits. */ //
/* In case never set */ //
/* No recursion at top level */ //
/* Handle different \R options. */ //
/* Handle different types of newline. The three bits give eight cases. If
nothing is set at run time, whatever was used at compile time applies. */ //
/* Compile-time default */ //
/* Partial matching was originally supported only for a restricted set of
regexes; from release 8.00 there are no restrictions, but the bits are still
defined (though never set). So there's no harm in leaving this code. */ //
/* If the expression has got more back references than the offsets supplied can
hold, we get a temporary chunk of working store to use during the matching.
Otherwise, we can use the vector supplied, rounding down its size to a multiple
of 3. */ //
/* Reset the working variable associated with each extraction. These should
never be used unless previously set, but they get saved and restored, and so we
initialize them to avoid reading uninitialized locations. Also, unset the
offsets for the matched string. This is really just for tidiness with callouts,
in case they inspect these fields. */ //
/* Set up the first character to match, if available. The first_char value is
never set for an anchored regular expression, but the anchoring may be forced
at run time, so we have to test for anchoring. The first char may be unset for
an unanchored pattern, of course. If there's no first char and the pattern was
studied, there may be a bitmap of possible first characters. */ //
/* For anchored or unanchored matches, there may be a "last known required
character" set. */ //
/* ==========================================================================*/ //
/* Loop for handling unanchored repeated matching attempts; for anchored regexs
the loop runs just once. */ //
/* If firstline is TRUE, the start of the match is constrained to the first
line of a multiline string. That is, the match must be before or at the first
newline. Implement this by temporarily adjusting end_subject so that we stop
scanning at a newline. If the match fails at the newline, later code breaks
this loop. */ //
/* There are some optimizations that avoid running the match if a known
starting point is not found, or if a known later character is not present.
However, there is an option that disables these, for testing and for ensuring
that all callouts do actually occur. The option can be set in the regex by
(*NO_START_OPT) or passed in match-time options. */ //
/* Advance to a unique first char if there is one. */ //
/* Or to just after a linebreak for a multiline match */ //
/* If we have just passed a CR and the newline option is ANY or ANYCRLF,
   and we are now at a LF, advance the match position by one more character.
*/ //
/* Or to a non-unique first byte after study */ //
/* Starting optimizations */ //
/* Restore fudged end_subject */ //
/* The following two optimizations are disabled for partial matching or if
disabling is explicitly requested. */ //
/* If the pattern was studied, a minimum subject length may be set. This is
   a lower bound; no actual string of that length may actually match the
   pattern. Although the value is, strictly, in characters, we treat it as
   bytes to avoid spending too much time in this optimization. */ //
/* If req_char is set, we know that that character must appear in the
   subject for the match to succeed. If the first character is set, req_char
   must be later in the subject; otherwise the test starts at the match point.
   This optimization can save a huge amount of backtracking in patterns with
   nested unlimited repeats that aren't going to match. Writing separate code
   for cased/caseless versions makes it go faster, as does using an
   autoincrement and backing off on a match.

   HOWEVER: when the subject string is very, very long, searching to its end
   can take a long time, and give bad performance on quite ordinary patterns.
   This showed up when somebody was matching something like /^\d+C/ on a
   32-megabyte string... so we don't do this when the string is sufficiently
   long. */ //
/* We don't need to repeat the search if we haven't yet reached the
   place we found it at last time. */ //
/* If we can't find the required character, break the matching loop,
   forcing a match failure. */ //
/* If we have found the required character, save the point where we
   found it, so that we don't search again next time round the loop if
   the start hasn't passed this character yet. */ //
/* OK, we can now run the match. If "hitend" is set afterwards, remember the
first starting point for which a partial match was found. */ //
/* If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
   the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
   entirely. The only way we can do that is to re-do the match at the same
   point, with a flag to force SKIP with an argument to be ignored. Just
   treating this case as NOMATCH does not work because it does not check other
   alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC. */ //
/* SKIP passes back the next starting point explicitly, but if it is no
   greater than the match we have just done, treat it as NOMATCH. */ //
/* Fall through */ //
/* NOMATCH and PRUNE advance by one character. THEN at this level acts
   exactly like PRUNE. Unset ignore SKIP-with-argument. */ //
/* COMMIT disables the bumpalong, but otherwise behaves as NOMATCH. */ //
/* Any other return is either a match, or some kind of error. */ //
/* Control reaches here for the various types of "no match at this point"
result. Reset the code to MATCH_NOMATCH for subsequent checking. */ //
/* If PCRE_FIRSTLINE is set, the match must happen before or at the first
newline in the subject (though it may continue over the newline). Therefore,
if we have just failed to match, starting at a newline, do not continue. */ //
/* Advance to new matching position */ //
/* Break the loop if the pattern is anchored or if we have passed the end of
the subject. */ //
/* If we have just passed a CR and we are now at a LF, and the pattern does
not contain any explicit matches for \r or \n, and the newline option is CRLF
or ANY or ANYCRLF, advance the match position by one more character. In
normal matching start_match will aways be greater than the first position at
this stage, but a failed *SKIP can cause a return at the same point, which is
why the first test exists. */ //
/* Reset for start of next match attempt */ //
/* End of for(;;) "bumpalong" loop */ //
/* ==========================================================================*/ //
/* We reach here when rc is not MATCH_NOMATCH, or if one of the stopping
conditions is true:

(1) The pattern is anchored or the match was failed by (*COMMIT);

(2) We are past the end of the subject;

(3) PCRE_FIRSTLINE is set and we have failed to match at a newline, because
    this option requests that a match occur at or before the first newline in
    the subject.

When we have a match and the offset vector is big enough to deal with any
backreferences, captured substring offsets will already be set up. In the case
where we had to get some local store to hold offsets for backreference
processing, copy those that we can. In this case there need not be overflow if
certain parts of the pattern were not used, even though there are more
capturing parentheses than vector slots. */ //
/* Set the return code to the number of captured strings, or 0 if there were
too many to fit into the vector. */ //
/* If there is space in the offset vector, set any unused pairs at the end of
the pattern to -1 for backwards compatibility. It is documented that this
happens. In earlier versions, the whole set of potential capturing offsets
was set to -1 each time round the loop, but this is handled differently now.
"Gaps" are set to -1 dynamically instead (this fixes a bug). Thus, it is only
those at the end that need unsetting here. We can't just unset them all at
the start of the whole thing because they may get set in one branch that is
not the final matching branch. */ //
/* If there is space, set up the whole thing as substring 0. The value of
md->start_match_ptr might be modified if \K was encountered on the success
matching path. */ //
/* Return MARK data if requested */ //
/* Control gets here if there has been an error, or if the overall match
attempt has failed at all permitted starting positions. */ //
/* For anything other than nomatch or partial match, just return the code. */ //
/* Handle partial matches - disable any mark data */ //
/* This is the classic nomatch case */ //
/* Return the MARK data if it has been requested. */ //
//
func pcre_exec(argument_re *pcre, extra_data *pcre_extra, subject *byte, length int32, start_offset int32, options int32, offsets *int32, offsetcount int32) int32 {
	var rc int32
	var ocount int32
	var arg_offset_max int32
	var newline int32
	var using_temporary_offsets BOOL = BOOL((int32(0)))
	var anchored BOOL
	var startline BOOL
	var firstline BOOL
	var utf BOOL
	var has_first_char BOOL = BOOL((int32(0)))
	var has_req_char BOOL = BOOL((int32(0)))
	var first_char pcre_uchar = pcre_uchar(int32(0))
	var first_char2 pcre_uchar = pcre_uchar(int32(0))
	var req_char pcre_uchar = pcre_uchar(int32(0))
	var req_char2 pcre_uchar = pcre_uchar(int32(0))
	var match_block match_data
	var md *match_data = &match_block
	var tables *pcre_uint8
	var start_bits *pcre_uint8 = nil
	var start_match *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(subject))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
	}()))
	var end_subject *pcre_uchar
	var start_partial *pcre_uchar = nil
	var match_partial *pcre_uchar = nil
	var req_char_ptr *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(int32(1))*unsafe.Sizeof(*start_match))))
	var study *pcre_study_data
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(argument_re))
	if ((((re == nil) && (extra_data == nil)) && (subject == nil)) && (length == -int32(999))) && (start_offset == -int32(999)) {
		return match(nil, nil, nil, int32(0), nil, nil, uint32(int32(0)))
	}
	if (options & ^(((((((((((int32(16) | int32(128)) | int32(256)) | int32(1024)) | int32(268435456)) | int32(8192)) | int32(134217728)) | int32(32768)) | (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) | int32(8388608)) | int32(16777216)) | int32(67108864))) != int32(0) {
		return (-int32(3))
	}
	if ((re == nil) || (subject == nil)) || ((offsets == nil) && (offsetcount > int32(0))) {
		return (-int32(2))
	}
	if offsetcount < int32(0) {
		return (-int32(15))
	}
	if length < int32(0) {
		return (-int32(32))
	}
	if (start_offset < int32(0)) || (start_offset > length) {
		return (-int32(24))
	}
	if uint32((pcre_uint32((*re).magic_number))) != uint32(1346589253) {
		return func() int32 {
			if uint32((pcre_uint32((*re).magic_number))) == uint32(1163019088) {
				return (-int32(29))
			} else {
				return (-int32(4))
			}
		}()
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		return (-int32(28))
	}
	(*md).utf = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(2048))))) != pcre_uint32((uint32(int32(0)))))]))
	utf = (*md).utf
	(*md).partial = func() int32 {
		if (map[bool]int32{false: 0, true: 1}[((options & int32(134217728)) != int32(0))]) != 0 {
			return int32(2)
		} else {
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((options & int32(32768)) != int32(0))]) != 0 {
					return int32(1)
				} else {
					return int32(0)
				}
			}()
		}
	}()
	if (int32((utf)) != 0) && ((options & int32(8192)) == int32(0)) {
		var erroroffset int32
		var errorcode int32 = _pcre_valid_utf((*pcre_uchar)(unsafe.Pointer(subject)), length, &erroroffset)
		if errorcode != int32(0) {
			if offsetcount >= int32(2) {
				*offsets = erroroffset
				*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = errorcode
			}
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((errorcode <= int32(5)) && ((*md).partial > int32(1)))]) != 0 {
					return (-int32(25))
				} else {
					return (-int32(10))
				}
			}()
		}
		if ((start_offset > int32(0)) && (start_offset < length)) && ((int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(subject)))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
		}()))))) & int32(192)) == int32(128)) {
			return (-int32(11))
		}
	}
	(*md).name_table = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*pcre_uchar)(unsafe.Pointer(re))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
	}()))
	(*md).name_count = int32(uint16((pcre_uint16((*re).name_count))))
	(*md).name_entry_size = int32(uint16((pcre_uint16((*re).name_entry_size))))
	study = nil
	(*md).match_limit = uint32(int32(10000000))
	(*md).match_limit_recursion = uint32(int32(10000000))
	(*md).callout_data = nil
	tables = (*re).tables
	if extra_data != nil {
		var flags uint32 = (*extra_data).flags
		if (flags & uint32(int32(1))) != uint32(int32(0)) {
			study = (*pcre_study_data)((*extra_data).study_data)
		}
		if (flags & uint32(int32(2))) != uint32(int32(0)) {
			(*md).match_limit = (*extra_data).match_limit
		}
		if (flags & uint32(int32(16))) != uint32(int32(0)) {
			(*md).match_limit_recursion = (*extra_data).match_limit_recursion
		}
		if (flags & uint32(int32(4))) != uint32(int32(0)) {
			(*md).callout_data = (*extra_data).callout_data
		}
		if (flags & uint32(int32(8))) != uint32(int32(0)) {
			tables = (*pcre_uint8)(unsafe.Pointer((*extra_data).tables))
		}
	}
	if ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(8192))))) != pcre_uint32((uint32(int32(0))))) && (uint32((pcre_uint32((*re).limit_match))) < (*md).match_limit) {
		(*md).match_limit = uint32((pcre_uint32((*re).limit_match)))
	}
	if ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16384))))) != pcre_uint32((uint32(int32(0))))) && (uint32((pcre_uint32((*re).limit_recursion))) < (*md).match_limit_recursion) {
		(*md).match_limit_recursion = uint32((pcre_uint32((*re).limit_recursion)))
	}
	if tables == nil {
		tables = &_pcre_default_tables[0]
	}
	anchored = BOOL((map[bool]int32{false: 0, true: 1}[(((pcre_uint32((*re).options) | pcre_uint32((uint32(options)))) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))))]))
	startline = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(256))))) != pcre_uint32((uint32(int32(0)))))]))
	firstline = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(262144))))) != pcre_uint32((uint32(int32(0)))))]))
	(*md).start_code = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*pcre_uchar)(unsafe.Pointer(re))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
		}()))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint16((pcre_uint16((*re).name_count))))*int32(uint16((pcre_uint16((*re).name_entry_size))))))*unsafe.Sizeof(*tempVar))
	}()))
	(*md).start_subject = (*pcre_uchar)(unsafe.Pointer(subject))
	(*md).start_offset = start_offset
	(*md).end_subject = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := (*md).start_subject
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(length)*unsafe.Sizeof(*tempVar))
	}()))
	end_subject = (*md).end_subject
	(*md).endonly = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(32))))) != pcre_uint32((uint32(int32(0)))))]))
	(*md).use_ucp = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(536870912))))) != pcre_uint32((uint32(int32(0)))))]))
	(*md).jscript_compat = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(33554432))))) != pcre_uint32((uint32(int32(0)))))]))
	(*md).ignore_skip_arg = uint32(int32(0))
	(*md).notbol = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(128)) != int32(0))]))
	(*md).noteol = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(256)) != int32(0))]))
	(*md).notempty = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(1024)) != int32(0))]))
	(*md).notempty_atstart = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(268435456)) != int32(0))]))
	(*md).hitend = BOOL((int32(0)))
	(*md).nomatch_mark = nil
	(*md).mark = (*md).nomatch_mark
	(*md).recursive = nil
	(*md).hasthen = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(4096))))) != pcre_uint32((uint32(int32(0)))))]))
	(*md).lcc = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(0))*unsafe.Sizeof(*tables))))
	(*md).fcc = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(256))*unsafe.Sizeof(*tables))))
	(*md).ctypes = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)((int32(512)+int32(320)))*unsafe.Sizeof(*tables))))
	switch options & (int32(8388608) | int32(16777216)) {
	case int32(0):
		{
			if (pcre_uint32((*re).options) & pcre_uint32((uint32((int32(8388608) | int32(16777216)))))) != pcre_uint32((uint32(int32(0)))) {
				(*md).bsr_anycrlf = BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(8388608))))) != pcre_uint32((uint32(int32(0)))))]))
			} else {
				(*md).bsr_anycrlf = BOOL((int32(0)))
			}
		}
	case int32(8388608):
		{
			(*md).bsr_anycrlf = BOOL((int32(1)))
		}
	case int32(16777216):
		{
			(*md).bsr_anycrlf = BOOL((int32(0)))
		}
	default:
		{
			return (-int32(23))
		}
	}
	switch func() uint32 {
		if (map[bool]int32{false: 0, true: 1}[((options & (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) == int32(0))]) != 0 {
			return uint32((pcre_uint32((*re).options)))
		} else {
			return uint32((pcre_uint32(options)))
		}
	}() & uint32((((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) {
	case uint32(int32(0)):
		{
			newline = int32(10)
		}
	case uint32(int32(1048576)):
		{
			newline = int32('\r')
		}
	case uint32(int32(2097152)):
		{
			newline = int32('\n')
		}
	case uint32((int32(1048576) + int32(2097152))):
		{
			newline = int32((('\r' << uint64(int32(8))) | '\n'))
		}
	case uint32(int32(4194304)):
		{
			newline = -int32(1)
		}
	case uint32(int32(5242880)):
		{
			newline = -int32(2)
		}
	default:
		{
			return (-int32(23))
		}
	}
	if newline == -int32(2) {
		(*md).nltype = int32(2)
	} else if newline < int32(0) {
		(*md).nltype = int32(1)
	} else {
		(*md).nltype = int32(0)
		if newline > int32(255) {
			(*md).nllen = int32(2)
			*&(*md).nl[0] = pcre_uchar((uint8(((newline >> uint64(int32(8))) & int32(255)))))
			*((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := &(*md).nl[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) = pcre_uchar((uint8((newline & int32(255)))))
		} else {
			(*md).nllen = int32(1)
			*&(*md).nl[0] = pcre_uchar((uint8(newline)))
		}
	}
	if ((*md).partial != 0) && ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(512))))) != pcre_uint32((uint32(int32(0))))) {
		return (-int32(13))
	}
	ocount = (offsetcount - (offsetcount % int32(3)))
	arg_offset_max = ((int32(2) * ocount) / int32(3))
	if (int32(uint16((pcre_uint16((*re).top_backref)))) > int32(0)) && (int32(uint16((pcre_uint16((*re).top_backref)))) >= (ocount / int32(3))) {
		ocount = ((int32(uint16((pcre_uint16((*re).top_backref)))) * int32(3)) + int32(3))
		(*md).offset_vector = (*int32)(pcre_malloc(size_t((uint32(ocount) * 4))))
		if (*md).offset_vector == nil {
			return (-int32(6))
		}
		using_temporary_offsets = BOOL((int32(1)))
	} else {
		(*md).offset_vector = offsets
	}
	(*md).offset_end = ocount
	(*md).offset_max = ((int32(2) * ocount) / int32(3))
	(*md).capture_last = pcre_int32((int32(0)))
	if (*md).offset_vector != nil {
		var iptr *int32 = ((*int32)(func() unsafe.Pointer {
			tempVar := (*md).offset_vector
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(ocount)*unsafe.Sizeof(*tempVar))
		}()))
		var iend *int32 = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(iptr)) - (uintptr)(int32(uint16((pcre_uint16((*re).top_bracket)))))*unsafe.Sizeof(*iptr))))
		if int64(uintptr(unsafe.Pointer(iend))) < int64(uintptr(unsafe.Pointer(((*int32)(func() unsafe.Pointer {
			tempVar := (*md).offset_vector
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}()))))) {
			iend = ((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
			}()))
		}
		for int64(uintptr(unsafe.Pointer(func() *int32 {
			iptr = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(iptr)) - (uintptr)(1)*unsafe.Sizeof(*iptr))))
			return iptr
		}()))) >= int64(uintptr(unsafe.Pointer(iend))) {
			*iptr = -int32(1)
		}
		if offsetcount > int32(0) {
			*(*md).offset_vector = -int32(1)
		}
		if offsetcount > int32(1) {
			*((*int32)(func() unsafe.Pointer {
				tempVar := (*md).offset_vector
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
			}())) = -int32(1)
		}
	}
	if int32((NotBOOL(BOOL(anchored)))) != 0 {
		if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))) {
			has_first_char = BOOL((int32(1)))
			first_char2 = pcre_uchar(pcre_uint16(((*re).first_char)))
			first_char = first_char2
			if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(32))))) != pcre_uint32((uint32(int32(0)))) {
				first_char2 = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := ((*md).fcc)
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((first_char))))*unsafe.Sizeof(*tempVar))
				}()))))))
			}
		} else if ((int32((NotBOOL(BOOL(startline)))) != 0) && (study != nil)) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0))))) {
			start_bits = &(*study).start_bits[0]
		}
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(64))))) != pcre_uint32((uint32(int32(0)))) {
		has_req_char = BOOL((int32(1)))
		req_char2 = pcre_uchar(pcre_uint16(((*re).req_char)))
		req_char = req_char2
		if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(128))))) != pcre_uint32((uint32(int32(0)))) {
			req_char2 = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := ((*md).fcc)
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((req_char))))*unsafe.Sizeof(*tempVar))
			}()))))))
		}
	}
	for {
		var save_end_subject *pcre_uchar = end_subject
		var new_start_match *pcre_uchar
		if int32((BOOL(firstline))) != 0 {
			var t *pcre_uchar = start_match
			if int32((BOOL(utf))) != 0 {
				for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (noarch.NotInt32((func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((t), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(t))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*t))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*t))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}())) != 0) {
					t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
					for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*t))) & int32(192)) == int32(128)) {
						t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
					}
				}
			} else {
				for (int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (noarch.NotInt32((func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
						return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(t))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((t), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
					} else {
						return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(t))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := (*md).end_subject
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
						}())))))) && (int32(uint8((*t))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*t))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
							tempVar := &(*md).nl[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
						}()))))))))])
					}
				}())) != 0) {
					t = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(t)) + (uintptr)(1)*unsafe.Sizeof(*t))))
				}
			}
			end_subject = t
		}
		if ((uint32(options) | uint32((pcre_uint32((*re).options)))) & uint32(int32(67108864))) == uint32(int32(0)) {
			if int32((BOOL(has_first_char))) != 0 {
				var smc pcre_uchar
				if int32(uint8((first_char))) != int32(uint8((first_char2))) {
					for ((int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((func() pcre_uchar {
						tempVar := *start_match
						smc = tempVar
						return tempVar
					}()))) != int32(uint8((first_char))))) && (int32(uint8((smc))) != int32(uint8((first_char2)))) {
						start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
					}
				} else {
					for (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (int32(uint8((*start_match))) != int32(uint8((first_char)))) {
						start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
					}
				}
			} else if int32((BOOL(startline))) != 0 {
				if int64(uintptr(unsafe.Pointer(start_match))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*md).start_subject
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
				}()))))) {
					if int32((BOOL(utf))) != 0 {
						for (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (noarch.NotInt32((func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(start_match))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((start_match), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
							} else {
								return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(start_match))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*md).start_subject
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
								}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*start_match))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(int32(uint8(((*md).nllen))))*unsafe.Sizeof(*start_match) + (uintptr)(int32(1))*unsafe.Sizeof(*start_match))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := &(*md).nl[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))))))))])
							}
						}())) != 0) {
							start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
							for (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*start_match))) & int32(192)) == int32(128)) {
								start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
							}
						}
					} else {
						for (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && (noarch.NotInt32((func() int32 {
							if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
								return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(start_match))) > int64(uintptr(unsafe.Pointer((*md).start_subject)))) && (int32((_pcre_was_newline((start_match), (*md).nltype, (*md).start_subject, &((*md).nllen), BOOL(utf)))) != 0))])
							} else {
								return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(start_match))) >= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := (*md).start_subject
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
								}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*start_match))))))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(int32(uint8((*md).nllen)))*unsafe.Sizeof(*start_match) + (uintptr)(int32(1))*unsafe.Sizeof(*start_match))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := &(*md).nl[0]
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
								}()))))))))])
							}
						}())) != 0) {
							start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
						}
					}
					if (((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(1)*unsafe.Sizeof(*start_match))))))) == int32('\r')) && (((*md).nltype == int32(1)) || ((*md).nltype == int32(2)))) && (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject))))) && (int32(uint8((*start_match))) == int32('\n')) {
						start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
					}
				}
			} else if start_bits != nil {
				for int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject))) {
					var c pcre_uint32 = pcre_uint32((uint32(uint8((*start_match)))))
					if (int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*start_bits))))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0) {
						break
					}
					start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
				}
			}
		}
		end_subject = save_end_subject
		if (((uint32(options) | uint32((pcre_uint32((*re).options)))) & uint32(int32(67108864))) == uint32(int32(0))) && (noarch.NotInt32((*md).partial) != 0) {
			if ((study != nil) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(2))))) != pcre_uint32((uint32(int32(0)))))) && (pcre_uint32((int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(start_match))))))) < pcre_uint32((*study).minlength)) {
				rc = int32(0)
				break
			}
			if (int32((has_req_char)) != 0) && ((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer(start_match)))) < int64(int32(1000))) {
				var p *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(func() int32 {
					if int32((BOOL(has_first_char))) != 0 {
						return int32(1)
					} else {
						return int32(0)
					}
				}())*unsafe.Sizeof(*start_match))))
				if int64(uintptr(unsafe.Pointer(p))) > int64(uintptr(unsafe.Pointer(req_char_ptr))) {
					if int32(uint8((req_char))) != int32(uint8((req_char2))) {
						for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(end_subject))) {
							var pp pcre_uint32 = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
								defer func() {
									p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
								}()
								return p
							}())))))
							if (pp == pcre_uint32((uint32(uint8((req_char)))))) || (pp == pcre_uint32((uint32(uint8((req_char2)))))) {
								p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - (uintptr)(1)*unsafe.Sizeof(*p))))
								break
							}
						}
					} else {
						for int64(uintptr(unsafe.Pointer(p))) < int64(uintptr(unsafe.Pointer(end_subject))) {
							if int32(uint8((*func() *pcre_uchar {
								defer func() {
									p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
								}()
								return p
							}()))) == int32(uint8((req_char))) {
								p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - (uintptr)(1)*unsafe.Sizeof(*p))))
								break
							}
						}
					}
					if int64(uintptr(unsafe.Pointer(p))) >= int64(uintptr(unsafe.Pointer(end_subject))) {
						rc = int32(0)
						break
					}
					req_char_ptr = p
				}
			}
		}
		(*md).start_match_ptr = start_match
		(*md).start_used_ptr = start_match
		(*md).match_call_count = uint32(int32(0))
		(*md).match_function_type = int32(0)
		(*md).end_offset_top = int32(0)
		(*md).skip_arg_count = uint32(int32(0))
		rc = match(start_match, (*md).start_code, start_match, int32(2), md, nil, uint32(int32(0)))
		if (int32((BOOL((*md).hitend))) != 0) && (start_partial == nil) {
			start_partial = (*md).start_used_ptr
			match_partial = start_match
		}
		switch rc {
		case (-int32(993)):
			{
				new_start_match = start_match
				(*md).ignore_skip_arg = (*md).skip_arg_count
			}
		case (-int32(994)):
			{
				if int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) > int64(uintptr(unsafe.Pointer(start_match))) {
					new_start_match = (*md).start_match_ptr
					break
				}
			}
			fallthrough
		case int32(0):
			fallthrough
		case (-int32(995)):
			fallthrough
		case (-int32(992)):
			{
				(*md).ignore_skip_arg = uint32(int32(0))
				new_start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(int32(1))*unsafe.Sizeof(*start_match))))
				if int32((BOOL(utf))) != 0 {
					for (int64(uintptr(unsafe.Pointer(new_start_match))) < int64(uintptr(unsafe.Pointer(end_subject)))) && ((int32(uint8((*new_start_match))) & int32(192)) == int32(128)) {
						new_start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(new_start_match)) + (uintptr)(1)*unsafe.Sizeof(*new_start_match))))
					}
				}
			}
		case (-int32(996)):
			{
				rc = int32(0)
				goto ENDLOOP
			}
			fallthrough
		default:
			{
				goto ENDLOOP
			}
		}
		rc = int32(0)
		if (int32((firstline)) != 0) && (func() int32 {
			if (map[bool]int32{false: 0, true: 1}[((*md).nltype != int32(0))]) != 0 {
				return (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer((*md).end_subject)))) && (int32((_pcre_is_newline((start_match), (*md).nltype, (*md).end_subject, &((*md).nllen), BOOL(utf)))) != 0))])
			} else {
				return (map[bool]int32{false: 0, true: 1}[(((int64(uintptr(unsafe.Pointer(start_match))) <= int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := (*md).end_subject
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) - (uintptr)((*md).nllen)*unsafe.Sizeof(*tempVar))
				}())))))) && (int32(uint8((*start_match))) == int32(uint8((*&(*md).nl[0]))))) && (((*md).nllen == int32(1)) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(int32(uint8((int32(0)+int32(1)))))*unsafe.Sizeof(*start_match))))))) == int32(uint8((*((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := &(*md).nl[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
				}()))))))))])
			}
		}() != 0) {
			break
		}
		start_match = new_start_match
		if (int32((anchored)) != 0) || (int64(uintptr(unsafe.Pointer(start_match))) > int64(uintptr(unsafe.Pointer(end_subject)))) {
			break
		}
		if (((((int64(uintptr(unsafe.Pointer(start_match))) > int64(uintptr(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*pcre_uchar)(unsafe.Pointer(subject))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(start_offset)*unsafe.Sizeof(*tempVar))
		}())))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) - (uintptr)(1)*unsafe.Sizeof(*start_match))))))) == int32('\r'))) && (int64(uintptr(unsafe.Pointer(start_match))) < int64(uintptr(unsafe.Pointer(end_subject))))) && (int32(uint8((*start_match))) == int32('\n'))) && ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(2048))))) == pcre_uint32((uint32(int32(0)))))) && ((((*md).nltype == int32(1)) || ((*md).nltype == int32(2))) || ((*md).nllen == int32(2))) {
			start_match = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(start_match)) + (uintptr)(1)*unsafe.Sizeof(*start_match))))
		}
		(*md).mark = nil
	}
ENDLOOP:
	;
	if (rc == int32(1)) || (rc == -int32(999)) {
		if int32((BOOL(using_temporary_offsets))) != 0 {
			if arg_offset_max >= int32(4) {
				noarch.Memcpy(unsafe.Pointer(((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(2))*unsafe.Sizeof(*offsets))))), unsafe.Pointer(((*int32)(func() unsafe.Pointer {
					tempVar := (*md).offset_vector
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))), int32((uint32((arg_offset_max - int32(2))) * 4)))
			}
			if (*md).end_offset_top > arg_offset_max {
				(*md).capture_last |= pcre_int32((int32(65536)))
			}
			pcre_free(unsafe.Pointer((*md).offset_vector))
		}
		rc = func() int32 {
			if (map[bool]int32{false: 0, true: 1}[(((pcre_int32((*md).capture_last) & pcre_int32((int32(65536)))) != pcre_int32((int32(0)))) && ((*md).end_offset_top >= arg_offset_max))]) != 0 {
				return int32(0)
			} else {
				return ((*md).end_offset_top / int32(2))
			}
		}()
		if (((*md).end_offset_top / int32(2)) <= int32(uint16((pcre_uint16((*re).top_bracket))))) && (offsets != nil) {
			var iptr *int32
			var iend *int32
			var resetcount int32 = (int32(2) + (int32(uint16((pcre_uint16((*re).top_bracket)))) * int32(2)))
			if resetcount > offsetcount {
				resetcount = offsetcount
			}
			iptr = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)((*md).end_offset_top)*unsafe.Sizeof(*offsets))))
			iend = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(resetcount)*unsafe.Sizeof(*offsets))))
			for int64(uintptr(unsafe.Pointer(iptr))) < int64(uintptr(unsafe.Pointer(iend))) {
				*func() *int32 {
					defer func() {
						iptr = ((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(iptr)) + (uintptr)(1)*unsafe.Sizeof(*iptr))))
					}()
					return iptr
				}() = -int32(1)
			}
		}
		if offsetcount < int32(2) {
			rc = int32(0)
		} else {
			*offsets = (int32((int64(uintptr(unsafe.Pointer((*md).start_match_ptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
			*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer((*md).end_match_ptr))) - int64(uintptr(unsafe.Pointer((*md).start_subject))))))
		}
		if (extra_data != nil) && (((*extra_data).flags & uint32(int32(32))) != uint32(int32(0))) {
			*(*extra_data).mark = (*uint8)(unsafe.Pointer((*md).mark))
		}
		return rc
	}
	if int32((BOOL(using_temporary_offsets))) != 0 {
		pcre_free(unsafe.Pointer((*md).offset_vector))
	}
	if (rc != int32(0)) && (rc != -int32(12)) {
		return rc
	}
	if match_partial != nil {
		(*md).mark = nil
		if offsetcount > int32(1) {
			*offsets = (int32((int64(uintptr(unsafe.Pointer(start_partial))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
			*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(1))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer(end_subject))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
			if offsetcount > int32(2) {
				*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(offsets)) + (uintptr)(int32(2))*unsafe.Sizeof(*offsets)))) = (int32((int64(uintptr(unsafe.Pointer(match_partial))) - int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(subject))))))))
			}
		}
		rc = -int32(12)
	} else {
		rc = -int32(1)
	}
	if (extra_data != nil) && (((*extra_data).flags & uint32(int32(32))) != uint32(int32(0))) {
		*(*extra_data).mark = (*uint8)(unsafe.Pointer((*md).nomatch_mark))
	}
	return rc
}

// pcre_fullinfo - transpiled function from  /root/Documents/pcre/pcre_fullinfo.c:69
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2013 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_fullinfo(), which returns
information about a compiled pattern. */ //
/*************************************************
*        Return info about compiled pattern      *
*************************************************/ //
/* This is a newer "info" function which has an extensible interface so
that additional items can be added compatibly.

Arguments:
  argument_re      points to compiled code
  extra_data       points extra data, or NULL
  what             what information is required
  where            where to put the information

Returns:           0 if data returned, negative on error
*/ //
/* Check that the first field in the block is the magic number. If it is not,
return with PCRE_ERROR_BADMAGIC. However, if the magic number is equal to
REVERSED_MAGIC_NUMBER we return with PCRE_ERROR_BADENDIANNESS, which
means that the pattern is likely compiled with different endianness. */ //
/* Check that this pattern was compiled in the correct bit mode */ //
/* Make sure we pass back the pointer to the bit vector in the external
block, not the internal copy (with flipped integer fields). */ //
/* From release 8.00 this will always return TRUE because NOPARTIAL is
no longer ever set (the restrictions have been removed). */ //
//
func pcre_fullinfo(argument_re *pcre, extra_data *pcre_extra, what int32, where unsafe.Pointer) int32 {
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(argument_re))
	var study *pcre_study_data = nil
	if (re == nil) || (where == nil) {
		return (-int32(2))
	}
	if (extra_data != nil) && (((*extra_data).flags & uint32(int32(1))) != uint32(int32(0))) {
		study = (*pcre_study_data)((*extra_data).study_data)
	}
	if uint32((pcre_uint32((*re).magic_number))) != uint32(1346589253) {
		return func() int32 {
			if uint32((pcre_uint32((*re).magic_number))) == uint32(1163019088) {
				return (-int32(29))
			} else {
				return (-int32(4))
			}
		}()
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		return (-int32(28))
	}
	switch what {
	case int32(0):
		{
			*(*uint32)(where) = uint32((pcre_uint32((*re).options) & pcre_uint32((uint32((((((((((((((((((((((int32(1) | int32(8)) | int32(16)) | int32(2)) | int32(4)) | int32(32)) | int32(64)) | int32(512)) | int32(2048)) | int32(4096)) | int32(131072)) | int32(8192)) | int32(16384)) | int32(262144)) | int32(524288)) | (((int32(1048576) | int32(2097152)) | int32(4194304)) | int32(5242880))) | int32(8388608)) | int32(16777216)) | int32(33554432)) | int32(536870912)) | int32(67108864)) | int32(65536)))))))
		}
	case int32(1):
		{
			*(*size_t)(where) = size_t((uint32((pcre_uint32((*re).size)))))
		}
	case int32(10):
		{
			*(*size_t)(where) = size_t((func() uint32 {
				if (map[bool]int32{false: 0, true: 1}[(study == nil)]) != 0 {
					return uint32(int32(0))
				} else {
					return uint32((pcre_uint32((*study).size)))
				}
			}()))
		}
	case int32(17):
		{
			*(*size_t)(where) = size_t(int32(0))
		}
	case int32(2):
		{
			*(*int32)(where) = int32(uint16((pcre_uint16((*re).top_bracket))))
		}
	case int32(3):
		{
			*(*int32)(where) = int32(uint16((pcre_uint16((*re).top_backref))))
		}
	case int32(4):
		{
			*(*int32)(where) = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
					return int32(uint16((pcre_uint16((*re).first_char))))
				} else {
					return func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(256))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
							return -int32(1)
						} else {
							return -int32(2)
						}
					}()
				}
			}()
		}
	case int32(19):
		{
			*(*pcre_uint32)(where) = pcre_uint32((uint32(func() int32 {
				if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))) {
					return int32(uint16((pcre_uint16((*re).first_char))))
				} else {
					return int32(0)
				}
			}())))
		}
	case int32(20):
		{
			*(*int32)(where) = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
					return int32(1)
				} else {
					return func() int32 {
						if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(256))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
							return int32(2)
						} else {
							return int32(0)
						}
					}()
				}
			}()
		}
	case int32(5):
		{
			*(**pcre_uint8)(where) = func() *pcre_uint8 {
				if (map[bool]int32{false: 0, true: 1}[((study != nil) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(1))))) != pcre_uint32((uint32(int32(0))))))]) != 0 {
					return &(*((*pcre_study_data)((*extra_data).study_data))).start_bits[0]
				} else {
					return nil
				}
			}()
		}
	case int32(15):
		{
			*(*int32)(where) = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((study != nil) && ((pcre_uint32((*study).flags) & pcre_uint32((uint32(int32(2))))) != pcre_uint32((uint32(int32(0))))))]) != 0 {
					return int32(uint32((pcre_uint32(((*study).minlength)))))
				} else {
					return -int32(1)
				}
			}()
		}
	case int32(16):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[(((extra_data != nil) && (((*extra_data).flags & uint32(int32(64))) != uint32(int32(0)))) && ((*extra_data).executable_jit != nil))]
		}
	case int32(6):
		{
			*(*int32)(where) = func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(64))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
					return int32(uint16((pcre_uint16((*re).req_char))))
				} else {
					return -int32(1)
				}
			}()
		}
	case int32(21):
		{
			*(*pcre_uint32)(where) = pcre_uint32((uint32(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(64))))) != pcre_uint32((uint32(int32(0)))))]) != 0 {
					return int32(uint16((pcre_uint16((*re).req_char))))
				} else {
					return int32(0)
				}
			}())))
		}
	case int32(22):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(64))))) != pcre_uint32((uint32(int32(0)))))]
		}
	case int32(7):
		{
			*(*int32)(where) = int32(uint16((pcre_uint16((*re).name_entry_size))))
		}
	case int32(8):
		{
			*(*int32)(where) = int32(uint16((pcre_uint16((*re).name_count))))
		}
	case int32(9):
		{
			*(**pcre_uchar)(where) = ((*pcre_uchar)(func() unsafe.Pointer {
				tempVar := (*pcre_uchar)(unsafe.Pointer(re))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
			}()))
		}
	case int32(11):
		{
			*(**pcre_uint8)(where) = &(_pcre_default_tables)[0]
		}
	case int32(12):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(512))))) == pcre_uint32((uint32(int32(0)))))]
		}
	case int32(13):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1024))))) != pcre_uint32((uint32(int32(0)))))]
		}
	case int32(14):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(2048))))) != pcre_uint32((uint32(int32(0)))))]
		}
	case int32(18):
		{
			*(*int32)(where) = int32(uint16((pcre_uint16((*re).max_lookbehind))))
		}
	case int32(23):
		{
			if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(8192))))) == pcre_uint32((uint32(int32(0)))) {
				return (-int32(33))
			}
			*(*pcre_uint32)(where) = pcre_uint32((*re).limit_match)
		}
	case int32(24):
		{
			if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(16384))))) == pcre_uint32((uint32(int32(0)))) {
				return (-int32(33))
			}
			*(*pcre_uint32)(where) = pcre_uint32((*re).limit_recursion)
		}
	case int32(25):
		{
			*(*int32)(where) = map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(32768))))) != pcre_uint32((uint32(int32(0)))))]
		}
	default:
		{
			return (-int32(3))
		}
	}
	return int32(0)
}

// pcre_get_stringnumber - transpiled function from  /root/Documents/pcre/pcre_get.c:69
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains some convenience functions for extracting substrings
from the subject string after a regex match has succeeded. The original idea
for these functions came from Scott Wimer. */ //
/*************************************************
*           Find number for named string         *
*************************************************/ //
/* This function is used by the get_first_set() function below, as well
as being generally available. It assumes that names are unique.

Arguments:
  code        the compiled regex
  stringname  the name whose number is required

Returns:      the number of the named parentheses, or a negative number
                (PCRE_ERROR_NOSUBSTRING) if not found
*/ //
//
func pcre_get_stringnumber(code *pcre, stringname *byte) int32 {
	var rc int32
	var entrysize int32
	var top int32
	var bot int32
	var nametable *pcre_uchar
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(8), unsafe.Pointer(&top))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	if top <= int32(0) {
		return (-int32(7))
	}
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(7), unsafe.Pointer(&entrysize))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(9), unsafe.Pointer(&nametable))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	bot = int32(0)
	for top > bot {
		var mid int32 = ((top + bot) / int32(2))
		var entry *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nametable)) + (uintptr)((entrysize*mid))*unsafe.Sizeof(*nametable))))
		var c int32 = noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(stringname))))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(entry)) + (uintptr)(int32(2))*unsafe.Sizeof(*entry)))))))
		if c == int32(0) {
			return int32(uint32(((int32(uint8((*(entry)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((entry))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(entry)))))))))))
		}
		if c > int32(0) {
			bot = (mid + int32(1))
		} else {
			top = mid
		}
	}
	return (-int32(7))
}

// pcre_get_stringtable_entries - transpiled function from  /root/Documents/pcre/pcre_get.c:149
/*************************************************
*     Find (multiple) entries for named string   *
*************************************************/ //
/* This is used by the get_first_set() function below, as well as being
generally available. It is used when duplicated names are permitted.

Arguments:
  code        the compiled regex
  stringname  the name whose entries required
  firstptr    where to put the pointer to the first entry
  lastptr     where to put the pointer to the last entry

Returns:      the length of each entry, or a negative number
                (PCRE_ERROR_NOSUBSTRING) if not found
*/ //
//
func pcre_get_stringtable_entries(code *pcre, stringname *byte, firstptr **byte, lastptr **byte) int32 {
	var rc int32
	var entrysize int32
	var top int32
	var bot int32
	var nametable *pcre_uchar
	var lastentry *pcre_uchar
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(8), unsafe.Pointer(&top))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	if top <= int32(0) {
		return (-int32(7))
	}
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(7), unsafe.Pointer(&entrysize))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	if (func() int32 {
		tempVar := pcre_fullinfo(code, nil, int32(9), unsafe.Pointer(&nametable))
		rc = tempVar
		return tempVar
	}()) != int32(0) {
		return rc
	}
	lastentry = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nametable)) + (uintptr)((entrysize*(top-int32(1))))*unsafe.Sizeof(*nametable))))
	bot = int32(0)
	for top > bot {
		var mid int32 = ((top + bot) / int32(2))
		var entry *pcre_uchar = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(nametable)) + (uintptr)((entrysize*mid))*unsafe.Sizeof(*nametable))))
		var c int32 = noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(stringname))))), (*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(entry)) + (uintptr)(int32(2))*unsafe.Sizeof(*entry)))))))
		if c == int32(0) {
			var first *pcre_uchar = entry
			var last *pcre_uchar = entry
			for int64(uintptr(unsafe.Pointer(first))) > int64(uintptr(unsafe.Pointer(nametable))) {
				if noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(stringname))))), (*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(first)) - (uintptr)(entrysize)*unsafe.Sizeof(*first))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))))) != int32(0) {
					break
				}
				first = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(first)) - (uintptr)(entrysize)*unsafe.Sizeof(*first))))
			}
			for int64(uintptr(unsafe.Pointer(last))) < int64(uintptr(unsafe.Pointer(lastentry))) {
				if noarch.Strcmp((*byte)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(stringname))))), (*byte)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last)) + (uintptr)(entrysize)*unsafe.Sizeof(*last))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))))) != int32(0) {
					break
				}
				last = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(last)) + (uintptr)(entrysize)*unsafe.Sizeof(*last))))
			}
			*firstptr = (*byte)(unsafe.Pointer(first))
			*lastptr = (*byte)(unsafe.Pointer(last))
			return entrysize
		}
		if c > int32(0) {
			bot = (mid + int32(1))
		} else {
			top = mid
		}
	}
	return (-int32(7))
}

// get_first_set - transpiled function from  /root/Documents/pcre/pcre_get.c:261
/*************************************************
*    Find first set of multiple named strings    *
*************************************************/ //
/* This function allows for duplicate names in the table of named substrings.
It returns the number of the first one that was set in a pattern match.

Arguments:
  code         the compiled regex
  stringname   the name of the capturing substring
  ovector      the vector of matched substrings
  stringcount  number of captured substrings

Returns:       the number of the first that is set,
               or the number of the last one if none are set,
               or a negative number on error
*/ //
//
func get_first_set(code *pcre, stringname *byte, ovector *int32, stringcount int32) int32 {
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(code))
	var entrysize int32
	var entry *pcre_uchar
	var first *byte
	var last *byte
	if ((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(524288))))) == pcre_uint32((uint32(int32(0))))) && ((pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1024))))) == pcre_uint32((uint32(int32(0))))) {
		return pcre_get_stringnumber(code, stringname)
	}
	entrysize = pcre_get_stringtable_entries(code, stringname, &first, &last)
	if entrysize <= int32(0) {
		return entrysize
	}
	for entry = (*pcre_uchar)(unsafe.Pointer(first)); int64(uintptr(unsafe.Pointer(entry))) <= int64(uintptr(unsafe.Pointer((*pcre_uchar)(unsafe.Pointer(last))))); entry = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(entry)) + (uintptr)(entrysize)*unsafe.Sizeof(*entry)))) {
		var n int32 = int32(uint32(((int32(uint8((*(entry)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((entry))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(entry)))))))))))
		if (n < stringcount) && (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((n*int32(2)))*unsafe.Sizeof(*ovector)))) >= int32(0)) {
			return n
		}
	}
	return int32(uint32(((int32(uint8((*(entry)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((entry))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(entry)))))))))))
}

// pcre_copy_substring - transpiled function from  /root/Documents/pcre/pcre_get.c:338
/*************************************************
*      Copy captured string to given buffer      *
*************************************************/ //
/* This function copies a single captured substring into a given buffer.
Note that we use memcpy() rather than strncpy() in case there are binary zeros
in the string.

Arguments:
  subject        the subject string that was matched
  ovector        pointer to the offsets table
  stringcount    the number of substrings that were captured
                   (i.e. the yield of the pcre_exec call, unless
                   that was zero, in which case it should be 1/3
                   of the offset table size)
  stringnumber   the number of the required substring
  buffer         where to put the substring
  size           the size of the buffer

Returns:         if successful:
                   the length of the copied string, not including the zero
                   that is put on the end; can be zero
                 if not successful:
                   PCRE_ERROR_NOMEMORY (-6) buffer too small
                   PCRE_ERROR_NOSUBSTRING (-7) no such captured substring
*/ //
//
func pcre_copy_substring(subject *byte, ovector *int32, stringcount int32, stringnumber int32, buffer *byte, size int32) int32 {
	var yield int32
	if (stringnumber < int32(0)) || (stringnumber >= stringcount) {
		return (-int32(7))
	}
	stringnumber *= int32(2)
	yield = (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((stringnumber+int32(1)))*unsafe.Sizeof(*ovector)))) - *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(stringnumber)*unsafe.Sizeof(*ovector)))))
	if size < (yield + int32(1)) {
		return (-int32(6))
	}
	noarch.Memcpy(unsafe.Pointer(buffer), unsafe.Pointer(((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(subject)) + (uintptr)(*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(stringnumber)*unsafe.Sizeof(*ovector)))))*unsafe.Sizeof(*subject))))), int32(uint32((yield))))
	*((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(buffer)) + (uintptr)(yield)*unsafe.Sizeof(*buffer)))) = byte(int32(0))
	return yield
}

// pcre_copy_named_substring - transpiled function from  /root/Documents/pcre/pcre_get.c:393
/*************************************************
*   Copy named captured string to given buffer   *
*************************************************/ //
/* This function copies a single captured substring into a given buffer,
identifying it by name. If the regex permits duplicate names, the first
substring that is set is chosen.

Arguments:
  code           the compiled regex
  subject        the subject string that was matched
  ovector        pointer to the offsets table
  stringcount    the number of substrings that were captured
                   (i.e. the yield of the pcre_exec call, unless
                   that was zero, in which case it should be 1/3
                   of the offset table size)
  stringname     the name of the required substring
  buffer         where to put the substring
  size           the size of the buffer

Returns:         if successful:
                   the length of the copied string, not including the zero
                   that is put on the end; can be zero
                 if not successful:
                   PCRE_ERROR_NOMEMORY (-6) buffer too small
                   PCRE_ERROR_NOSUBSTRING (-7) no such captured substring
*/ //
//
func pcre_copy_named_substring(code *pcre, subject *byte, ovector *int32, stringcount int32, stringname *byte, buffer *byte, size int32) int32 {
	var n int32 = get_first_set(code, stringname, ovector, stringcount)
	if n <= int32(0) {
		return n
	}
	return pcre_copy_substring(subject, ovector, stringcount, n, buffer, size)
}

// pcre_get_substring_list - transpiled function from  /root/Documents/pcre/pcre_get.c:444
/*************************************************
*      Copy all captured strings to new store    *
*************************************************/ //
/* This function gets one chunk of store and builds a list of pointers and all
of the captured substrings in it. A NULL pointer is put on the end of the list.

Arguments:
  subject        the subject string that was matched
  ovector        pointer to the offsets table
  stringcount    the number of substrings that were captured
                   (i.e. the yield of the pcre_exec call, unless
                   that was zero, in which case it should be 1/3
                   of the offset table size)
  listptr        set to point to the list of pointers

Returns:         if successful: 0
                 if not successful:
                   PCRE_ERROR_NOMEMORY (-6) failed to get store
*/ //
//
func pcre_get_substring_list(subject *byte, ovector *int32, stringcount int32, listptr ***byte) int32 {
	var i int32
	var size int32 = int32(8)
	var double_count int32 = (stringcount * int32(2))
	var stringlist **pcre_uchar
	var p *pcre_uchar
	for i = int32(0); i < double_count; i += int32(2) {
		size += int32((8 + uint32(int32(1))))
		if *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((i+int32(1)))*unsafe.Sizeof(*ovector)))) > *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(i)*unsafe.Sizeof(*ovector)))) {
			size += (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((i+int32(1)))*unsafe.Sizeof(*ovector)))) - *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(i)*unsafe.Sizeof(*ovector)))))
		}
	}
	stringlist = (**pcre_uchar)(pcre_malloc(size_t(size)))
	if stringlist == nil {
		return (-int32(6))
	}
	*listptr = (**byte)(unsafe.Pointer(stringlist))
	p = (*pcre_uchar)(unsafe.Pointer(((**pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((**pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(stringlist)) + (uintptr)(stringcount)*unsafe.Sizeof(*stringlist))))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
	}()))))
	for i = int32(0); i < double_count; i += int32(2) {
		var len int32 = func() int32 {
			if (map[bool]int32{false: 0, true: 1}[(*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((i+int32(1)))*unsafe.Sizeof(*ovector)))) > *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(i)*unsafe.Sizeof(*ovector)))))]) != 0 {
				return (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((i+int32(1)))*unsafe.Sizeof(*ovector)))) - *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(i)*unsafe.Sizeof(*ovector)))))
			} else {
				return int32(0)
			}
		}()
		noarch.Memcpy(unsafe.Pointer(p), unsafe.Pointer(((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(subject)) + (uintptr)(*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(i)*unsafe.Sizeof(*ovector)))))*unsafe.Sizeof(*subject))))), int32(uint32((len))))
		*func() **pcre_uchar {
			defer func() {
				stringlist = ((**pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(stringlist)) + (uintptr)(1)*unsafe.Sizeof(*stringlist))))
			}()
			return stringlist
		}() = p
		p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(len)*unsafe.Sizeof(*p))))
		*func() *pcre_uchar {
			defer func() {
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}() = pcre_uchar(int32(0))
	}
	*stringlist = nil
	return int32(0)
}

// pcre_free_substring_list - transpiled function from  /root/Documents/pcre/pcre_get.c:509
/*************************************************
*   Free store obtained by get_substring_list    *
*************************************************/ //
/* This function exists for the benefit of people calling PCRE from non-C
programs that can call its functions, but not free() or (PUBL(free))()
directly.

Argument:   the result of a previous pcre_get_substring_list()
Returns:    nothing
*/ //
//
func pcre_free_substring_list(pointer **byte) {
	pcre_free(unsafe.Pointer(pointer))
}

// pcre_get_substring - transpiled function from  /root/Documents/pcre/pcre_get.c:550
/*************************************************
*      Copy captured string to new store         *
*************************************************/ //
/* This function copies a single captured substring into a piece of new
store

Arguments:
  subject        the subject string that was matched
  ovector        pointer to the offsets table
  stringcount    the number of substrings that were captured
                   (i.e. the yield of the pcre_exec call, unless
                   that was zero, in which case it should be 1/3
                   of the offset table size)
  stringnumber   the number of the required substring
  stringptr      where to put a pointer to the substring

Returns:         if successful:
                   the length of the string, not including the zero that
                   is put on the end; can be zero
                 if not successful:
                   PCRE_ERROR_NOMEMORY (-6) failed to get store
                   PCRE_ERROR_NOSUBSTRING (-7) substring not present
*/ //
//
func pcre_get_substring(subject *byte, ovector *int32, stringcount int32, stringnumber int32, stringptr **byte) int32 {
	var yield int32
	var substring *pcre_uchar
	if (stringnumber < int32(0)) || (stringnumber >= stringcount) {
		return (-int32(7))
	}
	stringnumber *= int32(2)
	yield = (*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)((stringnumber+int32(1)))*unsafe.Sizeof(*ovector)))) - *((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(stringnumber)*unsafe.Sizeof(*ovector)))))
	substring = (*pcre_uchar)(pcre_malloc(size_t((yield + int32(1)))))
	if substring == nil {
		return (-int32(6))
	}
	noarch.Memcpy(unsafe.Pointer(substring), unsafe.Pointer(((*byte)(unsafe.Pointer(uintptr(unsafe.Pointer(subject)) + (uintptr)(*((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(ovector)) + (uintptr)(stringnumber)*unsafe.Sizeof(*ovector)))))*unsafe.Sizeof(*subject))))), int32(uint32((yield))))
	*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(substring)) + (uintptr)(yield)*unsafe.Sizeof(*substring)))) = pcre_uchar(int32(0))
	*stringptr = (*byte)(unsafe.Pointer(substring))
	return yield
}

// pcre_get_named_substring - transpiled function from  /root/Documents/pcre/pcre_get.c:613
/*************************************************
*   Copy named captured string to new store      *
*************************************************/ //
/* This function copies a single captured substring, identified by name, into
new store. If the regex permits duplicate names, the first substring that is
set is chosen.

Arguments:
  code           the compiled regex
  subject        the subject string that was matched
  ovector        pointer to the offsets table
  stringcount    the number of substrings that were captured
                   (i.e. the yield of the pcre_exec call, unless
                   that was zero, in which case it should be 1/3
                   of the offset table size)
  stringname     the name of the required substring
  stringptr      where to put the pointer

Returns:         if successful:
                   the length of the copied string, not including the zero
                   that is put on the end; can be zero
                 if not successful:
                   PCRE_ERROR_NOMEMORY (-6) couldn't get memory
                   PCRE_ERROR_NOSUBSTRING (-7) no such captured substring
*/ //
//
func pcre_get_named_substring(code *pcre, subject *byte, ovector *int32, stringcount int32, stringname *byte, stringptr **byte) int32 {
	var n int32 = get_first_set(code, stringname, ovector, stringcount)
	if n <= int32(0) {
		return n
	}
	return pcre_get_substring(subject, ovector, stringcount, n, stringptr)
}

// pcre_free_substring - transpiled function from  /root/Documents/pcre/pcre_get.c:656
/*************************************************
*       Free store obtained by get_substring     *
*************************************************/ //
/* This function exists for the benefit of people calling PCRE from non-C
programs that can call its functions, but not free() or (PUBL(free))()
directly.

Argument:   the result of a previous pcre_get_substring()
Returns:    nothing
*/ //
//
func pcre_free_substring(pointer *byte) {
	pcre_free(unsafe.Pointer(pointer))
}

// pcre_maketables - transpiled function from  /root/Documents/pcre/pcre_maketables.c:70
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_maketables(), which builds
character tables for PCRE in the current locale. The file is compiled on its
own as part of the PCRE library. However, it is also included in the
compilation of dftables.c, in which case the macro DFTABLES is defined. */ //
/*************************************************
*           Create PCRE character tables         *
*************************************************/ //
/* This function builds a set of character tables for use by PCRE and returns
a pointer to them. They are build using the ctype functions, and consequently
their contents will depend upon the current locale setting. When compiled as
part of the library, the store is obtained via PUBL(malloc)(), but when
compiled inside dftables, use malloc().

Arguments:   none
Returns:     pointer to the contiguous block of data
*/ //
/* First comes the lower casing table */ //
/* Next the case-flipping table */ //
/* Then the character class tables. Don't try to be clever and save effort on
exclusive ones - in some locales things may be different.

Note that the table for "space" includes everything "isspace" gives, including
VT in the default locale. This makes it work for the POSIX class [:space:].
From release 8.34 is is also correct for Perl space, because Perl added VT at
release 5.18.

Note also that it is possible for a character to be alnum or alpha without
being lower or upper, such as "male and female ordinals" (\xAA and \xBA) in the
fr_FR locale (at least under Debian Linux's locales as of 12/2005). So we must
test for alnum specially. */ //
/* Finally, the character type table. In this, we used to exclude VT from the
white space chars, because Perl didn't recognize it as such for \s and for
comments within regexes. However, Perl changed at release 5.18, so PCRE changed
at release 8.34. */ //
/* Note: strchr includes the terminating zero in the characters it considers.
In this instance, that is ok because we want binary zero to be flagged as a
meta-character, which in this sense is any character that terminates a run
of data characters. */ //
//
func pcre_maketables() *uint8 {
	var yield *uint8
	var p *uint8
	var i int32
	yield = (*uint8)(pcre_malloc(size_t(((int32(512) + int32(320)) + int32(256)))))
	if yield == nil {
		return nil
	}
	p = yield
	for i = int32(0); i < int32(256); i++ {
		*func() *uint8 {
			defer func() {
				p = ((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}() = uint8(linux.ToLower(i))
	}
	for i = int32(0); i < int32(256); i++ {
		*func() *uint8 {
			defer func() {
				p = ((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}() = uint8(func() int32 {
			if (int32(*((*uint16)(func() unsafe.Pointer {
				tempVar := (*linux.CtypeLoc())
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
			}()))) & int32(uint16(_ISlower))) != 0 {
				return linux.ToUpper(i)
			} else {
				return linux.ToLower(i)
			}
		}())
	}
	noarch.Memset(unsafe.Pointer(p), int32(0), int32(uint32(int32(320))))
	for i = int32(0); i < int32(256); i++ {
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISdigit))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(64)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISupper))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(96)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISlower))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(128)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISalnum))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(160)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if i == int32('_') {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(160)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISspace))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(0)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISxdigit))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(32)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISgraph))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(192)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISprint))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(224)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISpunct))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(256)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_IScntrl))) != 0 {
			*((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)((int32(288)+(i/int32(8))))*unsafe.Sizeof(*p)))) |= uint8((int32(1) << uint64((i & int32(7)))))
		}
	}
	p = ((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(320))*unsafe.Sizeof(*p))))
	for i = int32(0); i < int32(256); i++ {
		var x int32 = int32(0)
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISspace))) != 0 {
			x += int32(1)
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISalpha))) != 0 {
			x += int32(2)
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISdigit))) != 0 {
			x += int32(4)
		}
		if (int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISxdigit))) != 0 {
			x += int32(8)
		}
		if ((int32(*((*uint16)(func() unsafe.Pointer {
			tempVar := (*linux.CtypeLoc())
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((i))*unsafe.Sizeof(*tempVar))
		}()))) & int32(uint16(_ISalnum))) != 0) || (i == int32('_')) {
			x += int32(16)
		}
		if noarch.Strchr((&[]byte("\\*+?{^.$|()[\x00")[0]), i) != nil {
			x += int32(128)
		}
		*func() *uint8 {
			defer func() {
				p = ((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}() = uint8(x)
	}
	return yield
}

// _pcre_is_newline - transpiled function from  /root/Documents/pcre/pcre_newline.c:75
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains internal functions for testing newlines when more than
one kind of newline is to be recognized. When a newline is found, its length is
returned. In principle, we could implement several newline "types", each
referring to a different set of newline characters. At present, PCRE supports
only NLTYPE_FIXED, which gets handled without these functions, NLTYPE_ANYCRLF,
and NLTYPE_ANY. The full list of Unicode newline characters is taken from
http://unicode.org/unicode/reports/tr18/. */ //
/*************************************************
*      Check for newline at given position       *
*************************************************/ //
/* It is guaranteed that the initial value of ptr is less than the end of the
string that is being processed.

Arguments:
  ptr          pointer to possible newline
  type         the newline type
  endptr       pointer to the end of the string
  lenptr       where to return the length
  utf          TRUE if in utf mode

Returns:       TRUE or FALSE
*/ //
/* Note that this function is called only for ANY or ANYCRLF. */ //
/* NLTYPE_ANY */ //
/* LS */ //
/* PS */ //
//
func _pcre_is_newline(ptr *pcre_uchar, type_ int32, endptr *pcre_uchar, lenptr *int32, utf BOOL) (c2goDefaultReturn BOOL) {
	var c pcre_uint32
	_ = BOOL(utf)
	if int32((BOOL(utf))) != 0 {
		c = pcre_uint32((uint32(uint8((*ptr)))))
		if c >= pcre_uint32((uint32(int32(192)))) {
			if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else {
				c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			}
		}
	} else {
		c = pcre_uint32((uint32(uint8((*ptr)))))
	}
	if type_ == int32(2) {
		switch pcre_uint32(c) {
		case pcre_uint32('\n'):
			{
				*lenptr = int32(1)
				return BOOL((int32(1)))
			}
		case pcre_uint32('\r'):
			{
				*lenptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*endptr)))))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\n')))]) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		default:
			{
				return BOOL((int32(0)))
			}
		}
	} else {
		switch pcre_uint32(c) {
		case pcre_uint32('\n'):
			fallthrough
		case pcre_uint32('\v'):
			fallthrough
		case pcre_uint32('\f'):
			{
				*lenptr = int32(1)
				return BOOL((int32(1)))
			}
		case pcre_uint32('\r'):
			{
				*lenptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) < int64(uintptr(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(endptr)) - (uintptr)(int32(1))*unsafe.Sizeof(*endptr)))))))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) == int32('\n')))]) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		case pcre_uint32((uint8('\u0085'))):
			{
				*lenptr = func() int32 {
					if int32((BOOL(utf))) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		case pcre_uint32(int32(8232)):
			fallthrough
		case pcre_uint32(int32(8233)):
			{
				*lenptr = int32(3)
				return BOOL((int32(1)))
			}
		default:
			{
				return BOOL((int32(0)))
			}
		}
	}
	return
}

// _pcre_was_newline - transpiled function from  /root/Documents/pcre/pcre_newline.c:150
/*************************************************
*     Check for newline at previous position     *
*************************************************/ //
/* It is guaranteed that the initial value of ptr is greater than the start of
the string that is being processed.

Arguments:
  ptr          pointer to possible newline
  type         the newline type
  startptr     pointer to the start of the string
  lenptr       where to return the length
  utf          TRUE if in utf mode

Returns:       TRUE or FALSE
*/ //
/* Note that this function is called only for ANY or ANYCRLF. */ //
/* NLTYPE_ANY */ //
/* LS */ //
/* PS */ //
//
func _pcre_was_newline(ptr *pcre_uchar, type_ int32, startptr *pcre_uchar, lenptr *int32, utf BOOL) (c2goDefaultReturn BOOL) {
	var c pcre_uint32
	_ = BOOL(utf)
	ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))
	if int32((BOOL(utf))) != 0 {
		for (int32(uint8((*ptr))) & int32(192)) == int32(128) {
			ptr = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))
		}
		c = pcre_uint32((uint32(uint8((*ptr)))))
		if c >= pcre_uint32((uint32(int32(192)))) {
			if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			} else {
				c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(1))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(2))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(3))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(4))*unsafe.Sizeof(*ptr))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + (uintptr)(int32(5))*unsafe.Sizeof(*ptr))))))) & int32(63))))))
			}
		}
	} else {
		c = pcre_uint32((uint32(uint8((*ptr)))))
	}
	if type_ == int32(2) {
		switch pcre_uint32(c) {
		case pcre_uint32('\n'):
			{
				*lenptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer(startptr)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))))) == int32('\r')))]) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		case pcre_uint32('\r'):
			{
				*lenptr = int32(1)
				return BOOL((int32(1)))
			}
		default:
			{
				return BOOL((int32(0)))
			}
		}
	} else {
		switch pcre_uint32(c) {
		case pcre_uint32('\n'):
			{
				*lenptr = func() int32 {
					if (map[bool]int32{false: 0, true: 1}[((int64(uintptr(unsafe.Pointer(ptr))) > int64(uintptr(unsafe.Pointer(startptr)))) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) - (uintptr)(1)*unsafe.Sizeof(*ptr))))))) == int32('\r')))]) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		case pcre_uint32('\v'):
			fallthrough
		case pcre_uint32('\f'):
			fallthrough
		case pcre_uint32('\r'):
			{
				*lenptr = int32(1)
				return BOOL((int32(1)))
			}
		case pcre_uint32((uint8('\u0085'))):
			{
				*lenptr = func() int32 {
					if int32((BOOL(utf))) != 0 {
						return int32(2)
					} else {
						return int32(1)
					}
				}()
				return BOOL((int32(1)))
			}
		case pcre_uint32(int32(8232)):
			fallthrough
		case pcre_uint32(int32(8233)):
			{
				*lenptr = int32(3)
				return BOOL((int32(1)))
			}
		default:
			{
				return BOOL((int32(0)))
			}
		}
	}
	return
}

// _pcre_ord2utf - transpiled function from  /root/Documents/pcre/pcre_ord2utf8.c:66
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This file contains a private PCRE function that converts an ordinal
character value into a UTF8 string. */ //
/*************************************************
*       Convert character value to UTF-8         *
*************************************************/ //
/* This function takes an integer value in the range 0 - 0x10ffff
and encodes it as a UTF-8 character in 1 to 4 pcre_uchars.

Arguments:
  cvalue     the character value
  buffer     pointer to buffer for result - at least 6 pcre_uchars long

Returns:     number of characters placed in the buffer
*/ //
//
func _pcre_ord2utf(cvalue pcre_uint32, buffer *pcre_uchar) uint32 {
	var i int32
	var j int32
	for i = int32(0); i < _pcre_utf8_table1_size; i++ {
		if int32(uint32((pcre_uint32(cvalue)))) <= *((*int32)(func() unsafe.Pointer {
			tempVar := &_pcre_utf8_table1[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
		}())) {
			break
		}
	}
	buffer = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(buffer)) + (uintptr)(i)*unsafe.Sizeof(*buffer))))
	for j = i; j > int32(0); j-- {
		*func() *pcre_uchar {
			defer func() {
				buffer = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(buffer)) - (uintptr)(1)*unsafe.Sizeof(*buffer))))
			}()
			return buffer
		}() = pcre_uchar((uint8((uint32(int32(128)) | uint32((cvalue & pcre_uint32((uint32(int32(63))))))))))
		cvalue >>= pcre_uint32((uint32(uint64(int32(6)))))
	}
	*buffer = pcre_uchar((uint8((uint32(*((*int32)(func() unsafe.Pointer {
		tempVar := &_pcre_utf8_table2[0]
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(i)*unsafe.Sizeof(*tempVar))
	}()))) | uint32((cvalue))))))
	return uint32((i + int32(1)))
}

// pcre_refcount - transpiled function from  /root/Documents/pcre/pcre_refcount.c:72
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_refcount(), which is an
auxiliary function that can be used to maintain a reference count in a compiled
pattern data block. This might be helpful in applications where the block is
shared by different users. */ //
/*************************************************
*           Maintain reference count             *
*************************************************/ //
/* The reference count is a 16-bit field, initialized to zero. It is not
possible to transfer a non-zero count from one host to a different host that
has a different byte order - though I can't see why anyone in their right mind
would ever want to do that!

Arguments:
  argument_re   points to compiled code
  adjust        value to add to the count

Returns:        the (possibly updated) count value (a non-negative number), or
                a negative error number
*/ //
//
func pcre_refcount(argument_re *pcre, adjust int32) int32 {
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(argument_re))
	if re == nil {
		return (-int32(2))
	}
	if uint32((pcre_uint32((*re).magic_number))) != uint32(1346589253) {
		return (-int32(4))
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		return (-int32(28))
	}
	(*re).ref_count = pcre_uint16((uint16(func() int32 {
		if (map[bool]int32{false: 0, true: 1}[(-adjust > int32(uint16((pcre_uint16((*re).ref_count)))))]) != 0 {
			return int32(0)
		} else {
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((adjust + int32(uint16((pcre_uint16((*re).ref_count))))) > int32(65535))]) != 0 {
					return int32(65535)
				} else {
					return (int32(uint16((pcre_uint16((*re).ref_count)))) + adjust)
				}
			}()
		}
	}())))
	return int32(uint16((pcre_uint16((*re).ref_count))))
}

const SSB_FAIL int32 = 0
const SSB_DONE int32 = 1
const SSB_CONTINUE int32 = 2
const SSB_UNKNOWN int32 = 3

// find_minlength - transpiled function from  /root/Documents/pcre/pcre_study.c:82
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_study(), along with local
supporting functions. */ //
/* Returns from set_start_bits() */ //
/*************************************************
*   Find the minimum subject length for a group  *
*************************************************/ //
/* Scan a parenthesized group and compute the minimum length of subject that
is needed to match it. This is a lower bound; it does not mean there is a
string of that length that matches. In UTF8 mode, the result is in characters
rather than bytes.

Arguments:
  re              compiled pattern block
  code            pointer to start of group (the bracket)
  startcode       pointer to start of the whole pattern's code
  options         the compiling options
  recurses        chain of recurse_check to catch mutual recursion
  countptr        pointer to call count (to catch over complexity)

Returns:   the minimum length
           -1 if \C in UTF-8 mode or (*ACCEPT) was encountered
           -2 internal error (missing capturing bracket)
           -3 internal error (opcode not listed)
*/ //
/* PCRE_UTF16 has the same value as PCRE_UTF8. */ //
/* too complex */ //
/* Scan along the opcodes for this branch. If we get to the end of the
branch, check the length against that of the other branches. */ //
/* If there is only one branch in a condition, the implied branch has zero
   length, so we don't add anything. This covers the DEFINE "condition"
   automatically. */ //
/* Otherwise we can fall through and treat it the same as any other
   subpattern. */ //
/* ACCEPT makes things far too complicated; we have to give up. */ //
/* Reached end of a branch; if it's a ket it is the end of a nested
   call. If it's ALT it is an alternation in a nested call. If it is END it's
   the end of the outer call. All can be handled by the same code. If an
   ACCEPT was previously encountered, use the length that was in force at that
   time, and pass back the shortest ACCEPT length. */ //
/* Skip over assertive subpatterns */ //
/* Fall through */ //
/* Skip over things that don't match chars */ //
/* Skip over a subpattern that has a {0} or {0,x} quantifier */ //
/* Handle literal characters and + repetitions */ //
/* Handle exact repetitions. The count is already in characters, but we
   need to skip over a multibyte character in UTF8 mode.  */ //
/* Handle single-char non-literal matchers */ //
/* Fall through */ //
/* "Any newline" might match two characters, but it also might match just
   one. */ //
/* The single-byte matcher means we can't proceed in UTF-8 mode. (In
   non-UTF-8 mode \C will actually be turned into OP_ALLANY, so won't ever
   appear, but leave the code, just in case.) */ //
/* For repeated character types, we have to test for \p and \P, which have
   an extra two bytes of parameters. */ //
/* Check a class for variable quantification */ //
/* The original code caused an unsigned overflow in 64 bit systems,
   so now we use a conditional statement. */ //
/* Fall through */ //
/* Backreferences and subroutine calls are treated in the same way: we find
   the minimum length for the subpattern. A recursion, however, causes an
   a flag to be set that causes the length of this branch to be ignored. The
   logic is that a recursion can only make sense if there is another
   alternation that stops the recursing. That will provide the minimum length
   (when no recursion happens). A backreference within the group that it is
   referencing behaves in the same way.

   If PCRE_JAVASCRIPT_COMPAT is set, a backreference to an unset bracket
   matches an empty string (by default it causes a matching failure), so in
   that case we must set the minimum length to zero. */ //
/* Duplicate named pattern back reference */ //
/* Simple recursion */ //
/* Mutual recursion */ //
/* Single back reference */ //
/* Simple recursion */ //
/* Mutual recursion */ //
/* Handle repeated back references */ //
/* We can easily detect direct recursion, but not mutual recursion. This is
   caught by a recursion depth count. */ //
/* Simple recursion */ //
/* Mutual recursion */ //
/* Anything else does not or need not match a character. We can get the
   item's length from the table, but for those that can match zero occurrences
   of a character, we must take special action for UTF-8 characters. As it
   happens, the "NOT" versions of these opcodes are used at present only for
   ASCII characters, so they could be omitted from this list. However, in
   future that may change, so we include them here so as not to leave a
   gotcha for a future maintainer. */ //
/* Skip these, but we need to add in the name length. */ //
/* The remaining opcodes are just skipped over. */ //
/* This should not occur: we list all opcodes explicitly so that when
   new ones get added they are properly considered. */ //
/* Control never gets here */ //
//
func find_minlength(re *real_pcre, code *pcre_uchar, startcode *pcre_uchar, options int32, recurses *recurse_check, countptr *int32) (c2goDefaultReturn int32) {
	var length int32 = -int32(1)
	var utf BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((options & int32(2048)) != int32(0))]))
	var had_recurse BOOL = BOOL((int32(0)))
	var this_recurse recurse_check
	var branchlength int32 = int32(0)
	var cc *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
	}()))
	if func() int32 {
		tempVar := &(*countptr)
		defer func() {
			*tempVar += 1
		}()
		return *tempVar
	}() > int32(1000) {
		return -int32(1)
	}
	if (((int32(uint8((*code))) == OP_CBRA) || (int32(uint8((*code))) == OP_SCBRA)) || (int32(uint8((*code))) == OP_CBRAPOS)) || (int32(uint8((*code))) == OP_SCBRAPOS) {
		cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
	}
	for {
		var d int32
		var min int32
		var cs *pcre_uchar
		var ce *pcre_uchar
		var op pcre_uchar = *cc
		switch int32(uint8((pcre_uchar(op)))) {
		case OP_COND:
			goto SW_GENERATED_LABEL_542
		case OP_SCOND:
			goto SW_GENERATED_LABEL_543
		case OP_CBRA:
			goto SW_GENERATED_LABEL_544
		case OP_SCBRA:
			goto SW_GENERATED_LABEL_545
		case OP_BRA:
			goto SW_GENERATED_LABEL_546
		case OP_SBRA:
			goto SW_GENERATED_LABEL_547
		case OP_CBRAPOS:
			goto SW_GENERATED_LABEL_548
		case OP_SCBRAPOS:
			goto SW_GENERATED_LABEL_549
		case OP_BRAPOS:
			goto SW_GENERATED_LABEL_550
		case OP_SBRAPOS:
			goto SW_GENERATED_LABEL_551
		case OP_ONCE:
			goto SW_GENERATED_LABEL_552
		case OP_ONCE_NC:
			goto SW_GENERATED_LABEL_553
		case OP_ACCEPT:
			goto SW_GENERATED_LABEL_554
		case OP_ASSERT_ACCEPT:
			goto SW_GENERATED_LABEL_555
		case OP_ALT:
			goto SW_GENERATED_LABEL_556
		case OP_KET:
			goto SW_GENERATED_LABEL_557
		case OP_KETRMAX:
			goto SW_GENERATED_LABEL_558
		case OP_KETRMIN:
			goto SW_GENERATED_LABEL_559
		case OP_KETRPOS:
			goto SW_GENERATED_LABEL_560
		case OP_END:
			goto SW_GENERATED_LABEL_561
		case OP_ASSERT:
			goto SW_GENERATED_LABEL_562
		case OP_ASSERT_NOT:
			goto SW_GENERATED_LABEL_563
		case OP_ASSERTBACK:
			goto SW_GENERATED_LABEL_564
		case OP_ASSERTBACK_NOT:
			goto SW_GENERATED_LABEL_565
		case OP_REVERSE:
			goto SW_GENERATED_LABEL_566
		case OP_CREF:
			goto SW_GENERATED_LABEL_567
		case OP_DNCREF:
			goto SW_GENERATED_LABEL_568
		case OP_RREF:
			goto SW_GENERATED_LABEL_569
		case OP_DNRREF:
			goto SW_GENERATED_LABEL_570
		case OP_DEF:
			goto SW_GENERATED_LABEL_571
		case OP_CALLOUT:
			goto SW_GENERATED_LABEL_572
		case OP_SOD:
			goto SW_GENERATED_LABEL_573
		case OP_SOM:
			goto SW_GENERATED_LABEL_574
		case OP_EOD:
			goto SW_GENERATED_LABEL_575
		case OP_EODN:
			goto SW_GENERATED_LABEL_576
		case OP_CIRC:
			goto SW_GENERATED_LABEL_577
		case OP_CIRCM:
			goto SW_GENERATED_LABEL_578
		case OP_DOLL:
			goto SW_GENERATED_LABEL_579
		case OP_DOLLM:
			goto SW_GENERATED_LABEL_580
		case OP_NOT_WORD_BOUNDARY:
			goto SW_GENERATED_LABEL_581
		case OP_WORD_BOUNDARY:
			goto SW_GENERATED_LABEL_582
		case OP_BRAZERO:
			goto SW_GENERATED_LABEL_583
		case OP_BRAMINZERO:
			goto SW_GENERATED_LABEL_584
		case OP_BRAPOSZERO:
			goto SW_GENERATED_LABEL_585
		case OP_SKIPZERO:
			goto SW_GENERATED_LABEL_586
		case OP_CHAR:
			goto SW_GENERATED_LABEL_587
		case OP_CHARI:
			goto SW_GENERATED_LABEL_588
		case OP_NOT:
			goto SW_GENERATED_LABEL_589
		case OP_NOTI:
			goto SW_GENERATED_LABEL_590
		case OP_PLUS:
			goto SW_GENERATED_LABEL_591
		case OP_PLUSI:
			goto SW_GENERATED_LABEL_592
		case OP_MINPLUS:
			goto SW_GENERATED_LABEL_593
		case OP_MINPLUSI:
			goto SW_GENERATED_LABEL_594
		case OP_POSPLUS:
			goto SW_GENERATED_LABEL_595
		case OP_POSPLUSI:
			goto SW_GENERATED_LABEL_596
		case OP_NOTPLUS:
			goto SW_GENERATED_LABEL_597
		case OP_NOTPLUSI:
			goto SW_GENERATED_LABEL_598
		case OP_NOTMINPLUS:
			goto SW_GENERATED_LABEL_599
		case OP_NOTMINPLUSI:
			goto SW_GENERATED_LABEL_600
		case OP_NOTPOSPLUS:
			goto SW_GENERATED_LABEL_601
		case OP_NOTPOSPLUSI:
			goto SW_GENERATED_LABEL_602
		case OP_TYPEPLUS:
			goto SW_GENERATED_LABEL_603
		case OP_TYPEMINPLUS:
			goto SW_GENERATED_LABEL_604
		case OP_TYPEPOSPLUS:
			goto SW_GENERATED_LABEL_605
		case OP_EXACT:
			goto SW_GENERATED_LABEL_606
		case OP_EXACTI:
			goto SW_GENERATED_LABEL_607
		case OP_NOTEXACT:
			goto SW_GENERATED_LABEL_608
		case OP_NOTEXACTI:
			goto SW_GENERATED_LABEL_609
		case OP_TYPEEXACT:
			goto SW_GENERATED_LABEL_610
		case OP_PROP:
			goto SW_GENERATED_LABEL_611
		case OP_NOTPROP:
			goto SW_GENERATED_LABEL_612
		case OP_NOT_DIGIT:
			goto SW_GENERATED_LABEL_613
		case OP_DIGIT:
			goto SW_GENERATED_LABEL_614
		case OP_NOT_WHITESPACE:
			goto SW_GENERATED_LABEL_615
		case OP_WHITESPACE:
			goto SW_GENERATED_LABEL_616
		case OP_NOT_WORDCHAR:
			goto SW_GENERATED_LABEL_617
		case OP_WORDCHAR:
			goto SW_GENERATED_LABEL_618
		case OP_ANY:
			goto SW_GENERATED_LABEL_619
		case OP_ALLANY:
			goto SW_GENERATED_LABEL_620
		case OP_EXTUNI:
			goto SW_GENERATED_LABEL_621
		case OP_HSPACE:
			goto SW_GENERATED_LABEL_622
		case OP_NOT_HSPACE:
			goto SW_GENERATED_LABEL_623
		case OP_VSPACE:
			goto SW_GENERATED_LABEL_624
		case OP_NOT_VSPACE:
			goto SW_GENERATED_LABEL_625
		case OP_ANYNL:
			goto SW_GENERATED_LABEL_626
		case OP_ANYBYTE:
			goto SW_GENERATED_LABEL_627
		case OP_TYPESTAR:
			goto SW_GENERATED_LABEL_628
		case OP_TYPEMINSTAR:
			goto SW_GENERATED_LABEL_629
		case OP_TYPEQUERY:
			goto SW_GENERATED_LABEL_630
		case OP_TYPEMINQUERY:
			goto SW_GENERATED_LABEL_631
		case OP_TYPEPOSSTAR:
			goto SW_GENERATED_LABEL_632
		case OP_TYPEPOSQUERY:
			goto SW_GENERATED_LABEL_633
		case OP_TYPEUPTO:
			goto SW_GENERATED_LABEL_634
		case OP_TYPEMINUPTO:
			goto SW_GENERATED_LABEL_635
		case OP_TYPEPOSUPTO:
			goto SW_GENERATED_LABEL_636
		case OP_CLASS:
			goto SW_GENERATED_LABEL_637
		case OP_NCLASS:
			goto SW_GENERATED_LABEL_638
		case OP_XCLASS:
			goto SW_GENERATED_LABEL_639
		case OP_DNREF:
			goto SW_GENERATED_LABEL_640
		case OP_DNREFI:
			goto SW_GENERATED_LABEL_641
		case OP_REF:
			goto SW_GENERATED_LABEL_642
		case OP_REFI:
			goto SW_GENERATED_LABEL_643
		case OP_RECURSE:
			goto SW_GENERATED_LABEL_644
		case OP_UPTO:
			goto SW_GENERATED_LABEL_645
		case OP_UPTOI:
			goto SW_GENERATED_LABEL_646
		case OP_NOTUPTO:
			goto SW_GENERATED_LABEL_647
		case OP_NOTUPTOI:
			goto SW_GENERATED_LABEL_648
		case OP_MINUPTO:
			goto SW_GENERATED_LABEL_649
		case OP_MINUPTOI:
			goto SW_GENERATED_LABEL_650
		case OP_NOTMINUPTO:
			goto SW_GENERATED_LABEL_651
		case OP_NOTMINUPTOI:
			goto SW_GENERATED_LABEL_652
		case OP_POSUPTO:
			goto SW_GENERATED_LABEL_653
		case OP_POSUPTOI:
			goto SW_GENERATED_LABEL_654
		case OP_NOTPOSUPTO:
			goto SW_GENERATED_LABEL_655
		case OP_NOTPOSUPTOI:
			goto SW_GENERATED_LABEL_656
		case OP_STAR:
			goto SW_GENERATED_LABEL_657
		case OP_STARI:
			goto SW_GENERATED_LABEL_658
		case OP_NOTSTAR:
			goto SW_GENERATED_LABEL_659
		case OP_NOTSTARI:
			goto SW_GENERATED_LABEL_660
		case OP_MINSTAR:
			goto SW_GENERATED_LABEL_661
		case OP_MINSTARI:
			goto SW_GENERATED_LABEL_662
		case OP_NOTMINSTAR:
			goto SW_GENERATED_LABEL_663
		case OP_NOTMINSTARI:
			goto SW_GENERATED_LABEL_664
		case OP_POSSTAR:
			goto SW_GENERATED_LABEL_665
		case OP_POSSTARI:
			goto SW_GENERATED_LABEL_666
		case OP_NOTPOSSTAR:
			goto SW_GENERATED_LABEL_667
		case OP_NOTPOSSTARI:
			goto SW_GENERATED_LABEL_668
		case OP_QUERY:
			goto SW_GENERATED_LABEL_669
		case OP_QUERYI:
			goto SW_GENERATED_LABEL_670
		case OP_NOTQUERY:
			goto SW_GENERATED_LABEL_671
		case OP_NOTQUERYI:
			goto SW_GENERATED_LABEL_672
		case OP_MINQUERY:
			goto SW_GENERATED_LABEL_673
		case OP_MINQUERYI:
			goto SW_GENERATED_LABEL_674
		case OP_NOTMINQUERY:
			goto SW_GENERATED_LABEL_675
		case OP_NOTMINQUERYI:
			goto SW_GENERATED_LABEL_676
		case OP_POSQUERY:
			goto SW_GENERATED_LABEL_677
		case OP_POSQUERYI:
			goto SW_GENERATED_LABEL_678
		case OP_NOTPOSQUERY:
			goto SW_GENERATED_LABEL_679
		case OP_NOTPOSQUERYI:
			goto SW_GENERATED_LABEL_680
		case OP_MARK:
			goto SW_GENERATED_LABEL_681
		case OP_PRUNE_ARG:
			goto SW_GENERATED_LABEL_682
		case OP_SKIP_ARG:
			goto SW_GENERATED_LABEL_683
		case OP_THEN_ARG:
			goto SW_GENERATED_LABEL_684
		case OP_CLOSE:
			goto SW_GENERATED_LABEL_685
		case OP_COMMIT:
			goto SW_GENERATED_LABEL_686
		case OP_FAIL:
			goto SW_GENERATED_LABEL_687
		case OP_PRUNE:
			goto SW_GENERATED_LABEL_688
		case OP_SET_SOM:
			goto SW_GENERATED_LABEL_689
		case OP_SKIP:
			goto SW_GENERATED_LABEL_690
		case OP_THEN:
			goto SW_GENERATED_LABEL_691
		default:
			goto SW_GENERATED_LABEL_692
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_542:
		;
	SW_GENERATED_LABEL_543:
		{
			cs = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
			if int32(uint8((*cs))) != OP_ALT {
				cc = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cs)) + (uintptr)(int32(1))*unsafe.Sizeof(*cs))))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
				}()))
				goto SW_GENERATED_LABEL_541
			}
		}
	SW_GENERATED_LABEL_544:
		;
	SW_GENERATED_LABEL_545:
		;
	SW_GENERATED_LABEL_546:
		;
	SW_GENERATED_LABEL_547:
		;
	SW_GENERATED_LABEL_548:
		;
	SW_GENERATED_LABEL_549:
		;
	SW_GENERATED_LABEL_550:
		;
	SW_GENERATED_LABEL_551:
		;
	SW_GENERATED_LABEL_552:
		;
	SW_GENERATED_LABEL_553:
		{
			d = find_minlength(re, cc, startcode, options, recurses, countptr)
			if d < int32(0) {
				return d
			}
			branchlength += d
			for {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*cc))) == OP_ALT)])) != 0 {
					break
				}
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_554:
		;
	SW_GENERATED_LABEL_555:
		{
			return -int32(1)
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_556:
		;
	SW_GENERATED_LABEL_557:
		;
	SW_GENERATED_LABEL_558:
		;
	SW_GENERATED_LABEL_559:
		;
	SW_GENERATED_LABEL_560:
		;
	SW_GENERATED_LABEL_561:
		{
			if (length < int32(0)) || ((int32((NotBOOL(BOOL(had_recurse)))) != 0) && (branchlength < length)) {
				length = branchlength
			}
			if int32(uint8((op))) != OP_ALT {
				return length
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
			branchlength = int32(0)
			had_recurse = BOOL((int32(0)))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_562:
		;
	SW_GENERATED_LABEL_563:
		;
	SW_GENERATED_LABEL_564:
		;
	SW_GENERATED_LABEL_565:
		{
			for {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*cc))) == OP_ALT)])) != 0 {
					break
				}
			}
		}
	SW_GENERATED_LABEL_566:
		;
	SW_GENERATED_LABEL_567:
		;
	SW_GENERATED_LABEL_568:
		;
	SW_GENERATED_LABEL_569:
		;
	SW_GENERATED_LABEL_570:
		;
	SW_GENERATED_LABEL_571:
		;
	SW_GENERATED_LABEL_572:
		;
	SW_GENERATED_LABEL_573:
		;
	SW_GENERATED_LABEL_574:
		;
	SW_GENERATED_LABEL_575:
		;
	SW_GENERATED_LABEL_576:
		;
	SW_GENERATED_LABEL_577:
		;
	SW_GENERATED_LABEL_578:
		;
	SW_GENERATED_LABEL_579:
		;
	SW_GENERATED_LABEL_580:
		;
	SW_GENERATED_LABEL_581:
		;
	SW_GENERATED_LABEL_582:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*cc))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_583:
		;
	SW_GENERATED_LABEL_584:
		;
	SW_GENERATED_LABEL_585:
		;
	SW_GENERATED_LABEL_586:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*cc))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
			for {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*cc))) == OP_ALT)])) != 0 {
					break
				}
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_587:
		;
	SW_GENERATED_LABEL_588:
		;
	SW_GENERATED_LABEL_589:
		;
	SW_GENERATED_LABEL_590:
		;
	SW_GENERATED_LABEL_591:
		;
	SW_GENERATED_LABEL_592:
		;
	SW_GENERATED_LABEL_593:
		;
	SW_GENERATED_LABEL_594:
		;
	SW_GENERATED_LABEL_595:
		;
	SW_GENERATED_LABEL_596:
		;
	SW_GENERATED_LABEL_597:
		;
	SW_GENERATED_LABEL_598:
		;
	SW_GENERATED_LABEL_599:
		;
	SW_GENERATED_LABEL_600:
		;
	SW_GENERATED_LABEL_601:
		;
	SW_GENERATED_LABEL_602:
		{
			branchlength += 1
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
			if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc))))))) >= int32(192)) {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_utf8_table4[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*cc))))
			}
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_603:
		;
	SW_GENERATED_LABEL_604:
		;
	SW_GENERATED_LABEL_605:
		{
			branchlength += 1
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc))))))) == OP_NOTPROP))]) != 0 {
					return int32(4)
				} else {
					return int32(2)
				}
			}())*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_606:
		;
	SW_GENERATED_LABEL_607:
		;
	SW_GENERATED_LABEL_608:
		;
	SW_GENERATED_LABEL_609:
		{
			branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(2)+int32(2)))*unsafe.Sizeof(*cc))))
			if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc))))))) >= int32(192)) {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_utf8_table4[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*cc))))
			}
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_610:
		{
			branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(2)+int32(2))+func() int32 {
				if (map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_NOTPROP))]) != 0 {
					return int32(2)
				} else {
					return int32(0)
				}
			}()))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_611:
		;
	SW_GENERATED_LABEL_612:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
		}
	SW_GENERATED_LABEL_613:
		;
	SW_GENERATED_LABEL_614:
		;
	SW_GENERATED_LABEL_615:
		;
	SW_GENERATED_LABEL_616:
		;
	SW_GENERATED_LABEL_617:
		;
	SW_GENERATED_LABEL_618:
		;
	SW_GENERATED_LABEL_619:
		;
	SW_GENERATED_LABEL_620:
		;
	SW_GENERATED_LABEL_621:
		;
	SW_GENERATED_LABEL_622:
		;
	SW_GENERATED_LABEL_623:
		;
	SW_GENERATED_LABEL_624:
		;
	SW_GENERATED_LABEL_625:
		{
			branchlength += 1
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_626:
		{
			branchlength += int32(1)
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_627:
		{
			if int32((BOOL(utf))) != 0 {
				return -int32(1)
			}
			branchlength += 1
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_628:
		;
	SW_GENERATED_LABEL_629:
		;
	SW_GENERATED_LABEL_630:
		;
	SW_GENERATED_LABEL_631:
		;
	SW_GENERATED_LABEL_632:
		;
	SW_GENERATED_LABEL_633:
		{
			if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc))))))) == OP_NOTPROP) {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((op))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_634:
		;
	SW_GENERATED_LABEL_635:
		;
	SW_GENERATED_LABEL_636:
		{
			if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_PROP) || (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))))) == OP_NOTPROP) {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(2))*unsafe.Sizeof(*cc))))
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((op))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_637:
		;
	SW_GENERATED_LABEL_638:
		;
	SW_GENERATED_LABEL_639:
		{
			if int32(uint8((op))) == OP_XCLASS {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*cc))))
			} else {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_OP_lengths[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(OP_CLASS)*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*cc))))
			}
			switch int32(uint8((pcre_uchar(*cc)))) {
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRPOSPLUS:
				{
					branchlength += 1
				}
				fallthrough
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSQUERY:
				{
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					branchlength += int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*cc))))
				}
			default:
				{
					branchlength += 1
					break
				}
			}
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_640:
		;
	SW_GENERATED_LABEL_641:
		{
			if (options & int32(33554432)) == int32(0) {
				var count int32 = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(((int32(1)+int32(2))+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
				var slot *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
					tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := (*pcre_uchar)(unsafe.Pointer(re))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
					}()))
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*uint32(uint16((pcre_uint16((*re).name_entry_size)))))))*unsafe.Sizeof(*tempVar))
				}()))
				d = int32(2147483647)
				for func() int32 {
					defer func() {
						count -= 1
					}()
					return count
				}() > int32(0) {
					cs = _pcre_find_bracket(startcode, BOOL(utf), int32(uint32(((int32(uint8((*(slot)))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((slot))) + (uintptr)((int32(0)+int32(1)))*unsafe.Sizeof(*(slot))))))))))))
					ce = cs
					if cs == nil {
						return -int32(2)
					}
					for {
						ce = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ce)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ce))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ce))))))))))*unsafe.Sizeof(*ce))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ce))) == OP_ALT)])) != 0 {
							break
						}
					}
					if (int64(uintptr(unsafe.Pointer(cc))) > int64(uintptr(unsafe.Pointer(cs)))) && (int64(uintptr(unsafe.Pointer(cc))) < int64(uintptr(unsafe.Pointer(ce)))) {
						d = int32(0)
						had_recurse = BOOL((int32(1)))
						break
					} else {
						var r *recurse_check = recurses
						for r = recurses; r != nil; r = (*r).prev {
							if int64(uintptr(unsafe.Pointer((*r).group))) == int64(uintptr(unsafe.Pointer(cs))) {
								break
							}
						}
						if r != nil {
							d = int32(0)
							had_recurse = BOOL((int32(1)))
							break
						} else {
							var dd int32
							this_recurse.prev = recurses
							this_recurse.group = cs
							dd = find_minlength(re, cs, startcode, options, &this_recurse, countptr)
							if dd < d {
								d = dd
							}
						}
					}
					slot = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(slot)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_entry_size)))))*unsafe.Sizeof(*slot))))
				}
			} else {
				d = int32(0)
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*cc))))
			goto REPEAT_BACK_REFERENCE
		}
	SW_GENERATED_LABEL_642:
		;
	SW_GENERATED_LABEL_643:
		{
			if (options & int32(33554432)) == int32(0) {
				cs = _pcre_find_bracket(startcode, BOOL(utf), int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))))
				ce = cs
				if cs == nil {
					return -int32(2)
				}
				for {
					ce = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ce)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ce))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ce))))))))))*unsafe.Sizeof(*ce))))
					if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ce))) == OP_ALT)])) != 0 {
						break
					}
				}
				if (int64(uintptr(unsafe.Pointer(cc))) > int64(uintptr(unsafe.Pointer(cs)))) && (int64(uintptr(unsafe.Pointer(cc))) < int64(uintptr(unsafe.Pointer(ce)))) {
					d = int32(0)
					had_recurse = BOOL((int32(1)))
				} else {
					var r *recurse_check = recurses
					for r = recurses; r != nil; r = (*r).prev {
						if int64(uintptr(unsafe.Pointer((*r).group))) == int64(uintptr(unsafe.Pointer(cs))) {
							break
						}
					}
					if r != nil {
						d = int32(0)
						had_recurse = BOOL((int32(1)))
					} else {
						this_recurse.prev = recurses
						this_recurse.group = cs
						d = find_minlength(re, cs, startcode, options, &this_recurse, countptr)
					}
				}
			} else {
				d = int32(0)
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
		}
	REPEAT_BACK_REFERENCE:
		{
			switch int32(uint8((pcre_uchar(*cc)))) {
			case OP_CRSTAR:
				fallthrough
			case OP_CRMINSTAR:
				fallthrough
			case OP_CRQUERY:
				fallthrough
			case OP_CRMINQUERY:
				fallthrough
			case OP_CRPOSSTAR:
				fallthrough
			case OP_CRPOSQUERY:
				{
					min = int32(0)
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
				}
			case OP_CRPLUS:
				fallthrough
			case OP_CRMINPLUS:
				fallthrough
			case OP_CRPOSPLUS:
				{
					min = int32(1)
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(1)*unsafe.Sizeof(*cc))))
				}
			case OP_CRRANGE:
				fallthrough
			case OP_CRMINRANGE:
				fallthrough
			case OP_CRPOSRANGE:
				{
					min = int32(uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc)))))))))))
					cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*cc))))
				}
			default:
				{
					min = int32(1)
					break
				}
			}
			branchlength += (min * d)
			goto SW_GENERATED_LABEL_541
		}
	SW_GENERATED_LABEL_644:
		{
			ce = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(startcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)(int32(1))*unsafe.Sizeof(*(cc))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((cc))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(cc))))))))))*unsafe.Sizeof(*startcode))))
			cs = ce
			for {
				ce = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ce)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)(int32(1))*unsafe.Sizeof(*(ce))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((ce))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(ce))))))))))*unsafe.Sizeof(*ce))))
				if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*ce))) == OP_ALT)])) != 0 {
					break
				}
			}
			if (int64(uintptr(unsafe.Pointer(cc))) > int64(uintptr(unsafe.Pointer(cs)))) && (int64(uintptr(unsafe.Pointer(cc))) < int64(uintptr(unsafe.Pointer(ce)))) {
				had_recurse = BOOL((int32(1)))
			} else {
				var r *recurse_check = recurses
				for r = recurses; r != nil; r = (*r).prev {
					if int64(uintptr(unsafe.Pointer((*r).group))) == int64(uintptr(unsafe.Pointer(cs))) {
						break
					}
				}
				if r != nil {
					had_recurse = BOOL((int32(1)))
				} else {
					this_recurse.prev = recurses
					this_recurse.group = cs
					branchlength += find_minlength(re, cs, startcode, options, &this_recurse, countptr)
				}
			}
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_645:
		;
	SW_GENERATED_LABEL_646:
		;
	SW_GENERATED_LABEL_647:
		;
	SW_GENERATED_LABEL_648:
		;
	SW_GENERATED_LABEL_649:
		;
	SW_GENERATED_LABEL_650:
		;
	SW_GENERATED_LABEL_651:
		;
	SW_GENERATED_LABEL_652:
		;
	SW_GENERATED_LABEL_653:
		;
	SW_GENERATED_LABEL_654:
		;
	SW_GENERATED_LABEL_655:
		;
	SW_GENERATED_LABEL_656:
		;
	SW_GENERATED_LABEL_657:
		;
	SW_GENERATED_LABEL_658:
		;
	SW_GENERATED_LABEL_659:
		;
	SW_GENERATED_LABEL_660:
		;
	SW_GENERATED_LABEL_661:
		;
	SW_GENERATED_LABEL_662:
		;
	SW_GENERATED_LABEL_663:
		;
	SW_GENERATED_LABEL_664:
		;
	SW_GENERATED_LABEL_665:
		;
	SW_GENERATED_LABEL_666:
		;
	SW_GENERATED_LABEL_667:
		;
	SW_GENERATED_LABEL_668:
		;
	SW_GENERATED_LABEL_669:
		;
	SW_GENERATED_LABEL_670:
		;
	SW_GENERATED_LABEL_671:
		;
	SW_GENERATED_LABEL_672:
		;
	SW_GENERATED_LABEL_673:
		;
	SW_GENERATED_LABEL_674:
		;
	SW_GENERATED_LABEL_675:
		;
	SW_GENERATED_LABEL_676:
		;
	SW_GENERATED_LABEL_677:
		;
	SW_GENERATED_LABEL_678:
		;
	SW_GENERATED_LABEL_679:
		;
	SW_GENERATED_LABEL_680:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((op))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
			if (int32((utf)) != 0) && (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc))))))) >= int32(192)) {
				cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
					tempVar := &_pcre_utf8_table4[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) - (uintptr)(1)*unsafe.Sizeof(*cc)))))))&int32(63)))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*cc))))
			}
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_681:
		;
	SW_GENERATED_LABEL_682:
		;
	SW_GENERATED_LABEL_683:
		;
	SW_GENERATED_LABEL_684:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((op))))*unsafe.Sizeof(*tempVar))
			}())))))+int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(1))*unsafe.Sizeof(*cc)))))))))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_685:
		;
	SW_GENERATED_LABEL_686:
		;
	SW_GENERATED_LABEL_687:
		;
	SW_GENERATED_LABEL_688:
		;
	SW_GENERATED_LABEL_689:
		;
	SW_GENERATED_LABEL_690:
		;
	SW_GENERATED_LABEL_691:
		{
			cc = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(cc)) + (uintptr)(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := &_pcre_OP_lengths[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((op))))*unsafe.Sizeof(*tempVar))
			}()))))))*unsafe.Sizeof(*cc))))
		}
		goto SW_GENERATED_LABEL_541
	SW_GENERATED_LABEL_692:
		{
			return -int32(3)
		}
	SW_GENERATED_LABEL_541:
	}
	return
}

// set_table_bit - transpiled function from  /root/Documents/pcre/pcre_study.c:634
/*************************************************
*      Set a bit and maybe its alternate case    *
*************************************************/ //
/* Given a character, set its first byte's bit in the table, and also the
corresponding bit for the other version of a letter if we are caseless. In
UTF-8 mode, for characters greater than 127, we can only do the caseless thing
when Unicode property support is available.

Arguments:
  start_bits    points to the bit map
  p             points to the character
  caseless      the caseless flag
  cd            the block with char table pointers
  utf           TRUE for UTF-8 / UTF-16 / UTF-32 mode

Returns:        pointer after the character
*/ //
/* Not UTF-8 mode, or character is less than 127. */ //
//
func set_table_bit(start_bits *pcre_uint8, p *pcre_uchar, caseless BOOL, cd *compile_data, utf BOOL) *pcre_uchar {
	var c pcre_uint32 = pcre_uint32((uint32(uint8((*p)))))
	*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7)))))))))))
	if (int32((utf)) != 0) && (c > pcre_uint32((uint32(int32(127))))) {
		c = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
			defer func() {
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
			}()
			return p
		}())))))
		if c >= pcre_uint32((uint32(int32(192)))) {
			if (c & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((c & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
					defer func() {
						p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					}()
					return p
				}()))) & int32(63))))))
			} else if (c & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((c & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63))))))
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))
			} else if (c & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
				c = (((((c & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63))))))
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))
			} else if (c & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
				c = ((((((c & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))))) & int32(63))))))
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(4))*unsafe.Sizeof(*p))))
			} else {
				c = (((((((c & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*p))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(2))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(3))*unsafe.Sizeof(*p))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(4))*unsafe.Sizeof(*p))))))) & int32(63))))))
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(5))*unsafe.Sizeof(*p))))
			}
		}
		if int32((BOOL(caseless))) != 0 {
			var buff []pcre_uchar = make([]pcre_uchar, 6, 6)
			c = pcre_uint32((int32(uint32((pcre_uint32(c)))) + int32((pcre_int32(((*((*ucd_record)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_records[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
					}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*tempVar))
			}()))).other_case))))))
			_ = _pcre_ord2utf(pcre_uint32(c), &buff[0])
			*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(uint8((*&buff[0])))/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8((*&buff[0]))) & int32(7)))))))
		}
		return p
	}
	if (int32((caseless)) != 0) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
		tempVar := (*cd).ctypes
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
	}()))))) & int32(2)) != int32(0)) {
		*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := (*cd).fcc
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
		}())))))/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := (*cd).fcc
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*tempVar))
		}()))))) & int32(7)))))))
	}
	return ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(int32(1))*unsafe.Sizeof(*p))))
}

// set_type_bits - transpiled function from  /root/Documents/pcre/pcre_study.c:722
/*************************************************
*     Set bits for a positive character type     *
*************************************************/ //
/* This function sets starting bits for a character type. In UTF-8 mode, we can
only do a direct setting for bytes less than 128, as otherwise there can be
confusion with bytes in the middle of UTF-8 characters. In a "traditional"
environment, the tables will only recognize ASCII characters anyway, but in at
least one Windows environment, some higher bytes bits were set in the tables.
So we deal with that case by considering the UTF-8 encoding.

Arguments:
  start_bits     the starting bitmap
  cbit type      the type of character wanted
  table_limit    32 for non-UTF-8; 16 for UTF-8
  cd             the block with char table pointers

Returns:         nothing
*/ //
//
func set_type_bits(start_bits *pcre_uint8, cbit_type int32, table_limit uint32, cd *compile_data) {
	var c pcre_uint32
	for c = pcre_uint32(int32(0)); c < pcre_uint32((table_limit)); c++ {
		*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := (*cd).cbits
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(cbit_type)))))))*unsafe.Sizeof(*tempVar))
		}()))))))))
	}
	if table_limit == uint32(int32(32)) {
		return
	}
	for c = pcre_uint32(int32(128)); c < pcre_uint32((uint32(int32(256)))); c++ {
		if (int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := (*cd).cbits
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
		}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0) {
			var buff []pcre_uchar = make([]pcre_uchar, 6, 6)
			_ = _pcre_ord2utf(pcre_uint32(c), &buff[0])
			*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(uint8((*&buff[0])))/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8((*&buff[0]))) & int32(7)))))))
		}
	}
}

// set_nottype_bits - transpiled function from  /root/Documents/pcre/pcre_study.c:764
/*************************************************
*     Set bits for a negative character type     *
*************************************************/ //
/* This function sets starting bits for a negative character type such as \D.
In UTF-8 mode, we can only do a direct setting for bytes less than 128, as
otherwise there can be confusion with bytes in the middle of UTF-8 characters.
Unlike in the positive case, where we can set appropriate starting bits for
specific high-valued UTF-8 characters, in this case we have to set the bits for
all high-valued characters. The lowest is 0xc2, but we overkill by starting at
0xc0 (192) for simplicity.

Arguments:
  start_bits     the starting bitmap
  cbit type      the type of character wanted
  table_limit    32 for non-UTF-8; 16 for UTF-8
  cd             the block with char table pointers

Returns:         nothing
*/ //
//
func set_nottype_bits(start_bits *pcre_uint8, cbit_type int32, table_limit uint32, cd *compile_data) {
	var c pcre_uint32
	for c = pcre_uint32(int32(0)); c < pcre_uint32((table_limit)); c++ {
		*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((^uint8(int32(uint8((pcre_uint8(*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := (*cd).cbits
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c+pcre_uint32((uint32(cbit_type)))))))*unsafe.Sizeof(*tempVar))
		}())))))))))
	}
	if table_limit != uint32(int32(32)) {
		for c = pcre_uint32(int32(24)); c < pcre_uint32((uint32(int32(32)))); c++ {
			*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*start_bits)))) = pcre_uint8(int32(255))
		}
	}
}

// set_start_bits - transpiled function from  /root/Documents/pcre/pcre_study.c:801
/*************************************************
*          Create bitmap of starting bytes       *
*************************************************/ //
/* This function scans a compiled unanchored expression recursively and
attempts to build a bitmap of the set of possible starting bytes. As time goes
by, we may be able to get more clever at doing this. The SSB_CONTINUE return is
useful for parenthesized groups in patterns such as (a*)b where the group
provides some optional starting bytes but scanning must continue at the outer
level to find at least one mandatory byte. At the outermost level, this
function fails unless the result is SSB_DONE.

Arguments:
  code         points to an expression
  start_bits   points to a 32-byte table, initialized to 0
  utf          TRUE if in UTF-8 / UTF-16 / UTF-32 mode
  cd           the block with char table pointers

Returns:       SSB_FAIL     => Failed to find any starting bytes
               SSB_DONE     => Found mandatory starting bytes
               SSB_CONTINUE => Found optional starting bytes
               SSB_UNKNOWN  => Hit an unrecognized opcode
*/ //
/* Loop for items in this branch */ //
/* If we reach something we don't understand, it means a new opcode has
   been created that hasn't been added to this code. Hopefully this problem
   will be discovered during testing. */ //
/* Fail for a valid opcode that implies no starting bits. */ //
/* A "real" property test implies no starting bits, but the fake property
   PT_CLIST identifies a list of characters. These lists are short, as they
   are used for characters with more than one "other case", so there is no
   point in recognizing them for OP_NOTPROP. */ //
/* We can ignore word boundary tests. */ //
/* If we hit a bracket or a positive lookahead assertion, recurse to set
   bits from within the subpattern. If it can't find anything, we have to
   give up. If it finds some mandatory character(s), we are done for this
   branch. Otherwise, carry on scanning after the subpattern. */ //
/* If we hit ALT or KET, it means we haven't found anything mandatory in
   this branch, though we might have found something optional. For ALT, we
   continue with the next alternative, but we have to arrange that the final
   result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,
   return SSB_CONTINUE: if this is the top level, that indicates failure,
   but after a nested subpattern, it causes scanning to continue. */ //
/* Skip over callout */ //
/* Skip over lookbehind and negative lookahead assertions */ //
/* BRAZERO does the bracket, but carries on. */ //
/* =========================================================================
    See the comment at the head of this function concerning the next line,
    which was an old fudge for the benefit of OS/2.
    dummy = 1;
========================================================================= */ //
/* SKIPZERO skips the bracket. */ //
/* Single-char * or ? sets the bit and tries the next item */ //
/* Single-char upto sets the bit and tries the next */ //
/* At least one single char sets the bit and stops */ //
/* Fall through */ //
/* Fall through */ //
/* Special spacing and line-terminating items. These recognize specific
   lists of characters. The difference between VSPACE and ANYNL is that the
   latter can match the two-character CRLF sequence, but that is not
   relevant for finding the first character, so their code here is
   identical. */ //
/* For U+00A0 */ //
/* For U+1680, U+180E */ //
/* For U+2000 - U+200A, U+202F, U+205F */ //
/* For U+3000 */ //
/* For U+0085 */ //
/* For U+2028, U+2029 */ //
/* Single character types set the bits and stop. Note that if PCRE_UCP
   is set, we do not see these op codes because \d etc are converted to
   properties. Therefore, these apply in the case when only characters less
   than 256 are recognized to match the types. */ //
/* The cbit_space table has vertical tab as whitespace; we no longer
   have to play fancy tricks because Perl added VT to its whitespace at
   release 5.18. PCRE added it at release 8.34. */ //
/* One or more character type fudges the pointer and restarts, knowing
   it will hit a single character type and stop there. */ //
/* Zero or more repeats of character types set the bits and then
   try again. */ //
/* Fall through */ //
/* For U+00A0 */ //
/* For U+1680, U+180E */ //
/* For U+2000 - U+200A, U+202F, U+205F */ //
/* For U+3000 */ //
/* For U+0085 */ //
/* For U+2028, U+2029 */ //
/* The cbit_space table has vertical tab as whitespace; we no longer
   have to play fancy tricks because Perl added VT to its whitespace at
   release 5.18. PCRE added it at release 8.34. */ //
/* Character class where all the information is in a bit map: set the
   bits and either carry on or not, according to the repeat count. If it was
   a negative class, and we are operating with UTF-8 characters, any byte
   with a value >= 0xc4 is a potentially valid starter because it starts a
   character with a value > 255. */ //
/* All bits are set. */ //
/* Fall through */ //
/* Bits for 0xc4 - 0xc8 */ //
/* Bits for 0xc9 - 0xff */ //
/* Fall through */ //
/* In UTF-8 mode, the bits in a bit map correspond to character
   values, not to byte values. However, the bit map we are constructing is
   for byte values. So we have to do a conversion for characters whose
   value is > 127. In fact, there are only two possible starting bytes for
   characters in the range 128 - 255. */ //
/* Set bit for this starter */ //
/* and then skip on to the */ //
/* next relevant character. */ //
/* In non-UTF-8 mode, the two bit maps are completely compatible. */ //
/* Advance past the bit map, and act on what follows. For a zero
   minimum repeat, continue; otherwise stop processing. */ //
/* End of bitmap class handling */ //
/* End of switch */ //
/* End of try_next loop */ //
/* Advance to next branch */ //
//
func set_start_bits(code *pcre_uchar, start_bits *pcre_uint8, utf BOOL, cd *compile_data) int32 {
	var c pcre_uint32
	var yield int32 = SSB_DONE
	var table_limit int32 = func() int32 {
		if int32((BOOL(utf))) != 0 {
			return int32(16)
		} else {
			return int32(32)
		}
	}()
	for {
		var try_next BOOL = BOOL((int32(1)))
		var tcode *pcre_uchar = ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(int32(1))*unsafe.Sizeof(*code))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
		}()))
		if (((int32(uint8((*code))) == OP_CBRA) || (int32(uint8((*code))) == OP_SCBRA)) || (int32(uint8((*code))) == OP_CBRAPOS)) || (int32(uint8((*code))) == OP_SCBRAPOS) {
			tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))
		}
		for int32((try_next)) != 0 {
			var rc int32
			switch int32(uint8((pcre_uchar(*tcode)))) {
			default:
				{
					return SSB_UNKNOWN
				}
			case OP_ACCEPT:
				fallthrough
			case OP_ASSERT_ACCEPT:
				fallthrough
			case OP_ALLANY:
				fallthrough
			case OP_ANY:
				fallthrough
			case OP_ANYBYTE:
				fallthrough
			case OP_CIRC:
				fallthrough
			case OP_CIRCM:
				fallthrough
			case OP_CLOSE:
				fallthrough
			case OP_COMMIT:
				fallthrough
			case OP_COND:
				fallthrough
			case OP_CREF:
				fallthrough
			case OP_DEF:
				fallthrough
			case OP_DNCREF:
				fallthrough
			case OP_DNREF:
				fallthrough
			case OP_DNREFI:
				fallthrough
			case OP_DNRREF:
				fallthrough
			case OP_DOLL:
				fallthrough
			case OP_DOLLM:
				fallthrough
			case OP_END:
				fallthrough
			case OP_EOD:
				fallthrough
			case OP_EODN:
				fallthrough
			case OP_EXTUNI:
				fallthrough
			case OP_FAIL:
				fallthrough
			case OP_MARK:
				fallthrough
			case OP_NOT:
				fallthrough
			case OP_NOTEXACT:
				fallthrough
			case OP_NOTEXACTI:
				fallthrough
			case OP_NOTI:
				fallthrough
			case OP_NOTMINPLUS:
				fallthrough
			case OP_NOTMINPLUSI:
				fallthrough
			case OP_NOTMINQUERY:
				fallthrough
			case OP_NOTMINQUERYI:
				fallthrough
			case OP_NOTMINSTAR:
				fallthrough
			case OP_NOTMINSTARI:
				fallthrough
			case OP_NOTMINUPTO:
				fallthrough
			case OP_NOTMINUPTOI:
				fallthrough
			case OP_NOTPLUS:
				fallthrough
			case OP_NOTPLUSI:
				fallthrough
			case OP_NOTPOSPLUS:
				fallthrough
			case OP_NOTPOSPLUSI:
				fallthrough
			case OP_NOTPOSQUERY:
				fallthrough
			case OP_NOTPOSQUERYI:
				fallthrough
			case OP_NOTPOSSTAR:
				fallthrough
			case OP_NOTPOSSTARI:
				fallthrough
			case OP_NOTPOSUPTO:
				fallthrough
			case OP_NOTPOSUPTOI:
				fallthrough
			case OP_NOTPROP:
				fallthrough
			case OP_NOTQUERY:
				fallthrough
			case OP_NOTQUERYI:
				fallthrough
			case OP_NOTSTAR:
				fallthrough
			case OP_NOTSTARI:
				fallthrough
			case OP_NOTUPTO:
				fallthrough
			case OP_NOTUPTOI:
				fallthrough
			case OP_NOT_HSPACE:
				fallthrough
			case OP_NOT_VSPACE:
				fallthrough
			case OP_PRUNE:
				fallthrough
			case OP_PRUNE_ARG:
				fallthrough
			case OP_RECURSE:
				fallthrough
			case OP_REF:
				fallthrough
			case OP_REFI:
				fallthrough
			case OP_REVERSE:
				fallthrough
			case OP_RREF:
				fallthrough
			case OP_SCOND:
				fallthrough
			case OP_SET_SOM:
				fallthrough
			case OP_SKIP:
				fallthrough
			case OP_SKIP_ARG:
				fallthrough
			case OP_SOD:
				fallthrough
			case OP_SOM:
				fallthrough
			case OP_THEN:
				fallthrough
			case OP_THEN_ARG:
				{
					return SSB_FAIL
				}
			case OP_PROP:
				{
					if int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode))))))) != int32(9) {
						return SSB_FAIL
					}
					{
						var p *pcre_uint32 = ((*pcre_uint32)(func() unsafe.Pointer {
							tempVar := &_pcre_ucd_caseless_sets[0]
							return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))))))*unsafe.Sizeof(*tempVar))
						}()))
						for (func() pcre_uint32 {
							tempVar := *func() *pcre_uint32 {
								defer func() {
									p = ((*pcre_uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
								}()
								return p
							}()
							c = tempVar
							return tempVar
						}()) < pcre_uint32((uint32(4294967295))) {
							if int32((BOOL(utf))) != 0 {
								var buff []pcre_uchar = make([]pcre_uchar, 6, 6)
								_ = _pcre_ord2utf(pcre_uint32(c), &buff[0])
								c = pcre_uint32((uint32(uint8((*&buff[0])))))
							}
							if c > pcre_uint32((uint32(int32(255)))) {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(255)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(255) & int32(7)))))))
							} else {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7)))))))))))
							}
						}
					}
					try_next = BOOL((int32(0)))
				}
			case OP_WORD_BOUNDARY:
				fallthrough
			case OP_NOT_WORD_BOUNDARY:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
				}
			case OP_BRA:
				fallthrough
			case OP_SBRA:
				fallthrough
			case OP_CBRA:
				fallthrough
			case OP_SCBRA:
				fallthrough
			case OP_BRAPOS:
				fallthrough
			case OP_SBRAPOS:
				fallthrough
			case OP_CBRAPOS:
				fallthrough
			case OP_SCBRAPOS:
				fallthrough
			case OP_ONCE:
				fallthrough
			case OP_ONCE_NC:
				fallthrough
			case OP_ASSERT:
				{
					rc = set_start_bits(tcode, start_bits, BOOL(utf), cd)
					if (rc == SSB_FAIL) || (rc == SSB_UNKNOWN) {
						return rc
					}
					if rc == SSB_DONE {
						try_next = BOOL((int32(0)))
					} else {
						for {
							tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode))))))))))*unsafe.Sizeof(*tcode))))
							if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*tcode))) == OP_ALT)])) != 0 {
								break
							}
						}
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))
					}
				}
			case OP_ALT:
				{
					yield = SSB_CONTINUE
					try_next = BOOL((int32(0)))
				}
			case OP_KET:
				fallthrough
			case OP_KETRMAX:
				fallthrough
			case OP_KETRMIN:
				fallthrough
			case OP_KETRPOS:
				{
					return SSB_CONTINUE
				}
			case OP_CALLOUT:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(2)+(int32(2)*int32(2))))*unsafe.Sizeof(*tcode))))
				}
			case OP_ASSERT_NOT:
				fallthrough
			case OP_ASSERTBACK:
				fallthrough
			case OP_ASSERTBACK_NOT:
				{
					for {
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode))))))))))*unsafe.Sizeof(*tcode))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*tcode))) == OP_ALT)])) != 0 {
							break
						}
					}
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))
				}
			case OP_BRAZERO:
				fallthrough
			case OP_BRAMINZERO:
				fallthrough
			case OP_BRAPOSZERO:
				{
					rc = set_start_bits(func() *pcre_uchar {
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
						return tcode
					}(), start_bits, BOOL(utf), cd)
					if (rc == SSB_FAIL) || (rc == SSB_UNKNOWN) {
						return rc
					}
					for {
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode))))))))))*unsafe.Sizeof(*tcode))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*tcode))) == OP_ALT)])) != 0 {
							break
						}
					}
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))
				}
			case OP_SKIPZERO:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
					for {
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode))))))))))*unsafe.Sizeof(*tcode))))
						if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*tcode))) == OP_ALT)])) != 0 {
							break
						}
					}
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))
				}
			case OP_STAR:
				fallthrough
			case OP_MINSTAR:
				fallthrough
			case OP_POSSTAR:
				fallthrough
			case OP_QUERY:
				fallthrough
			case OP_MINQUERY:
				fallthrough
			case OP_POSQUERY:
				{
					tcode = set_table_bit(start_bits, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode)))), BOOL((int32(0))), cd, BOOL(utf))
				}
			case OP_STARI:
				fallthrough
			case OP_MINSTARI:
				fallthrough
			case OP_POSSTARI:
				fallthrough
			case OP_QUERYI:
				fallthrough
			case OP_MINQUERYI:
				fallthrough
			case OP_POSQUERYI:
				{
					tcode = set_table_bit(start_bits, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode)))), BOOL((int32(1))), cd, BOOL(utf))
				}
			case OP_UPTO:
				fallthrough
			case OP_MINUPTO:
				fallthrough
			case OP_POSUPTO:
				{
					tcode = set_table_bit(start_bits, ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}())), BOOL((int32(0))), cd, BOOL(utf))
				}
			case OP_UPTOI:
				fallthrough
			case OP_MINUPTOI:
				fallthrough
			case OP_POSUPTOI:
				{
					tcode = set_table_bit(start_bits, ((*pcre_uchar)(func() unsafe.Pointer {
						tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode))))
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
					}())), BOOL((int32(1))), cd, BOOL(utf))
				}
			case OP_EXACT:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))
				}
				fallthrough
			case OP_CHAR:
				fallthrough
			case OP_PLUS:
				fallthrough
			case OP_MINPLUS:
				fallthrough
			case OP_POSPLUS:
				{
					_ = set_table_bit(start_bits, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode)))), BOOL((int32(0))), cd, BOOL(utf))
					try_next = BOOL((int32(0)))
				}
			case OP_EXACTI:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))
				}
				fallthrough
			case OP_CHARI:
				fallthrough
			case OP_PLUSI:
				fallthrough
			case OP_MINPLUSI:
				fallthrough
			case OP_POSPLUSI:
				{
					_ = set_table_bit(start_bits, ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode)))), BOOL((int32(1))), cd, BOOL(utf))
					try_next = BOOL((int32(0)))
				}
			case OP_HSPACE:
				{
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\t'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\t' & byte(int32(7))))))))
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32((' '/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((' ' & byte(int32(7))))))))
					if int32((BOOL(utf))) != 0 {
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(194)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(194) & int32(7)))))))
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(225)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(225) & int32(7)))))))
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(226)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(226) & int32(7)))))))
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(227)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(227) & int32(7)))))))
					} else {
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(160)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(160) & int32(7)))))))
					}
					try_next = BOOL((int32(0)))
				}
			case OP_ANYNL:
				fallthrough
			case OP_VSPACE:
				{
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\n'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\n' & byte(int32(7))))))))
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\v'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\v' & byte(int32(7))))))))
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\f'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\f' & byte(int32(7))))))))
					*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\r'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\r' & byte(int32(7))))))))
					if int32((BOOL(utf))) != 0 {
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(194)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(194) & int32(7)))))))
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(226)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(226) & int32(7)))))))
					} else {
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(uint8('\u0085'))/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8('\u0085')) & int32(7)))))))
					}
					try_next = BOOL((int32(0)))
				}
			case OP_NOT_DIGIT:
				{
					set_nottype_bits(start_bits, int32(64), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_DIGIT:
				{
					set_type_bits(start_bits, int32(64), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_NOT_WHITESPACE:
				{
					set_nottype_bits(start_bits, int32(0), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_WHITESPACE:
				{
					set_type_bits(start_bits, int32(0), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_NOT_WORDCHAR:
				{
					set_nottype_bits(start_bits, int32(160), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_WORDCHAR:
				{
					set_type_bits(start_bits, int32(160), uint32(table_limit), cd)
					try_next = BOOL((int32(0)))
				}
			case OP_TYPEPLUS:
				fallthrough
			case OP_TYPEMINPLUS:
				fallthrough
			case OP_TYPEPOSPLUS:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
				}
			case OP_TYPEEXACT:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))
				}
			case OP_TYPEUPTO:
				fallthrough
			case OP_TYPEMINUPTO:
				fallthrough
			case OP_TYPEPOSUPTO:
				{
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))
				}
				fallthrough
			case OP_TYPESTAR:
				fallthrough
			case OP_TYPEMINSTAR:
				fallthrough
			case OP_TYPEPOSSTAR:
				fallthrough
			case OP_TYPEQUERY:
				fallthrough
			case OP_TYPEMINQUERY:
				fallthrough
			case OP_TYPEPOSQUERY:
				{
					switch int32(uint8((pcre_uchar(*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode)))))))) {
					default:
						fallthrough
					case OP_ANY:
						fallthrough
					case OP_ALLANY:
						{
							return SSB_FAIL
						}
					case OP_HSPACE:
						{
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\t'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\t' & byte(int32(7))))))))
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32((' '/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((' ' & byte(int32(7))))))))
							if int32((BOOL(utf))) != 0 {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(194)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(194) & int32(7)))))))
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(225)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(225) & int32(7)))))))
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(226)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(226) & int32(7)))))))
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(227)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(227) & int32(7)))))))
							} else {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(160)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(160) & int32(7)))))))
							}
						}
					case OP_ANYNL:
						fallthrough
					case OP_VSPACE:
						{
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\n'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\n' & byte(int32(7))))))))
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\v'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\v' & byte(int32(7))))))))
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\f'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\f' & byte(int32(7))))))))
							*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(('\r'/byte(int32(8)))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64(('\r' & byte(int32(7))))))))
							if int32((BOOL(utf))) != 0 {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(194)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(194) & int32(7)))))))
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(226)/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(226) & int32(7)))))))
							} else {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((int32(uint8('\u0085'))/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((int32(uint8('\u0085')) & int32(7)))))))
							}
						}
					case OP_NOT_DIGIT:
						{
							set_nottype_bits(start_bits, int32(64), uint32(table_limit), cd)
						}
					case OP_DIGIT:
						{
							set_type_bits(start_bits, int32(64), uint32(table_limit), cd)
						}
					case OP_NOT_WHITESPACE:
						{
							set_nottype_bits(start_bits, int32(0), uint32(table_limit), cd)
						}
					case OP_WHITESPACE:
						{
							set_type_bits(start_bits, int32(0), uint32(table_limit), cd)
						}
					case OP_NOT_WORDCHAR:
						{
							set_nottype_bits(start_bits, int32(160), uint32(table_limit), cd)
						}
					case OP_WORDCHAR:
						{
							set_type_bits(start_bits, int32(160), uint32(table_limit), cd)
							break
						}
					}
					tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(2))*unsafe.Sizeof(*tcode))))
				}
			case OP_XCLASS:
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))))) & int32(4)) != int32(0) {
						return SSB_FAIL
					}
					if ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))))) & int32(2)) == int32(0)) && ((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))))) & int32(1)) != int32(0)) {
						return SSB_FAIL
					}
				}
				fallthrough
			case OP_NCLASS:
				{
					if int32((BOOL(utf))) != 0 {
						*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(24))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8(int32(240))))
						noarch.Memset(unsafe.Pointer(((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(25))*unsafe.Sizeof(*start_bits))))), int32(255), int32(uint32(int32(7))))
					}
				}
				fallthrough
			case OP_CLASS:
				{
					var map_ *pcre_uint8
					map_ = nil
					if int32(uint8((*tcode))) == OP_XCLASS {
						if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+int32(2)))*unsafe.Sizeof(*tcode))))))) & int32(2)) != int32(0) {
							map_ = (*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(func() unsafe.Pointer {
								tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
									tempVar := ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32(1))*unsafe.Sizeof(*tcode))))
									return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(2))*unsafe.Sizeof(*tempVar))
								}()))
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
							}()))))
						}
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode))))))))))*unsafe.Sizeof(*tcode))))
					} else {
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
						map_ = (*pcre_uint8)(unsafe.Pointer(tcode))
						tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*tcode))))
					}
					if map_ != nil {
						if int32((BOOL(utf))) != 0 {
							for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(16)))); c++ {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(map_)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*map_))))))))))
							}
							for c = pcre_uint32(int32(128)); c < pcre_uint32((uint32(int32(256)))); c++ {
								if (int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(map_)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*map_))))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0) {
									var d int32 = int32(uint32(((c >> uint64(int32(6))) | pcre_uint32((uint32(int32(192)))))))
									*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)((d/int32(8)))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8((int32(1) << uint64((d & int32(7)))))))
									c = (((c & pcre_uint32((uint32(int32(192))))) + pcre_uint32((uint32(int32(64))))) - pcre_uint32((uint32(int32(1)))))
								}
							}
						} else {
							for c = pcre_uint32(int32(0)); c < pcre_uint32((uint32(int32(32)))); c++ {
								*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(start_bits)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*start_bits)))) |= pcre_uint8((uint8(int32(uint8((*((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(map_)) + (uintptr)(int32(uint32((c))))*unsafe.Sizeof(*map_))))))))))
							}
						}
					}
					switch int32(uint8((pcre_uchar(*tcode)))) {
					case OP_CRSTAR:
						fallthrough
					case OP_CRMINSTAR:
						fallthrough
					case OP_CRQUERY:
						fallthrough
					case OP_CRMINQUERY:
						fallthrough
					case OP_CRPOSSTAR:
						fallthrough
					case OP_CRPOSQUERY:
						{
							tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)(1)*unsafe.Sizeof(*tcode))))
						}
					case OP_CRRANGE:
						fallthrough
					case OP_CRMINRANGE:
						fallthrough
					case OP_CRPOSRANGE:
						{
							if uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)(int32(1))*unsafe.Sizeof(*(tcode)))))))) << uint64(int32(8))) | int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((tcode))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(tcode)))))))))) == uint32(int32(0)) {
								tcode = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(tcode)) + (uintptr)((int32(1)+(int32(2)*int32(2))))*unsafe.Sizeof(*tcode))))
							} else {
								try_next = BOOL((int32(0)))
							}
						}
					default:
						{
							try_next = BOOL((int32(0)))
							break
						}
					}
					break
				}
			}
		}
		code = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(code)) + (uintptr)(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)(int32(1))*unsafe.Sizeof(*(code))))))))<<uint64(int32(8)))|int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer((code))) + (uintptr)((int32(1)+int32(1)))*unsafe.Sizeof(*(code))))))))))*unsafe.Sizeof(*code))))
		if noarch.NotInt32((map[bool]int32{false: 0, true: 1}[(int32(uint8((*code))) == OP_ALT)])) != 0 {
			break
		}
	}
	return yield
}

// pcre_study - transpiled function from  /root/Documents/pcre/pcre_study.c:1451
/*************************************************
*          Study a compiled expression           *
*************************************************/ //
/* This function is handed a compiled expression that it must study to produce
information that will speed up the matching. It returns a pcre[16]_extra block
which then gets handed back to pcre_exec().

Arguments:
  re        points to the compiled expression
  options   contains option bits
  errorptr  points to where to place error messages;
            set NULL unless error

Returns:    pointer to a pcre[16]_extra block, with study_data filled in and
              the appropriate flags set;
            NULL on error or if no optimization possible
*/ //
/* For an anchored pattern, or an unanchored pattern that has a first char, or
a multiline pattern that matches only at "line starts", there is no point in
seeking a list of starting bytes. */ //
/* Set the character tables in the block that is passed around */ //
/* See if we can find a fixed set of initial characters for the pattern. */ //
/* Find the minimum length of subject string. */ //
/* If a set of starting bytes has been identified, or if the minimum length is
greater than zero, or if JIT optimization has been requested, or if
PCRE_STUDY_EXTRA_NEEDED is set, get a pcre[16]_extra block and a
pcre_study_data block. The study data is put in the latter, which is pointed to
by the former, which may also get additional data set later by the calling
program. At the moment, the size of pcre_study_data is fixed. We nevertheless
save it in a field for returning via the pcre_fullinfo() function so that if it
becomes variable in the future, we don't have to change that code. */ //
/* Set the start bits always, to avoid unset memory errors if the
study data is written to a file, but set the flag only if any of the bits
are set, to save time looking when none are. */ //
/* Always set the minlength value in the block, because the JIT compiler
makes use of it. However, don't set the bit unless the length is greater than
zero - the interpretive pcre_exec() and pcre_dfa_exec() needn't waste time
checking the zero case. */ //
/* If JIT support was compiled and requested, attempt the JIT compilation.
If no starting bytes were found, and the minimum length is zero, and JIT
compilation fails, abandon the extra block and return NULL, unless
PCRE_STUDY_EXTRA_NEEDED is set. */ //
//
func pcre_study(external_re *pcre, options int32, errorptr **byte) *pcre_extra {
	var min int32
	var count int32 = int32(0)
	var bits_set BOOL = BOOL((int32(0)))
	var start_bits []pcre_uint8 = make([]pcre_uint8, 32, 32)
	var extra *pcre_extra = nil
	var study *pcre_study_data
	var tables *pcre_uint8
	var code *pcre_uchar
	var compile_block compile_data
	var re *real_pcre = (*real_pcre)(unsafe.Pointer(external_re))
	*errorptr = nil
	if (re == nil) || (uint32((pcre_uint32((*re).magic_number))) != uint32(1346589253)) {
		*errorptr = (&[]byte("argument is not a compiled regular expression\x00")[0])
		return nil
	}
	if (pcre_uint32((*re).flags) & pcre_uint32((uint32(int32(1))))) == pcre_uint32((uint32(int32(0)))) {
		*errorptr = (&[]byte("argument not compiled in 8 bit mode\x00")[0])
		return nil
	}
	if (options & ^(((int32(1) | int32(2)) | int32(4)) | int32(8))) != int32(0) {
		*errorptr = (&[]byte("unknown or incorrect option bit(s) set\x00")[0])
		return nil
	}
	code = ((*pcre_uchar)(func() unsafe.Pointer {
		tempVar := ((*pcre_uchar)(func() unsafe.Pointer {
			tempVar := (*pcre_uchar)(unsafe.Pointer(re))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((pcre_uint16((*re).name_table_offset)))))*unsafe.Sizeof(*tempVar))
		}()))
		return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint16((pcre_uint16((*re).name_count))))*int32(uint16((pcre_uint16((*re).name_entry_size))))))*unsafe.Sizeof(*tempVar))
	}()))
	if ((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0))))) && ((pcre_uint32((*re).flags) & pcre_uint32((uint32((int32(16) | int32(256)))))) == pcre_uint32((uint32(int32(0))))) {
		var rc int32
		tables = (*re).tables
		if tables == nil {
			_ = pcre_fullinfo(external_re, nil, int32(11), unsafe.Pointer((&tables)))
		}
		compile_block.lcc = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(0))*unsafe.Sizeof(*tables))))
		compile_block.fcc = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(256))*unsafe.Sizeof(*tables))))
		compile_block.cbits = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)(int32(512))*unsafe.Sizeof(*tables))))
		compile_block.ctypes = ((*pcre_uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(tables)) + (uintptr)((int32(512)+int32(320)))*unsafe.Sizeof(*tables))))
		noarch.Memset(unsafe.Pointer(&start_bits[0]), int32(0), int32((uint32(int32(32)) * 1)))
		rc = set_start_bits(code, &start_bits[0], BOOL((map[bool]int32{false: 0, true: 1}[((pcre_uint32((*re).options) & pcre_uint32((uint32(int32(2048))))) != pcre_uint32((uint32(int32(0)))))])), &compile_block)
		bits_set = BOOL((map[bool]int32{false: 0, true: 1}[(rc == SSB_DONE)]))
		if rc == SSB_UNKNOWN {
			*errorptr = (&[]byte("internal error: opcode not recognized\x00")[0])
			return nil
		}
	}
	switch func() int32 {
		min = find_minlength(re, code, code, int32(uint32((pcre_uint32((*re).options)))), nil, &count)
		return min
	}() {
	case -int32(2):
		{
			*errorptr = (&[]byte("internal error: missing capturing bracket\x00")[0])
			return nil
		}
	case -int32(3):
		{
			*errorptr = (&[]byte("internal error: opcode not recognized\x00")[0])
			return nil
		}
	default:
		{
			break
		}
	}
	if ((int32((bits_set)) != 0) || (min > int32(0))) || ((options & int32(8)) != int32(0)) {
		extra = (*pcre_extra)(pcre_malloc(size_t((64 + 44))))
		if extra == nil {
			*errorptr = (&[]byte("failed to get memory\x00")[0])
			return nil
		}
		study = (*pcre_study_data)(unsafe.Pointer(((*byte)(func() unsafe.Pointer {
			tempVar := (*byte)(unsafe.Pointer(extra))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(64))*unsafe.Sizeof(*tempVar))
		}()))))
		(*extra).flags = uint32(int32(1))
		(*extra).study_data = unsafe.Pointer(study)
		(*study).size = pcre_uint32((44))
		(*study).flags = pcre_uint32(int32(0))
		if int32((BOOL(bits_set))) != 0 {
			(*study).flags |= pcre_uint32((uint32(int32(1))))
			noarch.Memcpy(unsafe.Pointer(&(*study).start_bits[0]), unsafe.Pointer(&start_bits[0]), int32(32))
		} else {
			noarch.Memset(unsafe.Pointer(&(*study).start_bits[0]), int32(0), int32((uint32(int32(32)) * 1)))
		}
		if min > int32(0) {
			(*study).flags |= pcre_uint32((uint32(int32(2))))
			(*study).minlength = pcre_uint32((uint32(min)))
		} else {
			(*study).minlength = pcre_uint32(int32(0))
		}
	}
	return extra
}

// pcre_free_study - transpiled function from  /root/Documents/pcre/pcre_study.c:1666
/*************************************************
*          Free the study data                   *
*************************************************/ //
/* This function frees the memory that was obtained by pcre_study().

Argument:   a pointer to the pcre[16]_extra block
Returns:    nothing
*/ //
//
func pcre_free_study(extra *pcre_extra) {
	if extra == nil {
		return
	}
	pcre_free(unsafe.Pointer(extra))
}

var _pcre_OP_lengths []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8((int32(2) + int32(2))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8((uint32(int32(1)) + (uint32(int32(32)) / 1))), pcre_uint8((uint32(int32(1)) + (uint32(int32(32)) / 1))), pcre_uint8(int32(0)), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(2) + (int32(2) * int32(2)))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(((int32(1) + int32(2)) + int32(2))), pcre_uint8(((int32(1) + int32(2)) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8(((int32(1) + int32(2)) + int32(2))), pcre_uint8(((int32(1) + int32(2)) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8((int32(1) + int32(2))), pcre_uint8((int32(1) + (int32(2) * int32(2)))), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8((int32(1) + int32(2))), pcre_uint8(int32(1))}
var _pcre_hspace_list []pcre_uint32 = []pcre_uint32{pcre_uint32('\t'), pcre_uint32(' '), pcre_uint32((uint8('\u00a0'))), pcre_uint32(int32(5760)), pcre_uint32(int32(6158)), pcre_uint32(int32(8192)), pcre_uint32(int32(8193)), pcre_uint32(int32(8194)), pcre_uint32(int32(8195)), pcre_uint32(int32(8196)), pcre_uint32(int32(8197)), pcre_uint32(int32(8198)), pcre_uint32(int32(8199)), pcre_uint32(int32(8200)), pcre_uint32(int32(8201)), pcre_uint32(int32(8202)), pcre_uint32(int32(8239)), pcre_uint32(int32(8287)), pcre_uint32(int32(12288)), 4294967295}
var _pcre_vspace_list []pcre_uint32 = []pcre_uint32{pcre_uint32('\n'), pcre_uint32('\v'), pcre_uint32('\f'), pcre_uint32('\r'), pcre_uint32((uint8('\u0085'))), pcre_uint32(int32(8232)), pcre_uint32(int32(8233)), 4294967295}
var _pcre_utf8_table1 []int32 = []int32{int32(127), int32(2047), int32(65535), int32(2097151), int32(67108863), int32(2147483647)}
var _pcre_utf8_table1_size int32 = int32((24 / 4))
var _pcre_utf8_table2 []int32 = []int32{int32(0), int32(192), int32(224), int32(240), int32(248), int32(252)}
var _pcre_utf8_table3 []int32 = []int32{int32(255), int32(31), int32(15), int32(7), int32(3), int32(1)}
var _pcre_utf8_table4 []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(3)), pcre_uint8(int32(4)), pcre_uint8(int32(4)), pcre_uint8(int32(4)), pcre_uint8(int32(4)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5)), pcre_uint8(int32(5))}
var _pcre_ucp_gentype []pcre_uint32 = []pcre_uint32{pcre_uint32(ucp_C), pcre_uint32(ucp_C), pcre_uint32(ucp_C), pcre_uint32(ucp_C), pcre_uint32(ucp_C), pcre_uint32(ucp_L), pcre_uint32(ucp_L), pcre_uint32(ucp_L), pcre_uint32(ucp_L), pcre_uint32(ucp_L), pcre_uint32(ucp_M), pcre_uint32(ucp_M), pcre_uint32(ucp_M), pcre_uint32(ucp_N), pcre_uint32(ucp_N), pcre_uint32(ucp_N), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_P), pcre_uint32(ucp_S), pcre_uint32(ucp_S), pcre_uint32(ucp_S), pcre_uint32(ucp_S), pcre_uint32(ucp_Z), pcre_uint32(ucp_Z), pcre_uint32(ucp_Z)}
var _pcre_ucp_gbtable []pcre_uint32 = []pcre_uint32{pcre_uint32((int32(1) << uint64(ucp_gbLF))), pcre_uint32(int32(0)), pcre_uint32(int32(0)), pcre_uint32(((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark)))), pcre_uint32((((((((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbPrepend))) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbL))) | (int32(1) << uint64(ucp_gbV))) | (int32(1) << uint64(ucp_gbT))) | (int32(1) << uint64(ucp_gbLV))) | (int32(1) << uint64(ucp_gbLVT))) | (int32(1) << uint64(ucp_gbOther)))), pcre_uint32(((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark)))), pcre_uint32(((((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbL))) | (int32(1) << uint64(ucp_gbV))) | (int32(1) << uint64(ucp_gbLV))) | (int32(1) << uint64(ucp_gbLVT)))), pcre_uint32(((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbV))) | (int32(1) << uint64(ucp_gbT)))), pcre_uint32((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbT)))), pcre_uint32(((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbV))) | (int32(1) << uint64(ucp_gbT)))), pcre_uint32((((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))) | (int32(1) << uint64(ucp_gbT)))), pcre_uint32((int32(1) << uint64(ucp_gbRegionalIndicator))), pcre_uint32(((int32(1) << uint64(ucp_gbExtend)) | (int32(1) << uint64(ucp_gbSpacingMark))))}
var _pcre_utt_names []byte = *(*[]byte)(unsafe.Pointer(noarch.UnsafeSliceToSlice([]byte("Any\x00Arabic\x00Armenian\x00Avestan\x00Balinese\x00Bamum\x00Bassa_Vah\x00Batak\x00Bengali\x00Bopomofo\x00Brahmi\x00Braille\x00Buginese\x00Buhid\x00C\x00Canadian_Aboriginal\x00Carian\x00Caucasian_Albanian\x00Cc\x00Cf\x00Chakma\x00Cham\x00Cherokee\x00Cn\x00Co\x00Common\x00Coptic\x00Cs\x00Cuneiform\x00Cypriot\x00Cyrillic\x00Deseret\x00Devanagari\x00Duployan\x00Egyptian_Hieroglyphs\x00Elbasan\x00Ethiopic\x00Georgian\x00Glagolitic\x00Gothic\x00Grantha\x00Greek\x00Gujarati\x00Gurmukhi\x00Han\x00Hangul\x00Hanunoo\x00Hebrew\x00Hiragana\x00Imperial_Aramaic\x00Inherited\x00Inscriptional_Pahlavi\x00Inscriptional_Parthian\x00Javanese\x00Kaithi\x00Kannada\x00Katakana\x00Kayah_Li\x00Kharoshthi\x00Khmer\x00Khojki\x00Khudawadi\x00L\x00L&\x00Lao\x00Latin\x00Lepcha\x00Limbu\x00Linear_A\x00Linear_B\x00Lisu\x00Ll\x00Lm\x00Lo\x00Lt\x00Lu\x00Lycian\x00Lydian\x00M\x00Mahajani\x00Malayalam\x00Mandaic\x00Manichaean\x00Mc\x00Me\x00Meetei_Mayek\x00Mende_Kikakui\x00Meroitic_Cursive\x00Meroitic_Hieroglyphs\x00Miao\x00Mn\x00Modi\x00Mongolian\x00Mro\x00Myanmar\x00N\x00Nabataean\x00Nd\x00New_Tai_Lue\x00Nko\x00Nl\x00No\x00Ogham\x00Ol_Chiki\x00Old_Italic\x00Old_North_Arabian\x00Old_Permic\x00Old_Persian\x00Old_South_Arabian\x00Old_Turkic\x00Oriya\x00Osmanya\x00P\x00Pahawh_Hmong\x00Palmyrene\x00Pau_Cin_Hau\x00Pc\x00Pd\x00Pe\x00Pf\x00Phags_Pa\x00Phoenician\x00Pi\x00Po\x00Ps\x00Psalter_Pahlavi\x00Rejang\x00Runic\x00S\x00Samaritan\x00Saurashtra\x00Sc\x00Sharada\x00Shavian\x00Siddham\x00Sinhala\x00Sk\x00Sm\x00So\x00Sora_Sompeng\x00Sundanese\x00Syloti_Nagri\x00Syriac\x00Tagalog\x00Tagbanwa\x00Tai_Le\x00Tai_Tham\x00Tai_Viet\x00Takri\x00Tamil\x00Telugu\x00Thaana\x00Thai\x00Tibetan\x00Tifinagh\x00Tirhuta\x00Ugaritic\x00Vai\x00Warang_Citi\x00Xan\x00Xps\x00Xsp\x00Xuc\x00Xwd\x00Yi\x00Z\x00Zl\x00Zp\x00Zs\x00\x00"), 1, 1)))
var _pcre_utt []ucp_type_table = []ucp_type_table{ucp_type_table{pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(ucp_Arabic)}, ucp_type_table{pcre_uint16(int32(11)), pcre_uint16(int32(4)), pcre_uint16(ucp_Armenian)}, ucp_type_table{pcre_uint16(int32(20)), pcre_uint16(int32(4)), pcre_uint16(ucp_Avestan)}, ucp_type_table{pcre_uint16(int32(28)), pcre_uint16(int32(4)), pcre_uint16(ucp_Balinese)}, ucp_type_table{pcre_uint16(int32(37)), pcre_uint16(int32(4)), pcre_uint16(ucp_Bamum)}, ucp_type_table{pcre_uint16(int32(43)), pcre_uint16(int32(4)), pcre_uint16(ucp_Bassa_Vah)}, ucp_type_table{pcre_uint16(int32(53)), pcre_uint16(int32(4)), pcre_uint16(ucp_Batak)}, ucp_type_table{pcre_uint16(int32(59)), pcre_uint16(int32(4)), pcre_uint16(ucp_Bengali)}, ucp_type_table{pcre_uint16(int32(67)), pcre_uint16(int32(4)), pcre_uint16(ucp_Bopomofo)}, ucp_type_table{pcre_uint16(int32(76)), pcre_uint16(int32(4)), pcre_uint16(ucp_Brahmi)}, ucp_type_table{pcre_uint16(int32(83)), pcre_uint16(int32(4)), pcre_uint16(ucp_Braille)}, ucp_type_table{pcre_uint16(int32(91)), pcre_uint16(int32(4)), pcre_uint16(ucp_Buginese)}, ucp_type_table{pcre_uint16(int32(100)), pcre_uint16(int32(4)), pcre_uint16(ucp_Buhid)}, ucp_type_table{pcre_uint16(int32(106)), pcre_uint16(int32(2)), pcre_uint16(ucp_C)}, ucp_type_table{pcre_uint16(int32(108)), pcre_uint16(int32(4)), pcre_uint16(ucp_Canadian_Aboriginal)}, ucp_type_table{pcre_uint16(int32(128)), pcre_uint16(int32(4)), pcre_uint16(ucp_Carian)}, ucp_type_table{pcre_uint16(int32(135)), pcre_uint16(int32(4)), pcre_uint16(ucp_Caucasian_Albanian)}, ucp_type_table{pcre_uint16(int32(154)), pcre_uint16(int32(3)), pcre_uint16(ucp_Cc)}, ucp_type_table{pcre_uint16(int32(157)), pcre_uint16(int32(3)), pcre_uint16(ucp_Cf)}, ucp_type_table{pcre_uint16(int32(160)), pcre_uint16(int32(4)), pcre_uint16(ucp_Chakma)}, ucp_type_table{pcre_uint16(int32(167)), pcre_uint16(int32(4)), pcre_uint16(ucp_Cham)}, ucp_type_table{pcre_uint16(int32(172)), pcre_uint16(int32(4)), pcre_uint16(ucp_Cherokee)}, ucp_type_table{pcre_uint16(int32(181)), pcre_uint16(int32(3)), pcre_uint16(ucp_Cn)}, ucp_type_table{pcre_uint16(int32(184)), pcre_uint16(int32(3)), pcre_uint16(ucp_Co)}, ucp_type_table{pcre_uint16(int32(187)), pcre_uint16(int32(4)), pcre_uint16(ucp_Common)}, ucp_type_table{pcre_uint16(int32(194)), pcre_uint16(int32(4)), pcre_uint16(ucp_Coptic)}, ucp_type_table{pcre_uint16(int32(201)), pcre_uint16(int32(3)), pcre_uint16(ucp_Cs)}, ucp_type_table{pcre_uint16(int32(204)), pcre_uint16(int32(4)), pcre_uint16(ucp_Cuneiform)}, ucp_type_table{pcre_uint16(int32(214)), pcre_uint16(int32(4)), pcre_uint16(ucp_Cypriot)}, ucp_type_table{pcre_uint16(int32(222)), pcre_uint16(int32(4)), pcre_uint16(ucp_Cyrillic)}, ucp_type_table{pcre_uint16(int32(231)), pcre_uint16(int32(4)), pcre_uint16(ucp_Deseret)}, ucp_type_table{pcre_uint16(int32(239)), pcre_uint16(int32(4)), pcre_uint16(ucp_Devanagari)}, ucp_type_table{pcre_uint16(int32(250)), pcre_uint16(int32(4)), pcre_uint16(ucp_Duployan)}, ucp_type_table{pcre_uint16(int32(259)), pcre_uint16(int32(4)), pcre_uint16(ucp_Egyptian_Hieroglyphs)}, ucp_type_table{pcre_uint16(int32(280)), pcre_uint16(int32(4)), pcre_uint16(ucp_Elbasan)}, ucp_type_table{pcre_uint16(int32(288)), pcre_uint16(int32(4)), pcre_uint16(ucp_Ethiopic)}, ucp_type_table{pcre_uint16(int32(297)), pcre_uint16(int32(4)), pcre_uint16(ucp_Georgian)}, ucp_type_table{pcre_uint16(int32(306)), pcre_uint16(int32(4)), pcre_uint16(ucp_Glagolitic)}, ucp_type_table{pcre_uint16(int32(317)), pcre_uint16(int32(4)), pcre_uint16(ucp_Gothic)}, ucp_type_table{pcre_uint16(int32(324)), pcre_uint16(int32(4)), pcre_uint16(ucp_Grantha)}, ucp_type_table{pcre_uint16(int32(332)), pcre_uint16(int32(4)), pcre_uint16(ucp_Greek)}, ucp_type_table{pcre_uint16(int32(338)), pcre_uint16(int32(4)), pcre_uint16(ucp_Gujarati)}, ucp_type_table{pcre_uint16(int32(347)), pcre_uint16(int32(4)), pcre_uint16(ucp_Gurmukhi)}, ucp_type_table{pcre_uint16(int32(356)), pcre_uint16(int32(4)), pcre_uint16(ucp_Han)}, ucp_type_table{pcre_uint16(int32(360)), pcre_uint16(int32(4)), pcre_uint16(ucp_Hangul)}, ucp_type_table{pcre_uint16(int32(367)), pcre_uint16(int32(4)), pcre_uint16(ucp_Hanunoo)}, ucp_type_table{pcre_uint16(int32(375)), pcre_uint16(int32(4)), pcre_uint16(ucp_Hebrew)}, ucp_type_table{pcre_uint16(int32(382)), pcre_uint16(int32(4)), pcre_uint16(ucp_Hiragana)}, ucp_type_table{pcre_uint16(int32(391)), pcre_uint16(int32(4)), pcre_uint16(ucp_Imperial_Aramaic)}, ucp_type_table{pcre_uint16(int32(408)), pcre_uint16(int32(4)), pcre_uint16(ucp_Inherited)}, ucp_type_table{pcre_uint16(int32(418)), pcre_uint16(int32(4)), pcre_uint16(ucp_Inscriptional_Pahlavi)}, ucp_type_table{pcre_uint16(int32(440)), pcre_uint16(int32(4)), pcre_uint16(ucp_Inscriptional_Parthian)}, ucp_type_table{pcre_uint16(int32(463)), pcre_uint16(int32(4)), pcre_uint16(ucp_Javanese)}, ucp_type_table{pcre_uint16(int32(472)), pcre_uint16(int32(4)), pcre_uint16(ucp_Kaithi)}, ucp_type_table{pcre_uint16(int32(479)), pcre_uint16(int32(4)), pcre_uint16(ucp_Kannada)}, ucp_type_table{pcre_uint16(int32(487)), pcre_uint16(int32(4)), pcre_uint16(ucp_Katakana)}, ucp_type_table{pcre_uint16(int32(496)), pcre_uint16(int32(4)), pcre_uint16(ucp_Kayah_Li)}, ucp_type_table{pcre_uint16(int32(505)), pcre_uint16(int32(4)), pcre_uint16(ucp_Kharoshthi)}, ucp_type_table{pcre_uint16(int32(516)), pcre_uint16(int32(4)), pcre_uint16(ucp_Khmer)}, ucp_type_table{pcre_uint16(int32(522)), pcre_uint16(int32(4)), pcre_uint16(ucp_Khojki)}, ucp_type_table{pcre_uint16(int32(529)), pcre_uint16(int32(4)), pcre_uint16(ucp_Khudawadi)}, ucp_type_table{pcre_uint16(int32(539)), pcre_uint16(int32(2)), pcre_uint16(ucp_L)}, ucp_type_table{pcre_uint16(int32(541)), pcre_uint16(int32(1)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(544)), pcre_uint16(int32(4)), pcre_uint16(ucp_Lao)}, ucp_type_table{pcre_uint16(int32(548)), pcre_uint16(int32(4)), pcre_uint16(ucp_Latin)}, ucp_type_table{pcre_uint16(int32(554)), pcre_uint16(int32(4)), pcre_uint16(ucp_Lepcha)}, ucp_type_table{pcre_uint16(int32(561)), pcre_uint16(int32(4)), pcre_uint16(ucp_Limbu)}, ucp_type_table{pcre_uint16(int32(567)), pcre_uint16(int32(4)), pcre_uint16(ucp_Linear_A)}, ucp_type_table{pcre_uint16(int32(576)), pcre_uint16(int32(4)), pcre_uint16(ucp_Linear_B)}, ucp_type_table{pcre_uint16(int32(585)), pcre_uint16(int32(4)), pcre_uint16(ucp_Lisu)}, ucp_type_table{pcre_uint16(int32(590)), pcre_uint16(int32(3)), pcre_uint16(ucp_Ll)}, ucp_type_table{pcre_uint16(int32(593)), pcre_uint16(int32(3)), pcre_uint16(ucp_Lm)}, ucp_type_table{pcre_uint16(int32(596)), pcre_uint16(int32(3)), pcre_uint16(ucp_Lo)}, ucp_type_table{pcre_uint16(int32(599)), pcre_uint16(int32(3)), pcre_uint16(ucp_Lt)}, ucp_type_table{pcre_uint16(int32(602)), pcre_uint16(int32(3)), pcre_uint16(ucp_Lu)}, ucp_type_table{pcre_uint16(int32(605)), pcre_uint16(int32(4)), pcre_uint16(ucp_Lycian)}, ucp_type_table{pcre_uint16(int32(612)), pcre_uint16(int32(4)), pcre_uint16(ucp_Lydian)}, ucp_type_table{pcre_uint16(int32(619)), pcre_uint16(int32(2)), pcre_uint16(ucp_M)}, ucp_type_table{pcre_uint16(int32(621)), pcre_uint16(int32(4)), pcre_uint16(ucp_Mahajani)}, ucp_type_table{pcre_uint16(int32(630)), pcre_uint16(int32(4)), pcre_uint16(ucp_Malayalam)}, ucp_type_table{pcre_uint16(int32(640)), pcre_uint16(int32(4)), pcre_uint16(ucp_Mandaic)}, ucp_type_table{pcre_uint16(int32(648)), pcre_uint16(int32(4)), pcre_uint16(ucp_Manichaean)}, ucp_type_table{pcre_uint16(int32(659)), pcre_uint16(int32(3)), pcre_uint16(ucp_Mc)}, ucp_type_table{pcre_uint16(int32(662)), pcre_uint16(int32(3)), pcre_uint16(ucp_Me)}, ucp_type_table{pcre_uint16(int32(665)), pcre_uint16(int32(4)), pcre_uint16(ucp_Meetei_Mayek)}, ucp_type_table{pcre_uint16(int32(678)), pcre_uint16(int32(4)), pcre_uint16(ucp_Mende_Kikakui)}, ucp_type_table{pcre_uint16(int32(692)), pcre_uint16(int32(4)), pcre_uint16(ucp_Meroitic_Cursive)}, ucp_type_table{pcre_uint16(int32(709)), pcre_uint16(int32(4)), pcre_uint16(ucp_Meroitic_Hieroglyphs)}, ucp_type_table{pcre_uint16(int32(730)), pcre_uint16(int32(4)), pcre_uint16(ucp_Miao)}, ucp_type_table{pcre_uint16(int32(735)), pcre_uint16(int32(3)), pcre_uint16(ucp_Mn)}, ucp_type_table{pcre_uint16(int32(738)), pcre_uint16(int32(4)), pcre_uint16(ucp_Modi)}, ucp_type_table{pcre_uint16(int32(743)), pcre_uint16(int32(4)), pcre_uint16(ucp_Mongolian)}, ucp_type_table{pcre_uint16(int32(753)), pcre_uint16(int32(4)), pcre_uint16(ucp_Mro)}, ucp_type_table{pcre_uint16(int32(757)), pcre_uint16(int32(4)), pcre_uint16(ucp_Myanmar)}, ucp_type_table{pcre_uint16(int32(765)), pcre_uint16(int32(2)), pcre_uint16(ucp_N)}, ucp_type_table{pcre_uint16(int32(767)), pcre_uint16(int32(4)), pcre_uint16(ucp_Nabataean)}, ucp_type_table{pcre_uint16(int32(777)), pcre_uint16(int32(3)), pcre_uint16(ucp_Nd)}, ucp_type_table{pcre_uint16(int32(780)), pcre_uint16(int32(4)), pcre_uint16(ucp_New_Tai_Lue)}, ucp_type_table{pcre_uint16(int32(792)), pcre_uint16(int32(4)), pcre_uint16(ucp_Nko)}, ucp_type_table{pcre_uint16(int32(796)), pcre_uint16(int32(3)), pcre_uint16(ucp_Nl)}, ucp_type_table{pcre_uint16(int32(799)), pcre_uint16(int32(3)), pcre_uint16(ucp_No)}, ucp_type_table{pcre_uint16(int32(802)), pcre_uint16(int32(4)), pcre_uint16(ucp_Ogham)}, ucp_type_table{pcre_uint16(int32(808)), pcre_uint16(int32(4)), pcre_uint16(ucp_Ol_Chiki)}, ucp_type_table{pcre_uint16(int32(817)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_Italic)}, ucp_type_table{pcre_uint16(int32(828)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_North_Arabian)}, ucp_type_table{pcre_uint16(int32(846)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_Permic)}, ucp_type_table{pcre_uint16(int32(857)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_Persian)}, ucp_type_table{pcre_uint16(int32(869)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_South_Arabian)}, ucp_type_table{pcre_uint16(int32(887)), pcre_uint16(int32(4)), pcre_uint16(ucp_Old_Turkic)}, ucp_type_table{pcre_uint16(int32(898)), pcre_uint16(int32(4)), pcre_uint16(ucp_Oriya)}, ucp_type_table{pcre_uint16(int32(904)), pcre_uint16(int32(4)), pcre_uint16(ucp_Osmanya)}, ucp_type_table{pcre_uint16(int32(912)), pcre_uint16(int32(2)), pcre_uint16(ucp_P)}, ucp_type_table{pcre_uint16(int32(914)), pcre_uint16(int32(4)), pcre_uint16(ucp_Pahawh_Hmong)}, ucp_type_table{pcre_uint16(int32(927)), pcre_uint16(int32(4)), pcre_uint16(ucp_Palmyrene)}, ucp_type_table{pcre_uint16(int32(937)), pcre_uint16(int32(4)), pcre_uint16(ucp_Pau_Cin_Hau)}, ucp_type_table{pcre_uint16(int32(949)), pcre_uint16(int32(3)), pcre_uint16(ucp_Pc)}, ucp_type_table{pcre_uint16(int32(952)), pcre_uint16(int32(3)), pcre_uint16(ucp_Pd)}, ucp_type_table{pcre_uint16(int32(955)), pcre_uint16(int32(3)), pcre_uint16(ucp_Pe)}, ucp_type_table{pcre_uint16(int32(958)), pcre_uint16(int32(3)), pcre_uint16(ucp_Pf)}, ucp_type_table{pcre_uint16(int32(961)), pcre_uint16(int32(4)), pcre_uint16(ucp_Phags_Pa)}, ucp_type_table{pcre_uint16(int32(970)), pcre_uint16(int32(4)), pcre_uint16(ucp_Phoenician)}, ucp_type_table{pcre_uint16(int32(981)), pcre_uint16(int32(3)), pcre_uint16(ucp_Pi)}, ucp_type_table{pcre_uint16(int32(984)), pcre_uint16(int32(3)), pcre_uint16(ucp_Po)}, ucp_type_table{pcre_uint16(int32(987)), pcre_uint16(int32(3)), pcre_uint16(ucp_Ps)}, ucp_type_table{pcre_uint16(int32(990)), pcre_uint16(int32(4)), pcre_uint16(ucp_Psalter_Pahlavi)}, ucp_type_table{pcre_uint16(int32(1006)), pcre_uint16(int32(4)), pcre_uint16(ucp_Rejang)}, ucp_type_table{pcre_uint16(int32(1013)), pcre_uint16(int32(4)), pcre_uint16(ucp_Runic)}, ucp_type_table{pcre_uint16(int32(1019)), pcre_uint16(int32(2)), pcre_uint16(ucp_S)}, ucp_type_table{pcre_uint16(int32(1021)), pcre_uint16(int32(4)), pcre_uint16(ucp_Samaritan)}, ucp_type_table{pcre_uint16(int32(1031)), pcre_uint16(int32(4)), pcre_uint16(ucp_Saurashtra)}, ucp_type_table{pcre_uint16(int32(1042)), pcre_uint16(int32(3)), pcre_uint16(ucp_Sc)}, ucp_type_table{pcre_uint16(int32(1045)), pcre_uint16(int32(4)), pcre_uint16(ucp_Sharada)}, ucp_type_table{pcre_uint16(int32(1053)), pcre_uint16(int32(4)), pcre_uint16(ucp_Shavian)}, ucp_type_table{pcre_uint16(int32(1061)), pcre_uint16(int32(4)), pcre_uint16(ucp_Siddham)}, ucp_type_table{pcre_uint16(int32(1069)), pcre_uint16(int32(4)), pcre_uint16(ucp_Sinhala)}, ucp_type_table{pcre_uint16(int32(1077)), pcre_uint16(int32(3)), pcre_uint16(ucp_Sk)}, ucp_type_table{pcre_uint16(int32(1080)), pcre_uint16(int32(3)), pcre_uint16(ucp_Sm)}, ucp_type_table{pcre_uint16(int32(1083)), pcre_uint16(int32(3)), pcre_uint16(ucp_So)}, ucp_type_table{pcre_uint16(int32(1086)), pcre_uint16(int32(4)), pcre_uint16(ucp_Sora_Sompeng)}, ucp_type_table{pcre_uint16(int32(1099)), pcre_uint16(int32(4)), pcre_uint16(ucp_Sundanese)}, ucp_type_table{pcre_uint16(int32(1109)), pcre_uint16(int32(4)), pcre_uint16(ucp_Syloti_Nagri)}, ucp_type_table{pcre_uint16(int32(1122)), pcre_uint16(int32(4)), pcre_uint16(ucp_Syriac)}, ucp_type_table{pcre_uint16(int32(1129)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tagalog)}, ucp_type_table{pcre_uint16(int32(1137)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tagbanwa)}, ucp_type_table{pcre_uint16(int32(1146)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tai_Le)}, ucp_type_table{pcre_uint16(int32(1153)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tai_Tham)}, ucp_type_table{pcre_uint16(int32(1162)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tai_Viet)}, ucp_type_table{pcre_uint16(int32(1171)), pcre_uint16(int32(4)), pcre_uint16(ucp_Takri)}, ucp_type_table{pcre_uint16(int32(1177)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tamil)}, ucp_type_table{pcre_uint16(int32(1183)), pcre_uint16(int32(4)), pcre_uint16(ucp_Telugu)}, ucp_type_table{pcre_uint16(int32(1190)), pcre_uint16(int32(4)), pcre_uint16(ucp_Thaana)}, ucp_type_table{pcre_uint16(int32(1197)), pcre_uint16(int32(4)), pcre_uint16(ucp_Thai)}, ucp_type_table{pcre_uint16(int32(1202)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tibetan)}, ucp_type_table{pcre_uint16(int32(1210)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tifinagh)}, ucp_type_table{pcre_uint16(int32(1219)), pcre_uint16(int32(4)), pcre_uint16(ucp_Tirhuta)}, ucp_type_table{pcre_uint16(int32(1227)), pcre_uint16(int32(4)), pcre_uint16(ucp_Ugaritic)}, ucp_type_table{pcre_uint16(int32(1236)), pcre_uint16(int32(4)), pcre_uint16(ucp_Vai)}, ucp_type_table{pcre_uint16(int32(1240)), pcre_uint16(int32(4)), pcre_uint16(ucp_Warang_Citi)}, ucp_type_table{pcre_uint16(int32(1252)), pcre_uint16(int32(5)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(1256)), pcre_uint16(int32(7)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(1260)), pcre_uint16(int32(6)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(1264)), pcre_uint16(int32(10)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(1268)), pcre_uint16(int32(8)), pcre_uint16(int32(0))}, ucp_type_table{pcre_uint16(int32(1272)), pcre_uint16(int32(4)), pcre_uint16(ucp_Yi)}, ucp_type_table{pcre_uint16(int32(1275)), pcre_uint16(int32(2)), pcre_uint16(ucp_Z)}, ucp_type_table{pcre_uint16(int32(1277)), pcre_uint16(int32(3)), pcre_uint16(ucp_Zl)}, ucp_type_table{pcre_uint16(int32(1280)), pcre_uint16(int32(3)), pcre_uint16(ucp_Zp)}, ucp_type_table{pcre_uint16(int32(1283)), pcre_uint16(int32(3)), pcre_uint16(ucp_Zs)}}
var _pcre_utt_size int32 = int32((1352 / 8))
var _pcre_ucd_caseless_sets []pcre_uint32 = []pcre_uint32{4294967295, pcre_uint32(int32(83)), pcre_uint32(int32(115)), pcre_uint32(int32(383)), 4294967295, pcre_uint32(int32(452)), pcre_uint32(int32(453)), pcre_uint32(int32(454)), 4294967295, pcre_uint32(int32(455)), pcre_uint32(int32(456)), pcre_uint32(int32(457)), 4294967295, pcre_uint32(int32(458)), pcre_uint32(int32(459)), pcre_uint32(int32(460)), 4294967295, pcre_uint32(int32(497)), pcre_uint32(int32(498)), pcre_uint32(int32(499)), 4294967295, pcre_uint32(int32(837)), pcre_uint32(int32(921)), pcre_uint32(int32(953)), pcre_uint32(int32(8126)), 4294967295, pcre_uint32(int32(181)), pcre_uint32(int32(924)), pcre_uint32(int32(956)), 4294967295, pcre_uint32(int32(931)), pcre_uint32(int32(962)), pcre_uint32(int32(963)), 4294967295, pcre_uint32(int32(914)), pcre_uint32(int32(946)), pcre_uint32(int32(976)), 4294967295, pcre_uint32(int32(920)), pcre_uint32(int32(952)), pcre_uint32(int32(977)), pcre_uint32(int32(1012)), 4294967295, pcre_uint32(int32(934)), pcre_uint32(int32(966)), pcre_uint32(int32(981)), 4294967295, pcre_uint32(int32(928)), pcre_uint32(int32(960)), pcre_uint32(int32(982)), 4294967295, pcre_uint32(int32(922)), pcre_uint32(int32(954)), pcre_uint32(int32(1008)), 4294967295, pcre_uint32(int32(929)), pcre_uint32(int32(961)), pcre_uint32(int32(1009)), 4294967295, pcre_uint32(int32(917)), pcre_uint32(int32(949)), pcre_uint32(int32(1013)), 4294967295, pcre_uint32(int32(7776)), pcre_uint32(int32(7777)), pcre_uint32(int32(7835)), 4294967295, pcre_uint32(int32(937)), pcre_uint32(int32(969)), pcre_uint32(int32(8486)), 4294967295, pcre_uint32(int32(75)), pcre_uint32(int32(107)), pcre_uint32(int32(8490)), 4294967295, pcre_uint32(int32(197)), pcre_uint32(int32(229)), pcre_uint32(int32(8491)), 4294967295}
var _pcre_ucd_records []ucd_record = []ucd_record{ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(0)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(29)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(22)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(18)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(25)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(17)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(71)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(1)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(24)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(16)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(71)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(1)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(20)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(26)), pcre_int32((int32(775)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(19)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(75)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(7615)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(75)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(121)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(121)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(1)), pcre_int32((-int32(268)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(195)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(210)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(206)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(205)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(79)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(202)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(203)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(207)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(97)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(211)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(209)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(163)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(213)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(130)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(214)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(218)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(217)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(219)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(56)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_int32((int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_int32((-int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_int32((int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_int32((-int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_int32((int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_int32((-int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(79)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(17)), pcre_int32((int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(17)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(17)), pcre_int32((-int32(2)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(97)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(56)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(130)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10795)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(163)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10792)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10815)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(195)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(69)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(71)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10783)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10780)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10782)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(210)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(206)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(205)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(202)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(203)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42319)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42315)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(207)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42280)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42308)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(209)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(211)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10743)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42305)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10749)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(213)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(214)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(10727)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(218)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42282)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(69)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(217)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(71)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(219)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(42258)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(3)), pcre_uint8(int32(24)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(27)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(27)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(21)), pcre_int32((int32(116)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(1)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(24)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(2)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(130)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(116)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(38)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(37)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(64)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(63)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(34)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(59)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(38)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(21)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(51)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(26)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(47)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(55)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(30)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(43)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(67)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(38)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(37)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(34)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(59)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(38)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(21)), pcre_int32((-int32(116)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(51)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(26)), pcre_int32((-int32(775)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(47)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(55)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(30)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(30)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(43)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(67)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(64)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(63)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(8)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(34)), pcre_int32((-int32(30)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(38)), pcre_int32((-int32(25)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(43)), pcre_int32((-int32(15)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(47)), pcre_int32((-int32(22)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(8)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(1)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(51)), pcre_int32((-int32(54)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(55)), pcre_int32((-int32(48)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(7)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(116)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(38)), pcre_int32((-int32(60)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(59)), pcre_int32((-int32(64)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(25)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(7)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(130)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(80)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(80)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(1)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(11)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(15)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(15)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(48)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(48)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(17)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(1)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(25)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(25)), pcre_uint8(int32(17)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(25)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(25)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(25)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(49)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(49)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(49)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(49)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(55)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(55)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(63)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(89)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(89)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(89)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(89)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(94)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(94)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(94)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(14)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(2)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(21)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(21)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(21)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(20)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(43)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(53)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(54)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(28)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(28)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(28)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(28)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(28)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(36)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(7)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(56)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(32)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(32)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(32)), pcre_uint8(int32(7)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(32)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(32)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(22)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(18)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(57)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(10)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(16)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(7264)))}, ucd_record{pcre_uint8(int32(16)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(16)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(6)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(7)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(8)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(15)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(15)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(15)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(15)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(8)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(7)), pcre_uint8(int32(17)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(7)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(7)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(40)), pcre_uint8(int32(29)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(40)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(40)), pcre_uint8(int32(22)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(40)), pcre_uint8(int32(18)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(45)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(45)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(50)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(50)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(24)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(24)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(6)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(51)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(51)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(23)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(17)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(37)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(34)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(52)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(10)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(39)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(31)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(5)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(5)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(5)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(10)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(90)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(27)), pcre_uint8(int32(11)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(61)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(75)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(75)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(75)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(75)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(92)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(92)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(92)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(92)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(69)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(69)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(69)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(69)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(69)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(72)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(72)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(72)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(72)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(75)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(35332)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(3814)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(63)), pcre_int32((int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(63)), pcre_int32((-int32(1)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(63)), pcre_int32((-int32(58)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(7615)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(8)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(8)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(74)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(86)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(100)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(128)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(112)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(126)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(8)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(9)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(74)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(8)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(9)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(21)), pcre_int32((-int32(7173)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(86)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(100)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(112)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(128)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(126)))}, ucd_record{pcre_uint8(int32(27)), pcre_uint8(int32(1)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(27)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(28)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(2)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(67)), pcre_int32((-int32(7517)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(71)), pcre_int32((-int32(8383)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(75)), pcre_int32((-int32(8262)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(28)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(28)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(16)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(16)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(26)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(26)))}, ucd_record{pcre_uint8(int32(4)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(17)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(48)))}, ucd_record{pcre_uint8(int32(17)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(48)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10743)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(3814)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10727)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10795)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10792)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10780)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10749)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10783)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10782)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(10815)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(10)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(16)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(7264)))}, ucd_record{pcre_uint8(int32(58)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(58)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(58)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(58)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(22)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(22)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(22)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(26)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(26)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(29)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(29)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(3)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(29)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(22)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(60)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(60)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(60)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(85)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(85)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(85)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(76)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(76)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(76)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(76)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(12)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(78)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(78)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(78)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(78)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(35332)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42280)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42308)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42319)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42315)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42305)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42258)))}, ucd_record{pcre_uint8(int32(33)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(42282)))}, ucd_record{pcre_uint8(int32(48)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(48)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(48)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(48)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(64)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(64)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(74)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(74)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(74)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(74)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(74)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(68)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(68)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(68)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(68)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(73)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(73)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(73)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(73)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(83)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(83)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(83)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(83)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(83)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(38)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(67)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(67)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(67)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(67)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(67)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(91)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(91)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(91)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(91)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(86)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(9)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(23)), pcre_uint8(int32(7)), pcre_uint8(int32(10)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(4)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(3)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(25)), pcre_uint8(int32(25)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(24)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(6)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(35)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(70)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(66)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(41)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(41)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(18)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(18)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(117)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(117)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(59)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(59)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(42)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(42)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(42)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(13)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(40)))}, ucd_record{pcre_uint8(int32(13)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(40)))}, ucd_record{pcre_uint8(int32(46)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(44)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(44)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(105)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(103)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(103)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(109)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(11)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(80)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(80)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(80)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(119)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(119)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(119)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(115)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(115)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(65)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(65)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(65)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(71)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(71)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(97)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(96)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(30)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(30)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(30)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(30)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(87)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(87)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(87)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(116)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(116)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(111)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(111)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(111)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(111)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(111)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(77)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(77)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(82)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(82)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(81)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(81)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(120)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(120)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(120)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(88)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(0)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(93)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(84)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(84)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(84)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(84)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(84)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(100)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(100)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(95)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(95)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(95)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(95)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(95)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(110)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(110)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(110)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(99)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(99)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(99)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(99)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(99)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(47)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(107)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(107)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(107)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(107)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(108)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(108)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(108)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(108)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(106)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(106)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(106)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(106)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(123)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(122)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(122)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(122)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(122)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(122)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(113)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(113)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(113)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(113)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(113)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(101)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(101)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(101)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(101)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(124)), pcre_uint8(int32(9)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(32)))}, ucd_record{pcre_uint8(int32(124)), pcre_uint8(int32(5)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((-int32(32)))}, ucd_record{pcre_uint8(int32(124)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(124)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(124)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(121)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(62)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(62)), pcre_uint8(int32(14)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(62)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(79)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(114)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(114)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(114)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(102)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(102)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(102)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(13)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(118)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(98)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(98)), pcre_uint8(int32(10)), pcre_uint8(int32(5)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(98)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(98)), pcre_uint8(int32(6)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(104)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(104)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(104)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(104)), pcre_uint8(int32(21)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(19)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(112)), pcre_uint8(int32(7)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(112)), pcre_uint8(int32(15)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(112)), pcre_uint8(int32(12)), pcre_uint8(int32(3)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(9)), pcre_uint8(int32(26)), pcre_uint8(int32(11)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}, ucd_record{pcre_uint8(int32(26)), pcre_uint8(int32(26)), pcre_uint8(int32(12)), pcre_uint8(int32(0)), pcre_int32((int32(0)))}}
var _pcre_ucd_stage1 []pcre_uint8 = []pcre_uint8{pcre_uint8(int32(0)), pcre_uint8(int32(1)), pcre_uint8(int32(2)), pcre_uint8(int32(3)), pcre_uint8(int32(4)), pcre_uint8(int32(5)), pcre_uint8(int32(6)), pcre_uint8(int32(7)), pcre_uint8(int32(8)), pcre_uint8(int32(9)), pcre_uint8(int32(10)), pcre_uint8(int32(11)), pcre_uint8(int32(12)), pcre_uint8(int32(13)), pcre_uint8(int32(14)), pcre_uint8(int32(15)), pcre_uint8(int32(16)), pcre_uint8(int32(17)), pcre_uint8(int32(18)), pcre_uint8(int32(19)), pcre_uint8(int32(20)), pcre_uint8(int32(21)), pcre_uint8(int32(22)), pcre_uint8(int32(23)), pcre_uint8(int32(24)), pcre_uint8(int32(25)), pcre_uint8(int32(26)), pcre_uint8(int32(27)), pcre_uint8(int32(28)), pcre_uint8(int32(29)), pcre_uint8(int32(30)), pcre_uint8(int32(31)), pcre_uint8(int32(32)), pcre_uint8(int32(33)), pcre_uint8(int32(34)), pcre_uint8(int32(35)), pcre_uint8(int32(36)), pcre_uint8(int32(37)), pcre_uint8(int32(38)), pcre_uint8(int32(39)), pcre_uint8(int32(40)), pcre_uint8(int32(41)), pcre_uint8(int32(41)), pcre_uint8(int32(41)), pcre_uint8(int32(42)), pcre_uint8(int32(43)), pcre_uint8(int32(44)), pcre_uint8(int32(45)), pcre_uint8(int32(46)), pcre_uint8(int32(47)), pcre_uint8(int32(48)), pcre_uint8(int32(49)), pcre_uint8(int32(50)), pcre_uint8(int32(51)), pcre_uint8(int32(52)), pcre_uint8(int32(53)), pcre_uint8(int32(54)), pcre_uint8(int32(55)), pcre_uint8(int32(56)), pcre_uint8(int32(57)), pcre_uint8(int32(58)), pcre_uint8(int32(59)), pcre_uint8(int32(60)), pcre_uint8(int32(61)), pcre_uint8(int32(62)), pcre_uint8(int32(63)), pcre_uint8(int32(64)), pcre_uint8(int32(65)), pcre_uint8(int32(66)), pcre_uint8(int32(66)), pcre_uint8(int32(67)), pcre_uint8(int32(68)), pcre_uint8(int32(69)), pcre_uint8(int32(70)), pcre_uint8(int32(71)), pcre_uint8(int32(72)), pcre_uint8(int32(73)), pcre_uint8(int32(71)), pcre_uint8(int32(74)), pcre_uint8(int32(75)), pcre_uint8(int32(76)), pcre_uint8(int32(76)), pcre_uint8(int32(66)), pcre_uint8(int32(77)), pcre_uint8(int32(66)), pcre_uint8(int32(66)), pcre_uint8(int32(78)), pcre_uint8(int32(79)), pcre_uint8(int32(80)), pcre_uint8(int32(81)), pcre_uint8(int32(82)), pcre_uint8(int32(83)), pcre_uint8(int32(84)), pcre_uint8(int32(85)), pcre_uint8(int32(86)), pcre_uint8(int32(87)), pcre_uint8(int32(88)), pcre_uint8(int32(89)), pcre_uint8(int32(90)), pcre_uint8(int32(91)), pcre_uint8(int32(92)), pcre_uint8(int32(93)), pcre_uint8(int32(94)), pcre_uint8(int32(71)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(96)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(97)), pcre_uint8(int32(98)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(99)), pcre_uint8(int32(100)), pcre_uint8(int32(101)), pcre_uint8(int32(101)), pcre_uint8(int32(102)), pcre_uint8(int32(103)), pcre_uint8(int32(104)), pcre_uint8(int32(105)), pcre_uint8(int32(106)), pcre_uint8(int32(107)), pcre_uint8(int32(108)), pcre_uint8(int32(109)), pcre_uint8(int32(110)), pcre_uint8(int32(111)), pcre_uint8(int32(112)), pcre_uint8(int32(113)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(117)), pcre_uint8(int32(118)), pcre_uint8(int32(119)), pcre_uint8(int32(120)), pcre_uint8(int32(114)), pcre_uint8(int32(115)), pcre_uint8(int32(116)), pcre_uint8(int32(121)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(122)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(124)), pcre_uint8(int32(125)), pcre_uint8(int32(126)), pcre_uint8(int32(127)), pcre_uint8(int32(128)), pcre_uint8(int32(128)), pcre_uint8(int32(129)), pcre_uint8(int32(130)), pcre_uint8(int32(131)), pcre_uint8(int32(132)), pcre_uint8(int32(133)), pcre_uint8(int32(134)), pcre_uint8(int32(135)), pcre_uint8(int32(136)), pcre_uint8(int32(137)), pcre_uint8(int32(138)), pcre_uint8(int32(139)), pcre_uint8(int32(140)), pcre_uint8(int32(141)), pcre_uint8(int32(142)), pcre_uint8(int32(143)), pcre_uint8(int32(144)), pcre_uint8(int32(145)), pcre_uint8(int32(139)), pcre_uint8(int32(146)), pcre_uint8(int32(146)), pcre_uint8(int32(147)), pcre_uint8(int32(139)), pcre_uint8(int32(148)), pcre_uint8(int32(149)), pcre_uint8(int32(150)), pcre_uint8(int32(151)), pcre_uint8(int32(152)), pcre_uint8(int32(153)), pcre_uint8(int32(154)), pcre_uint8(int32(155)), pcre_uint8(int32(156)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(157)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(158)), pcre_uint8(int32(159)), pcre_uint8(int32(160)), pcre_uint8(int32(161)), pcre_uint8(int32(162)), pcre_uint8(int32(163)), pcre_uint8(int32(164)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(165)), pcre_uint8(int32(139)), pcre_uint8(int32(166)), pcre_uint8(int32(167)), pcre_uint8(int32(168)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(169)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(170)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(171)), pcre_uint8(int32(172)), pcre_uint8(int32(173)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(174)), pcre_uint8(int32(175)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(176)), pcre_uint8(int32(176)), pcre_uint8(int32(176)), pcre_uint8(int32(176)), pcre_uint8(int32(177)), pcre_uint8(int32(178)), pcre_uint8(int32(179)), pcre_uint8(int32(180)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(181)), pcre_uint8(int32(182)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(183)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(184)), pcre_uint8(int32(185)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(71)), pcre_uint8(int32(186)), pcre_uint8(int32(187)), pcre_uint8(int32(188)), pcre_uint8(int32(189)), pcre_uint8(int32(139)), pcre_uint8(int32(190)), pcre_uint8(int32(139)), pcre_uint8(int32(191)), pcre_uint8(int32(192)), pcre_uint8(int32(193)), pcre_uint8(int32(194)), pcre_uint8(int32(195)), pcre_uint8(int32(196)), pcre_uint8(int32(197)), pcre_uint8(int32(198)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(199)), pcre_uint8(int32(200)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(201)), pcre_uint8(int32(202)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(203)), pcre_uint8(int32(204)), pcre_uint8(int32(205)), pcre_uint8(int32(206)), pcre_uint8(int32(207)), pcre_uint8(int32(139)), pcre_uint8(int32(208)), pcre_uint8(int32(209)), pcre_uint8(int32(71)), pcre_uint8(int32(210)), pcre_uint8(int32(211)), pcre_uint8(int32(212)), pcre_uint8(int32(213)), pcre_uint8(int32(214)), pcre_uint8(int32(215)), pcre_uint8(int32(216)), pcre_uint8(int32(217)), pcre_uint8(int32(218)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(219)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(220)), pcre_uint8(int32(95)), pcre_uint8(int32(221)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(95)), pcre_uint8(int32(221)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(222)), pcre_uint8(int32(223)), pcre_uint8(int32(224)), pcre_uint8(int32(225)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(223)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(139)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(226)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(123)), pcre_uint8(int32(226))}
var _pcre_ucd_stage2 []pcre_uint16 = []pcre_uint16{pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(1)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(2)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(3)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(5)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(12)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(13)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(6)), pcre_uint16(int32(4)), pcre_uint16(int32(7)), pcre_uint16(int32(14)), pcre_uint16(int32(15)), pcre_uint16(int32(14)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(17)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(18)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(6)), pcre_uint16(int32(8)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(0)), pcre_uint16(int32(3)), pcre_uint16(int32(4)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(19)), pcre_uint16(int32(4)), pcre_uint16(int32(14)), pcre_uint16(int32(19)), pcre_uint16(int32(20)), pcre_uint16(int32(21)), pcre_uint16(int32(8)), pcre_uint16(int32(22)), pcre_uint16(int32(19)), pcre_uint16(int32(14)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(14)), pcre_uint16(int32(24)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(14)), pcre_uint16(int32(23)), pcre_uint16(int32(20)), pcre_uint16(int32(25)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(4)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(26)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(8)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(27)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(28)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(8)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(29)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(32)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(34)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(35)), pcre_uint16(int32(36)), pcre_uint16(int32(37)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(38)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(39)), pcre_uint16(int32(39)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(40)), pcre_uint16(int32(41)), pcre_uint16(int32(42)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(39)), pcre_uint16(int32(43)), pcre_uint16(int32(44)), pcre_uint16(int32(45)), pcre_uint16(int32(46)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(47)), pcre_uint16(int32(33)), pcre_uint16(int32(45)), pcre_uint16(int32(48)), pcre_uint16(int32(49)), pcre_uint16(int32(50)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(51)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(51)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(51)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(52)), pcre_uint16(int32(52)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(53)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(20)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(54)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(55)), pcre_uint16(int32(56)), pcre_uint16(int32(57)), pcre_uint16(int32(58)), pcre_uint16(int32(59)), pcre_uint16(int32(60)), pcre_uint16(int32(61)), pcre_uint16(int32(62)), pcre_uint16(int32(63)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(64)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(65)), pcre_uint16(int32(66)), pcre_uint16(int32(67)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(68)), pcre_uint16(int32(69)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(70)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(71)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(72)), pcre_uint16(int32(73)), pcre_uint16(int32(74)), pcre_uint16(int32(74)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(75)), pcre_uint16(int32(76)), pcre_uint16(int32(77)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(78)), pcre_uint16(int32(79)), pcre_uint16(int32(80)), pcre_uint16(int32(81)), pcre_uint16(int32(82)), pcre_uint16(int32(33)), pcre_uint16(int32(83)), pcre_uint16(int32(83)), pcre_uint16(int32(33)), pcre_uint16(int32(84)), pcre_uint16(int32(33)), pcre_uint16(int32(85)), pcre_uint16(int32(86)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(83)), pcre_uint16(int32(87)), pcre_uint16(int32(33)), pcre_uint16(int32(88)), pcre_uint16(int32(33)), pcre_uint16(int32(89)), pcre_uint16(int32(90)), pcre_uint16(int32(33)), pcre_uint16(int32(91)), pcre_uint16(int32(92)), pcre_uint16(int32(33)), pcre_uint16(int32(93)), pcre_uint16(int32(94)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(92)), pcre_uint16(int32(33)), pcre_uint16(int32(95)), pcre_uint16(int32(96)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(97)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(98)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(99)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(99)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(100)), pcre_uint16(int32(99)), pcre_uint16(int32(101)), pcre_uint16(int32(102)), pcre_uint16(int32(102)), pcre_uint16(int32(103)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(104)), pcre_uint16(int32(33)), pcre_uint16(int32(20)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(105)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(108)), pcre_uint16(int32(108)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(110)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(107)), pcre_uint16(int32(113)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(115)), pcre_uint16(int32(116)), pcre_uint16(int32(116)), pcre_uint16(int32(116)), pcre_uint16(int32(4)), pcre_uint16(int32(117)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(113)), pcre_uint16(int32(14)), pcre_uint16(int32(118)), pcre_uint16(int32(4)), pcre_uint16(int32(119)), pcre_uint16(int32(119)), pcre_uint16(int32(119)), pcre_uint16(int32(114)), pcre_uint16(int32(120)), pcre_uint16(int32(114)), pcre_uint16(int32(121)), pcre_uint16(int32(121)), pcre_uint16(int32(122)), pcre_uint16(int32(123)), pcre_uint16(int32(124)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(125)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(126)), pcre_uint16(int32(127)), pcre_uint16(int32(128)), pcre_uint16(int32(123)), pcre_uint16(int32(129)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(130)), pcre_uint16(int32(131)), pcre_uint16(int32(114)), pcre_uint16(int32(132)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(133)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(134)), pcre_uint16(int32(123)), pcre_uint16(int32(123)), pcre_uint16(int32(135)), pcre_uint16(int32(136)), pcre_uint16(int32(136)), pcre_uint16(int32(136)), pcre_uint16(int32(122)), pcre_uint16(int32(137)), pcre_uint16(int32(138)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(139)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(140)), pcre_uint16(int32(141)), pcre_uint16(int32(142)), pcre_uint16(int32(137)), pcre_uint16(int32(143)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(144)), pcre_uint16(int32(145)), pcre_uint16(int32(146)), pcre_uint16(int32(147)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(148)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(149)), pcre_uint16(int32(137)), pcre_uint16(int32(137)), pcre_uint16(int32(150)), pcre_uint16(int32(151)), pcre_uint16(int32(151)), pcre_uint16(int32(152)), pcre_uint16(int32(153)), pcre_uint16(int32(154)), pcre_uint16(int32(155)), pcre_uint16(int32(155)), pcre_uint16(int32(155)), pcre_uint16(int32(156)), pcre_uint16(int32(157)), pcre_uint16(int32(158)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(161)), pcre_uint16(int32(162)), pcre_uint16(int32(163)), pcre_uint16(int32(164)), pcre_uint16(int32(165)), pcre_uint16(int32(166)), pcre_uint16(int32(167)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(168)), pcre_uint16(int32(111)), pcre_uint16(int32(112)), pcre_uint16(int32(122)), pcre_uint16(int32(169)), pcre_uint16(int32(169)), pcre_uint16(int32(169)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(170)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(171)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(172)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(173)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(176)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(177)), pcre_uint16(int32(178)), pcre_uint16(int32(178)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(179)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(180)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(114)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(181)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(182)), pcre_uint16(int32(183)), pcre_uint16(int32(183)), pcre_uint16(int32(183)), pcre_uint16(int32(183)), pcre_uint16(int32(183)), pcre_uint16(int32(183)), pcre_uint16(int32(114)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(184)), pcre_uint16(int32(185)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(186)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(187)), pcre_uint16(int32(187)), pcre_uint16(int32(188)), pcre_uint16(int32(114)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(190)), pcre_uint16(int32(189)), pcre_uint16(int32(191)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(191)), pcre_uint16(int32(189)), pcre_uint16(int32(189)), pcre_uint16(int32(191)), pcre_uint16(int32(189)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(191)), pcre_uint16(int32(191)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(193)), pcre_uint16(int32(193)), pcre_uint16(int32(193)), pcre_uint16(int32(193)), pcre_uint16(int32(193)), pcre_uint16(int32(22)), pcre_uint16(int32(194)), pcre_uint16(int32(194)), pcre_uint16(int32(194)), pcre_uint16(int32(195)), pcre_uint16(int32(195)), pcre_uint16(int32(196)), pcre_uint16(int32(4)), pcre_uint16(int32(195)), pcre_uint16(int32(197)), pcre_uint16(int32(197)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(4)), pcre_uint16(int32(22)), pcre_uint16(int32(114)), pcre_uint16(int32(195)), pcre_uint16(int32(4)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(107)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(195)), pcre_uint16(int32(195)), pcre_uint16(int32(195)), pcre_uint16(int32(195)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(109)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(195)), pcre_uint16(int32(199)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(22)), pcre_uint16(int32(197)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(200)), pcre_uint16(int32(200)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(197)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(201)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(197)), pcre_uint16(int32(197)), pcre_uint16(int32(199)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(202)), pcre_uint16(int32(114)), pcre_uint16(int32(203)), pcre_uint16(int32(204)), pcre_uint16(int32(205)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(205)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(204)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(206)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(207)), pcre_uint16(int32(206)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(208)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(209)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(210)), pcre_uint16(int32(211)), pcre_uint16(int32(211)), pcre_uint16(int32(212)), pcre_uint16(int32(213)), pcre_uint16(int32(213)), pcre_uint16(int32(213)), pcre_uint16(int32(211)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(214)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(216)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(216)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(216)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(215)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(217)), pcre_uint16(int32(114)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(218)), pcre_uint16(int32(219)), pcre_uint16(int32(219)), pcre_uint16(int32(219)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(220)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(198)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(222)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(221)), pcre_uint16(int32(222)), pcre_uint16(int32(221)), pcre_uint16(int32(223)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(221)), pcre_uint16(int32(222)), pcre_uint16(int32(222)), pcre_uint16(int32(223)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(224)), pcre_uint16(int32(225)), pcre_uint16(int32(226)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(227)), pcre_uint16(int32(228)), pcre_uint16(int32(229)), pcre_uint16(int32(229)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(228)), pcre_uint16(int32(227)), pcre_uint16(int32(230)), pcre_uint16(int32(229)), pcre_uint16(int32(229)), pcre_uint16(int32(228)), pcre_uint16(int32(228)), pcre_uint16(int32(228)), pcre_uint16(int32(228)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(229)), pcre_uint16(int32(229)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(229)), pcre_uint16(int32(229)), pcre_uint16(int32(228)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(230)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(114)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(228)), pcre_uint16(int32(228)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(231)), pcre_uint16(int32(227)), pcre_uint16(int32(227)), pcre_uint16(int32(232)), pcre_uint16(int32(232)), pcre_uint16(int32(233)), pcre_uint16(int32(233)), pcre_uint16(int32(233)), pcre_uint16(int32(233)), pcre_uint16(int32(233)), pcre_uint16(int32(233)), pcre_uint16(int32(234)), pcre_uint16(int32(232)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(236)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(236)), pcre_uint16(int32(236)), pcre_uint16(int32(236)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(237)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(238)), pcre_uint16(int32(235)), pcre_uint16(int32(235)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(237)), pcre_uint16(int32(235)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(240)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(239)), pcre_uint16(int32(241)), pcre_uint16(int32(240)), pcre_uint16(int32(240)), pcre_uint16(int32(240)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(114)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(240)), pcre_uint16(int32(114)), pcre_uint16(int32(240)), pcre_uint16(int32(240)), pcre_uint16(int32(239)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(241)), pcre_uint16(int32(241)), pcre_uint16(int32(239)), pcre_uint16(int32(239)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(242)), pcre_uint16(int32(243)), pcre_uint16(int32(244)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(245)), pcre_uint16(int32(246)), pcre_uint16(int32(246)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(245)), pcre_uint16(int32(247)), pcre_uint16(int32(248)), pcre_uint16(int32(245)), pcre_uint16(int32(246)), pcre_uint16(int32(245)), pcre_uint16(int32(245)), pcre_uint16(int32(245)), pcre_uint16(int32(245)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(246)), pcre_uint16(int32(246)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(246)), pcre_uint16(int32(246)), pcre_uint16(int32(245)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(245)), pcre_uint16(int32(248)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(114)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(247)), pcre_uint16(int32(245)), pcre_uint16(int32(245)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(249)), pcre_uint16(int32(250)), pcre_uint16(int32(247)), pcre_uint16(int32(251)), pcre_uint16(int32(251)), pcre_uint16(int32(251)), pcre_uint16(int32(251)), pcre_uint16(int32(251)), pcre_uint16(int32(251)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(252)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(254)), pcre_uint16(int32(255)), pcre_uint16(int32(252)), pcre_uint16(int32(255)), pcre_uint16(int32(255)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(255)), pcre_uint16(int32(255)), pcre_uint16(int32(255)), pcre_uint16(int32(114)), pcre_uint16(int32(255)), pcre_uint16(int32(255)), pcre_uint16(int32(255)), pcre_uint16(int32(252)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(253)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(254)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(256)), pcre_uint16(int32(257)), pcre_uint16(int32(257)), pcre_uint16(int32(257)), pcre_uint16(int32(258)), pcre_uint16(int32(258)), pcre_uint16(int32(258)), pcre_uint16(int32(258)), pcre_uint16(int32(258)), pcre_uint16(int32(258)), pcre_uint16(int32(259)), pcre_uint16(int32(258)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(260)), pcre_uint16(int32(261)), pcre_uint16(int32(261)), pcre_uint16(int32(261)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(261)), pcre_uint16(int32(261)), pcre_uint16(int32(261)), pcre_uint16(int32(261)), pcre_uint16(int32(114)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(114)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(262)), pcre_uint16(int32(262)), pcre_uint16(int32(260)), pcre_uint16(int32(260)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(263)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(264)), pcre_uint16(int32(265)), pcre_uint16(int32(114)), pcre_uint16(int32(266)), pcre_uint16(int32(267)), pcre_uint16(int32(267)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(266)), pcre_uint16(int32(268)), pcre_uint16(int32(267)), pcre_uint16(int32(266)), pcre_uint16(int32(267)), pcre_uint16(int32(267)), pcre_uint16(int32(269)), pcre_uint16(int32(267)), pcre_uint16(int32(267)), pcre_uint16(int32(114)), pcre_uint16(int32(266)), pcre_uint16(int32(267)), pcre_uint16(int32(267)), pcre_uint16(int32(114)), pcre_uint16(int32(267)), pcre_uint16(int32(267)), pcre_uint16(int32(266)), pcre_uint16(int32(266)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(269)), pcre_uint16(int32(269)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(266)), pcre_uint16(int32(266)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(270)), pcre_uint16(int32(114)), pcre_uint16(int32(268)), pcre_uint16(int32(268)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(271)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(114)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(114)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(114)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(273)), pcre_uint16(int32(274)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(271)), pcre_uint16(int32(271)), pcre_uint16(int32(271)), pcre_uint16(int32(271)), pcre_uint16(int32(114)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(114)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(272)), pcre_uint16(int32(271)), pcre_uint16(int32(273)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(274)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(271)), pcre_uint16(int32(271)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(275)), pcre_uint16(int32(276)), pcre_uint16(int32(276)), pcre_uint16(int32(276)), pcre_uint16(int32(276)), pcre_uint16(int32(276)), pcre_uint16(int32(276)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(277)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(273)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(114)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(114)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(114)), pcre_uint16(int32(279)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(279)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(280)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(281)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(280)), pcre_uint16(int32(280)), pcre_uint16(int32(280)), pcre_uint16(int32(114)), pcre_uint16(int32(280)), pcre_uint16(int32(114)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(281)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(282)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(278)), pcre_uint16(int32(278)), pcre_uint16(int32(283)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(285)), pcre_uint16(int32(284)), pcre_uint16(int32(286)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(5)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(284)), pcre_uint16(int32(287)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(285)), pcre_uint16(int32(288)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(289)), pcre_uint16(int32(288)), pcre_uint16(int32(288)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(291)), pcre_uint16(int32(290)), pcre_uint16(int32(292)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(114)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(293)), pcre_uint16(int32(114)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(291)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(294)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(290)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(295)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(296)), pcre_uint16(int32(297)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(299)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(300)), pcre_uint16(int32(296)), pcre_uint16(int32(298)), pcre_uint16(int32(296)), pcre_uint16(int32(298)), pcre_uint16(int32(296)), pcre_uint16(int32(298)), pcre_uint16(int32(301)), pcre_uint16(int32(302)), pcre_uint16(int32(301)), pcre_uint16(int32(302)), pcre_uint16(int32(303)), pcre_uint16(int32(303)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(114)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(303)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(297)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(295)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(114)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(298)), pcre_uint16(int32(114)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(298)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(114)), pcre_uint16(int32(296)), pcre_uint16(int32(296)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(297)), pcre_uint16(int32(297)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(307)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(305)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(307)), pcre_uint16(int32(307)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(304)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(309)), pcre_uint16(int32(309)), pcre_uint16(int32(309)), pcre_uint16(int32(309)), pcre_uint16(int32(309)), pcre_uint16(int32(309)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(307)), pcre_uint16(int32(307)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(304)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(306)), pcre_uint16(int32(305)), pcre_uint16(int32(307)), pcre_uint16(int32(306)), pcre_uint16(int32(306)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(306)), pcre_uint16(int32(304)), pcre_uint16(int32(305)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(305)), pcre_uint16(int32(306)), pcre_uint16(int32(310)), pcre_uint16(int32(310)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(311)), pcre_uint16(int32(114)), pcre_uint16(int32(311)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(311)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(4)), pcre_uint16(int32(313)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(312)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(318)), pcre_uint16(int32(318)), pcre_uint16(int32(318)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(319)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(320)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(321)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(322)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(323)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(325)), pcre_uint16(int32(325)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(326)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(327)), pcre_uint16(int32(328)), pcre_uint16(int32(329)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(331)), pcre_uint16(int32(331)), pcre_uint16(int32(331)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(330)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(114)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(332)), pcre_uint16(int32(333)), pcre_uint16(int32(333)), pcre_uint16(int32(333)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(334)), pcre_uint16(int32(335)), pcre_uint16(int32(335)), pcre_uint16(int32(335)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(336)), pcre_uint16(int32(337)), pcre_uint16(int32(337)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(114)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(338)), pcre_uint16(int32(114)), pcre_uint16(int32(339)), pcre_uint16(int32(339)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(340)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(342)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(341)), pcre_uint16(int32(342)), pcre_uint16(int32(342)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(341)), pcre_uint16(int32(343)), pcre_uint16(int32(343)), pcre_uint16(int32(343)), pcre_uint16(int32(344)), pcre_uint16(int32(343)), pcre_uint16(int32(343)), pcre_uint16(int32(343)), pcre_uint16(int32(345)), pcre_uint16(int32(340)), pcre_uint16(int32(341)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(346)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(347)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(348)), pcre_uint16(int32(348)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(348)), pcre_uint16(int32(4)), pcre_uint16(int32(349)), pcre_uint16(int32(348)), pcre_uint16(int32(348)), pcre_uint16(int32(348)), pcre_uint16(int32(348)), pcre_uint16(int32(350)), pcre_uint16(int32(350)), pcre_uint16(int32(350)), pcre_uint16(int32(351)), pcre_uint16(int32(114)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(352)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(354)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(353)), pcre_uint16(int32(350)), pcre_uint16(int32(353)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(324)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(355)), pcre_uint16(int32(114)), pcre_uint16(int32(356)), pcre_uint16(int32(356)), pcre_uint16(int32(356)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(356)), pcre_uint16(int32(356)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(356)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(357)), pcre_uint16(int32(356)), pcre_uint16(int32(356)), pcre_uint16(int32(356)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(358)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(359)), pcre_uint16(int32(359)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(360)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(361)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(364)), pcre_uint16(int32(364)), pcre_uint16(int32(364)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(364)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(362)), pcre_uint16(int32(363)), pcre_uint16(int32(363)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(365)), pcre_uint16(int32(366)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(367)), pcre_uint16(int32(367)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(368)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(369)), pcre_uint16(int32(370)), pcre_uint16(int32(370)), pcre_uint16(int32(371)), pcre_uint16(int32(371)), pcre_uint16(int32(370)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(372)), pcre_uint16(int32(372)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(373)), pcre_uint16(int32(374)), pcre_uint16(int32(375)), pcre_uint16(int32(374)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(114)), pcre_uint16(int32(375)), pcre_uint16(int32(376)), pcre_uint16(int32(375)), pcre_uint16(int32(376)), pcre_uint16(int32(376)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(374)), pcre_uint16(int32(374)), pcre_uint16(int32(374)), pcre_uint16(int32(374)), pcre_uint16(int32(374)), pcre_uint16(int32(374)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(375)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(375)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(377)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(379)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(378)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(380)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(382)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(381)), pcre_uint16(int32(382)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(382)), pcre_uint16(int32(381)), pcre_uint16(int32(382)), pcre_uint16(int32(382)), pcre_uint16(int32(382)), pcre_uint16(int32(382)), pcre_uint16(int32(382)), pcre_uint16(int32(381)), pcre_uint16(int32(382)), pcre_uint16(int32(382)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(383)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(384)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(385)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(381)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(386)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(388)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(388)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(388)), pcre_uint16(int32(388)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(388)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(387)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(390)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(389)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(391)), pcre_uint16(int32(392)), pcre_uint16(int32(393)), pcre_uint16(int32(392)), pcre_uint16(int32(392)), pcre_uint16(int32(393)), pcre_uint16(int32(393)), pcre_uint16(int32(393)), pcre_uint16(int32(392)), pcre_uint16(int32(393)), pcre_uint16(int32(392)), pcre_uint16(int32(392)), pcre_uint16(int32(392)), pcre_uint16(int32(393)), pcre_uint16(int32(393)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(394)), pcre_uint16(int32(394)), pcre_uint16(int32(394)), pcre_uint16(int32(394)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(396)), pcre_uint16(int32(396)), pcre_uint16(int32(397)), pcre_uint16(int32(397)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(398)), pcre_uint16(int32(398)), pcre_uint16(int32(398)), pcre_uint16(int32(398)), pcre_uint16(int32(398)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(399)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(395)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(400)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(401)), pcre_uint16(int32(402)), pcre_uint16(int32(402)), pcre_uint16(int32(402)), pcre_uint16(int32(402)), pcre_uint16(int32(402)), pcre_uint16(int32(402)), pcre_uint16(int32(403)), pcre_uint16(int32(403)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(404)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(4)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(405)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(109)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(405)), pcre_uint16(int32(405)), pcre_uint16(int32(109)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(407)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(115)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(408)), pcre_uint16(int32(409)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(410)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(115)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(411)), pcre_uint16(int32(412)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(413)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(414)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(415)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(114)), pcre_uint16(int32(416)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(417)), pcre_uint16(int32(417)), pcre_uint16(int32(418)), pcre_uint16(int32(418)), pcre_uint16(int32(418)), pcre_uint16(int32(418)), pcre_uint16(int32(419)), pcre_uint16(int32(419)), pcre_uint16(int32(420)), pcre_uint16(int32(420)), pcre_uint16(int32(421)), pcre_uint16(int32(421)), pcre_uint16(int32(422)), pcre_uint16(int32(422)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(423)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(424)), pcre_uint16(int32(122)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(425)), pcre_uint16(int32(425)), pcre_uint16(int32(426)), pcre_uint16(int32(113)), pcre_uint16(int32(427)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(122)), pcre_uint16(int32(424)), pcre_uint16(int32(122)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(428)), pcre_uint16(int32(428)), pcre_uint16(int32(428)), pcre_uint16(int32(428)), pcre_uint16(int32(426)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(429)), pcre_uint16(int32(429)), pcre_uint16(int32(114)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(415)), pcre_uint16(int32(415)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(163)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(416)), pcre_uint16(int32(416)), pcre_uint16(int32(430)), pcre_uint16(int32(430)), pcre_uint16(int32(168)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(424)), pcre_uint16(int32(122)), pcre_uint16(int32(114)), pcre_uint16(int32(122)), pcre_uint16(int32(122)), pcre_uint16(int32(431)), pcre_uint16(int32(431)), pcre_uint16(int32(432)), pcre_uint16(int32(432)), pcre_uint16(int32(426)), pcre_uint16(int32(113)), pcre_uint16(int32(113)), pcre_uint16(int32(114)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(3)), pcre_uint16(int32(22)), pcre_uint16(int32(433)), pcre_uint16(int32(433)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(6)), pcre_uint16(int32(21)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(6)), pcre_uint16(int32(21)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(434)), pcre_uint16(int32(435)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(3)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(15)), pcre_uint16(int32(15)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(4)), pcre_uint16(int32(15)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(3)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(436)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(23)), pcre_uint16(int32(106)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(106)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(114)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(380)), pcre_uint16(int32(380)), pcre_uint16(int32(380)), pcre_uint16(int32(380)), pcre_uint16(int32(109)), pcre_uint16(int32(380)), pcre_uint16(int32(380)), pcre_uint16(int32(380)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(19)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(439)), pcre_uint16(int32(19)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(440)), pcre_uint16(int32(441)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(19)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(442)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(406)), pcre_uint16(int32(438)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(443)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(444)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(445)), pcre_uint16(int32(446)), pcre_uint16(int32(446)), pcre_uint16(int32(446)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(446)), pcre_uint16(int32(446)), pcre_uint16(int32(446)), pcre_uint16(int32(446)), pcre_uint16(int32(23)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(447)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(448)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(449)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(450)), pcre_uint16(int32(114)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(451)), pcre_uint16(int32(114)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(452)), pcre_uint16(int32(453)), pcre_uint16(int32(454)), pcre_uint16(int32(455)), pcre_uint16(int32(456)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(457)), pcre_uint16(int32(458)), pcre_uint16(int32(459)), pcre_uint16(int32(460)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(461)), pcre_uint16(int32(461)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(462)), pcre_uint16(int32(463)), pcre_uint16(int32(463)), pcre_uint16(int32(463)), pcre_uint16(int32(463)), pcre_uint16(int32(463)), pcre_uint16(int32(463)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(464)), pcre_uint16(int32(464)), pcre_uint16(int32(464)), pcre_uint16(int32(159)), pcre_uint16(int32(160)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(465)), pcre_uint16(int32(465)), pcre_uint16(int32(465)), pcre_uint16(int32(465)), pcre_uint16(int32(466)), pcre_uint16(int32(465)), pcre_uint16(int32(465)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(467)), pcre_uint16(int32(114)), pcre_uint16(int32(467)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(467)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(468)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(469)), pcre_uint16(int32(470)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(471)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(21)), pcre_uint16(int32(25)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(107)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(114)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(472)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(3)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(19)), pcre_uint16(int32(473)), pcre_uint16(int32(406)), pcre_uint16(int32(474)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(9)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(7)), pcre_uint16(int32(19)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(475)), pcre_uint16(int32(475)), pcre_uint16(int32(9)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(474)), pcre_uint16(int32(473)), pcre_uint16(int32(406)), pcre_uint16(int32(4)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(476)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(477)), pcre_uint16(int32(477)), pcre_uint16(int32(476)), pcre_uint16(int32(9)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(4)), pcre_uint16(int32(107)), pcre_uint16(int32(479)), pcre_uint16(int32(479)), pcre_uint16(int32(478)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(480)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(482)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(114)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(483)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(486)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(485)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(487)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(488)), pcre_uint16(int32(489)), pcre_uint16(int32(489)), pcre_uint16(int32(489)), pcre_uint16(int32(489)), pcre_uint16(int32(489)), pcre_uint16(int32(489)), pcre_uint16(int32(490)), pcre_uint16(int32(490)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(492)), pcre_uint16(int32(493)), pcre_uint16(int32(493)), pcre_uint16(int32(493)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(494)), pcre_uint16(int32(491)), pcre_uint16(int32(491)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(495)), pcre_uint16(int32(177)), pcre_uint16(int32(178)), pcre_uint16(int32(178)), pcre_uint16(int32(178)), pcre_uint16(int32(496)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(177)), pcre_uint16(int32(496)), pcre_uint16(int32(408)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(174)), pcre_uint16(int32(175)), pcre_uint16(int32(408)), pcre_uint16(int32(408)), pcre_uint16(int32(114)), pcre_uint16(int32(177)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(498)), pcre_uint16(int32(499)), pcre_uint16(int32(499)), pcre_uint16(int32(500)), pcre_uint16(int32(500)), pcre_uint16(int32(500)), pcre_uint16(int32(500)), pcre_uint16(int32(500)), pcre_uint16(int32(500)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(106)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(501)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(107)), pcre_uint16(int32(14)), pcre_uint16(int32(14)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(502)), pcre_uint16(int32(33)), pcre_uint16(int32(114)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(30)), pcre_uint16(int32(31)), pcre_uint16(int32(503)), pcre_uint16(int32(504)), pcre_uint16(int32(505)), pcre_uint16(int32(506)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(507)), pcre_uint16(int32(508)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(20)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(33)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(20)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(510)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(510)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(510)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(509)), pcre_uint16(int32(511)), pcre_uint16(int32(511)), pcre_uint16(int32(510)), pcre_uint16(int32(510)), pcre_uint16(int32(511)), pcre_uint16(int32(512)), pcre_uint16(int32(512)), pcre_uint16(int32(512)), pcre_uint16(int32(512)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(5)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(513)), pcre_uint16(int32(514)), pcre_uint16(int32(514)), pcre_uint16(int32(514)), pcre_uint16(int32(514)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(516)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(515)), pcre_uint16(int32(517)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(518)), pcre_uint16(int32(518)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(519)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(221)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(223)), pcre_uint16(int32(225)), pcre_uint16(int32(225)), pcre_uint16(int32(225)), pcre_uint16(int32(223)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(520)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(521)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(522)), pcre_uint16(int32(4)), pcre_uint16(int32(523)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(524)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(525)), pcre_uint16(int32(526)), pcre_uint16(int32(526)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(527)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(314)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(528)), pcre_uint16(int32(528)), pcre_uint16(int32(528)), pcre_uint16(int32(529)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(530)), pcre_uint16(int32(528)), pcre_uint16(int32(529)), pcre_uint16(int32(529)), pcre_uint16(int32(528)), pcre_uint16(int32(528)), pcre_uint16(int32(528)), pcre_uint16(int32(528)), pcre_uint16(int32(529)), pcre_uint16(int32(529)), pcre_uint16(int32(528)), pcre_uint16(int32(529)), pcre_uint16(int32(529)), pcre_uint16(int32(529)), pcre_uint16(int32(529)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(114)), pcre_uint16(int32(107)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(532)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(531)), pcre_uint16(int32(531)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(306)), pcre_uint16(int32(533)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(308)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(114)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(536)), pcre_uint16(int32(536)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(536)), pcre_uint16(int32(536)), pcre_uint16(int32(535)), pcre_uint16(int32(535)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(535)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(534)), pcre_uint16(int32(535)), pcre_uint16(int32(536)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(537)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(538)), pcre_uint16(int32(538)), pcre_uint16(int32(538)), pcre_uint16(int32(538)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(533)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(310)), pcre_uint16(int32(310)), pcre_uint16(int32(310)), pcre_uint16(int32(304)), pcre_uint16(int32(305)), pcre_uint16(int32(306)), pcre_uint16(int32(305)), pcre_uint16(int32(304)), pcre_uint16(int32(304)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(540)), pcre_uint16(int32(539)), pcre_uint16(int32(540)), pcre_uint16(int32(540)), pcre_uint16(int32(540)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(540)), pcre_uint16(int32(540)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(540)), pcre_uint16(int32(540)), pcre_uint16(int32(539)), pcre_uint16(int32(540)), pcre_uint16(int32(539)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(539)), pcre_uint16(int32(539)), pcre_uint16(int32(541)), pcre_uint16(int32(542)), pcre_uint16(int32(542)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(544)), pcre_uint16(int32(545)), pcre_uint16(int32(545)), pcre_uint16(int32(544)), pcre_uint16(int32(544)), pcre_uint16(int32(546)), pcre_uint16(int32(546)), pcre_uint16(int32(543)), pcre_uint16(int32(547)), pcre_uint16(int32(547)), pcre_uint16(int32(544)), pcre_uint16(int32(545)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(317)), pcre_uint16(int32(114)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(14)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(106)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(33)), pcre_uint16(int32(122)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(543)), pcre_uint16(int32(544)), pcre_uint16(int32(544)), pcre_uint16(int32(545)), pcre_uint16(int32(544)), pcre_uint16(int32(544)), pcre_uint16(int32(545)), pcre_uint16(int32(544)), pcre_uint16(int32(544)), pcre_uint16(int32(546)), pcre_uint16(int32(544)), pcre_uint16(int32(545)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(548)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(549)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(550)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(315)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(316)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(551)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(33)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(185)), pcre_uint16(int32(185)), pcre_uint16(int32(185)), pcre_uint16(int32(185)), pcre_uint16(int32(185)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(189)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(553)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(114)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(192)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(554)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(196)), pcre_uint16(int32(197)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(9)), pcre_uint16(int32(15)), pcre_uint16(int32(15)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(15)), pcre_uint16(int32(15)), pcre_uint16(int32(15)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(9)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(5)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(22)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(5)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(4)), pcre_uint16(int32(9)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(11)), pcre_uint16(int32(6)), pcre_uint16(int32(4)), pcre_uint16(int32(7)), pcre_uint16(int32(14)), pcre_uint16(int32(15)), pcre_uint16(int32(14)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(16)), pcre_uint16(int32(6)), pcre_uint16(int32(8)), pcre_uint16(int32(7)), pcre_uint16(int32(8)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(6)), pcre_uint16(int32(7)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(107)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(478)), pcre_uint16(int32(555)), pcre_uint16(int32(555)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(481)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(8)), pcre_uint16(int32(14)), pcre_uint16(int32(19)), pcre_uint16(int32(5)), pcre_uint16(int32(5)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(8)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(556)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(4)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(557)), pcre_uint16(int32(558)), pcre_uint16(int32(558)), pcre_uint16(int32(558)), pcre_uint16(int32(558)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(558)), pcre_uint16(int32(558)), pcre_uint16(int32(559)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(559)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(109)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(560)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(561)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(109)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(562)), pcre_uint16(int32(563)), pcre_uint16(int32(563)), pcre_uint16(int32(563)), pcre_uint16(int32(563)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(565)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(564)), pcre_uint16(int32(565)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(566)), pcre_uint16(int32(567)), pcre_uint16(int32(567)), pcre_uint16(int32(567)), pcre_uint16(int32(567)), pcre_uint16(int32(567)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(568)), pcre_uint16(int32(114)), pcre_uint16(int32(569)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(570)), pcre_uint16(int32(571)), pcre_uint16(int32(572)), pcre_uint16(int32(572)), pcre_uint16(int32(572)), pcre_uint16(int32(572)), pcre_uint16(int32(572)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(573)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(574)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(575)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(576)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(577)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(578)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(579)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(580)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(581)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(582)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(582)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(583)), pcre_uint16(int32(114)), pcre_uint16(int32(584)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(585)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(586)), pcre_uint16(int32(587)), pcre_uint16(int32(587)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(588)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(589)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(590)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(591)), pcre_uint16(int32(592)), pcre_uint16(int32(592)), pcre_uint16(int32(592)), pcre_uint16(int32(592)), pcre_uint16(int32(592)), pcre_uint16(int32(592)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(593)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(594)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(595)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(596)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(597)), pcre_uint16(int32(597)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(598)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(114)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(114)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(114)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(598)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(599)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(599)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(600)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(601)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(602)), pcre_uint16(int32(603)), pcre_uint16(int32(603)), pcre_uint16(int32(604)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(605)), pcre_uint16(int32(606)), pcre_uint16(int32(606)), pcre_uint16(int32(606)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(608)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(607)), pcre_uint16(int32(609)), pcre_uint16(int32(609)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(610)), pcre_uint16(int32(610)), pcre_uint16(int32(610)), pcre_uint16(int32(610)), pcre_uint16(int32(610)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(611)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(612)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(613)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(614)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(615)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(616)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(617)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(618)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(619)), pcre_uint16(int32(619)), pcre_uint16(int32(619)), pcre_uint16(int32(619)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(620)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(621)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(622)), pcre_uint16(int32(114)), pcre_uint16(int32(623)), pcre_uint16(int32(624)), pcre_uint16(int32(623)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(625)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(624)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(626)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(627)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(628)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(624)), pcre_uint16(int32(629)), pcre_uint16(int32(629)), pcre_uint16(int32(630)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(631)), pcre_uint16(int32(630)), pcre_uint16(int32(630)), pcre_uint16(int32(630)), pcre_uint16(int32(629)), pcre_uint16(int32(629)), pcre_uint16(int32(629)), pcre_uint16(int32(629)), pcre_uint16(int32(630)), pcre_uint16(int32(630)), pcre_uint16(int32(629)), pcre_uint16(int32(629)), pcre_uint16(int32(632)), pcre_uint16(int32(632)), pcre_uint16(int32(633)), pcre_uint16(int32(632)), pcre_uint16(int32(632)), pcre_uint16(int32(632)), pcre_uint16(int32(632)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(634)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(635)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(637)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(638)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(636)), pcre_uint16(int32(114)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(639)), pcre_uint16(int32(640)), pcre_uint16(int32(640)), pcre_uint16(int32(640)), pcre_uint16(int32(640)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(641)), pcre_uint16(int32(642)), pcre_uint16(int32(643)), pcre_uint16(int32(643)), pcre_uint16(int32(641)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(645)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(645)), pcre_uint16(int32(645)), pcre_uint16(int32(645)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(644)), pcre_uint16(int32(645)), pcre_uint16(int32(645)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(646)), pcre_uint16(int32(647)), pcre_uint16(int32(647)), pcre_uint16(int32(647)), pcre_uint16(int32(647)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(647)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(648)), pcre_uint16(int32(646)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(649)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(114)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(650)), pcre_uint16(int32(651)), pcre_uint16(int32(651)), pcre_uint16(int32(651)), pcre_uint16(int32(652)), pcre_uint16(int32(652)), pcre_uint16(int32(652)), pcre_uint16(int32(651)), pcre_uint16(int32(651)), pcre_uint16(int32(652)), pcre_uint16(int32(651)), pcre_uint16(int32(652)), pcre_uint16(int32(652)), pcre_uint16(int32(653)), pcre_uint16(int32(653)), pcre_uint16(int32(653)), pcre_uint16(int32(653)), pcre_uint16(int32(653)), pcre_uint16(int32(653)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(654)), pcre_uint16(int32(655)), pcre_uint16(int32(656)), pcre_uint16(int32(656)), pcre_uint16(int32(656)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(655)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(657)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(658)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(658)), pcre_uint16(int32(660)), pcre_uint16(int32(661)), pcre_uint16(int32(659)), pcre_uint16(int32(658)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(661)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(660)), pcre_uint16(int32(659)), pcre_uint16(int32(659)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(658)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(663)), pcre_uint16(int32(664)), pcre_uint16(int32(664)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(664)), pcre_uint16(int32(665)), pcre_uint16(int32(664)), pcre_uint16(int32(664)), pcre_uint16(int32(663)), pcre_uint16(int32(664)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(664)), pcre_uint16(int32(665)), pcre_uint16(int32(665)), pcre_uint16(int32(662)), pcre_uint16(int32(662)), pcre_uint16(int32(666)), pcre_uint16(int32(662)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(667)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(668)), pcre_uint16(int32(669)), pcre_uint16(int32(670)), pcre_uint16(int32(670)), pcre_uint16(int32(671)), pcre_uint16(int32(671)), pcre_uint16(int32(671)), pcre_uint16(int32(671)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(670)), pcre_uint16(int32(670)), pcre_uint16(int32(670)), pcre_uint16(int32(670)), pcre_uint16(int32(671)), pcre_uint16(int32(671)), pcre_uint16(int32(670)), pcre_uint16(int32(671)), pcre_uint16(int32(671)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(672)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(673)), pcre_uint16(int32(674)), pcre_uint16(int32(674)), pcre_uint16(int32(674)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(674)), pcre_uint16(int32(674)), pcre_uint16(int32(675)), pcre_uint16(int32(674)), pcre_uint16(int32(675)), pcre_uint16(int32(675)), pcre_uint16(int32(676)), pcre_uint16(int32(676)), pcre_uint16(int32(676)), pcre_uint16(int32(673)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(677)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(678)), pcre_uint16(int32(679)), pcre_uint16(int32(680)), pcre_uint16(int32(679)), pcre_uint16(int32(680)), pcre_uint16(int32(680)), pcre_uint16(int32(679)), pcre_uint16(int32(679)), pcre_uint16(int32(679)), pcre_uint16(int32(679)), pcre_uint16(int32(679)), pcre_uint16(int32(679)), pcre_uint16(int32(680)), pcre_uint16(int32(679)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(681)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(682)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(683)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(684)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(685)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(686)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(687)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(688)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(689)), pcre_uint16(int32(114)), pcre_uint16(int32(690)), pcre_uint16(int32(690)), pcre_uint16(int32(690)), pcre_uint16(int32(690)), pcre_uint16(int32(690)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(691)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(497)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(692)), pcre_uint16(int32(114)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(693)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(694)), pcre_uint16(int32(694)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(695)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(696)), pcre_uint16(int32(696)), pcre_uint16(int32(696)), pcre_uint16(int32(696)), pcre_uint16(int32(696)), pcre_uint16(int32(697)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(699)), pcre_uint16(int32(700)), pcre_uint16(int32(700)), pcre_uint16(int32(700)), pcre_uint16(int32(700)), pcre_uint16(int32(700)), pcre_uint16(int32(701)), pcre_uint16(int32(701)), pcre_uint16(int32(701)), pcre_uint16(int32(701)), pcre_uint16(int32(702)), pcre_uint16(int32(702)), pcre_uint16(int32(702)), pcre_uint16(int32(702)), pcre_uint16(int32(700)), pcre_uint16(int32(701)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(703)), pcre_uint16(int32(114)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(704)), pcre_uint16(int32(114)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(698)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(705)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(705)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(706)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(707)), pcre_uint16(int32(707)), pcre_uint16(int32(707)), pcre_uint16(int32(707)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(708)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(478)), pcre_uint16(int32(476)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(709)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(710)), pcre_uint16(int32(711)), pcre_uint16(int32(711)), pcre_uint16(int32(712)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(713)), pcre_uint16(int32(405)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(405)), pcre_uint16(int32(713)), pcre_uint16(int32(713)), pcre_uint16(int32(713)), pcre_uint16(int32(713)), pcre_uint16(int32(713)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(559)), pcre_uint16(int32(714)), pcre_uint16(int32(714)), pcre_uint16(int32(714)), pcre_uint16(int32(559)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(114)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(437)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(8)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(438)), pcre_uint16(int32(437)), pcre_uint16(int32(438)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(10)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(715)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(716)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(717)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(199)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(194)), pcre_uint16(int32(194)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(23)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(718)), pcre_uint16(int32(719)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(19)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(484)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(114)), pcre_uint16(int32(436)), pcre_uint16(int32(22)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(22)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(109)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(436)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(552)), pcre_uint16(int32(114)), pcre_uint16(int32(114))}

// _pcre_valid_utf - transpiled function from  /root/Documents/pcre/pcre_valid_utf8.c:106
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2013 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains an internal function for validating UTF-8 character
strings. */ //
/*************************************************
*         Validate a UTF-8 string                *
*************************************************/ //
/* This function is called (optionally) at the start of compile or match, to
check that a supposed UTF-8 string is actually valid. The early check means
that subsequent code can assume it is dealing with a valid string. The check
can be turned off for maximum performance, but the consequences of supplying an
invalid string are then undefined.

Originally, this function checked according to RFC 2279, allowing for values in
the range 0 to 0x7fffffff, up to 6 bytes long, but ensuring that they were in
the canonical format. Once somebody had pointed out RFC 3629 to me (it
obsoletes 2279), additional restrictions were applied. The values are now
limited to be between 0 and 0x0010ffff, no more than 4 bytes long, and the
subrange 0xd000 to 0xdfff is excluded. However, the format of 5-byte and 6-byte
characters is still checked.

From release 8.13 more information about the details of the error are passed
back in the returned value:

PCRE_UTF8_ERR0   No error
PCRE_UTF8_ERR1   Missing 1 byte at the end of the string
PCRE_UTF8_ERR2   Missing 2 bytes at the end of the string
PCRE_UTF8_ERR3   Missing 3 bytes at the end of the string
PCRE_UTF8_ERR4   Missing 4 bytes at the end of the string
PCRE_UTF8_ERR5   Missing 5 bytes at the end of the string
PCRE_UTF8_ERR6   2nd-byte's two top bits are not 0x80
PCRE_UTF8_ERR7   3rd-byte's two top bits are not 0x80
PCRE_UTF8_ERR8   4th-byte's two top bits are not 0x80
PCRE_UTF8_ERR9   5th-byte's two top bits are not 0x80
PCRE_UTF8_ERR10  6th-byte's two top bits are not 0x80
PCRE_UTF8_ERR11  5-byte character is not permitted by RFC 3629
PCRE_UTF8_ERR12  6-byte character is not permitted by RFC 3629
PCRE_UTF8_ERR13  4-byte character with value > 0x10ffff is not permitted
PCRE_UTF8_ERR14  3-byte character with value 0xd000-0xdfff is not permitted
PCRE_UTF8_ERR15  Overlong 2-byte sequence
PCRE_UTF8_ERR16  Overlong 3-byte sequence
PCRE_UTF8_ERR17  Overlong 4-byte sequence
PCRE_UTF8_ERR18  Overlong 5-byte sequence (won't ever occur)
PCRE_UTF8_ERR19  Overlong 6-byte sequence (won't ever occur)
PCRE_UTF8_ERR20  Isolated 0x80 byte (not within UTF-8 character)
PCRE_UTF8_ERR21  Byte with the illegal value 0xfe or 0xff
PCRE_UTF8_ERR22  Unused (was non-character)

Arguments:
  string       points to the string
  length       length of string, or -1 if the string is zero-terminated
  errp         pointer to an error position offset variable

Returns:       = 0    if the string is a valid UTF-8 string
               > 0    otherwise, setting the offset of the bad character
*/ //
/* ASCII character */ //
/* Isolated 10xx xxxx byte */ //
/* Invalid 0xfe or 0xff bytes */ //
/* Number of additional bytes */ //
/* Missing bytes */ //
/* Codes ERR1 to ERR5 */ //
/* Length remaining */ //
/* Check top bits in the second byte */ //
/* For each length, check that the remaining bytes start with the 0x80 bit
set and not the 0x40 bit. Then check for an overlong sequence, and for the
excluded range 0xd800 to 0xdfff. */ //
/* 2-byte character. No further bytes to check for 0x80. Check first byte
   for for xx00 000x (overlong sequence). */ //
/* 3-byte character. Check third byte for 0x80. Then check first 2 bytes
   for 1110 0000, xx0x xxxx (overlong sequence) or
       1110 1101, 1010 xxxx (0xd800 - 0xdfff) */ //
/* Third byte */ //
/* 4-byte character. Check 3rd and 4th bytes for 0x80. Then check first 2
   bytes for for 1111 0000, xx00 xxxx (overlong sequence), then check for a
   character greater than 0x0010ffff (f4 8f bf bf) */ //
/* Third byte */ //
/* Fourth byte */ //
/* 5-byte and 6-byte characters are not allowed by RFC 3629, and will be
   rejected by the length test below. However, we do the appropriate tests
   here so that overlong sequences get diagnosed, and also in case there is
   ever an option for handling these larger code points. */ //
/* 5-byte character. Check 3rd, 4th, and 5th bytes for 0x80. Then check for
   1111 1000, xx00 0xxx */ //
/* Third byte */ //
/* Fourth byte */ //
/* Fifth byte */ //
/* 6-byte character. Check 3rd-6th bytes for 0x80. Then check for
   1111 1100, xx00 00xx. */ //
/* Third byte */ //
/* Fourth byte */ //
/* Fifth byte */ //
/* Sixth byte */ //
/* Character is valid under RFC 2279, but 4-byte and 5-byte characters are
excluded by RFC 3629. The pointer p is currently at the last byte of the
character. */ //
/* This indicates success */ //
//
func _pcre_valid_utf(string *pcre_uchar, length int32, erroroffset *int32) int32 {
	var p *pcre_uchar
	if length < int32(0) {
		for p = string; int32(uint8((*p))) != int32(0); p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p)))) {
		}
		length = (int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string))))))
	}
	for p = string; func() int32 {
		defer func() {
			length -= 1
		}()
		return length
	}() > int32(0); p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p)))) {
		var ab pcre_uchar
		var c pcre_uchar
		var d pcre_uchar
		c = *p
		if int32(uint8((c))) < int32(128) {
			continue
		}
		if int32(uint8((c))) < int32(192) {
			*erroroffset = (int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string))))))
			return int32(20)
		}
		if int32(uint8((c))) >= int32(254) {
			*erroroffset = (int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string))))))
			return int32(21)
		}
		ab = pcre_uchar((uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := &_pcre_utf8_table4[0]
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint8((c)))&int32(63)))*unsafe.Sizeof(*tempVar))
		}()))))))
		if length < int32(uint8((ab))) {
			*erroroffset = (int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string))))))
			return (int32(uint8((ab))) - length)
		}
		length -= int32(uint8((ab)))
		if (int32(uint8((func() pcre_uchar {
			tempVar := *func() *pcre_uchar {
				p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
				return p
			}()
			d = tempVar
			return tempVar
		}()))) & int32(192)) != int32(128) {
			*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(1))
			return int32(6)
		}
		switch int32(uint8((pcre_uchar(ab)))) {
		case int32(1):
			{
				if (int32(uint8((c))) & int32(62)) == int32(0) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(1))
					return int32(15)
				}
			}
		case int32(2):
			{
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(7)
				}
				if (int32(uint8((c))) == int32(224)) && ((int32(uint8((d))) & int32(32)) == int32(0)) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(16)
				}
				if (int32(uint8((c))) == int32(237)) && (int32(uint8((d))) >= int32(160)) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(14)
				}
			}
		case int32(3):
			{
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(7)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(3))
					return int32(8)
				}
				if (int32(uint8((c))) == int32(240)) && ((int32(uint8((d))) & int32(48)) == int32(0)) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(3))
					return int32(17)
				}
				if (int32(uint8((c))) > int32(244)) || ((int32(uint8((c))) == int32(244)) && (int32(uint8((d))) > int32(143))) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(3))
					return int32(13)
				}
			}
		case int32(4):
			{
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(7)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(3))
					return int32(8)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(4))
					return int32(9)
				}
				if (int32(uint8((c))) == int32(248)) && ((int32(uint8((d))) & int32(56)) == int32(0)) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(4))
					return int32(18)
				}
			}
		case int32(5):
			{
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(2))
					return int32(7)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(3))
					return int32(8)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(4))
					return int32(9)
				}
				if (int32(uint8((*func() *pcre_uchar {
					p = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + (uintptr)(1)*unsafe.Sizeof(*p))))
					return p
				}()))) & int32(192)) != int32(128) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(5))
					return int32(10)
				}
				if (int32(uint8((c))) == int32(252)) && ((int32(uint8((d))) & int32(60)) == int32(0)) {
					*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(5))
					return int32(19)
				}
				break
			}
		}
		if int32(uint8((ab))) > int32(3) {
			*erroroffset = ((int32((int64(uintptr(unsafe.Pointer(p))) - int64(uintptr(unsafe.Pointer(string)))))) - int32(uint8((ab))))
			return func() int32 {
				if (map[bool]int32{false: 0, true: 1}[(int32(uint8((ab))) == int32(4))]) != 0 {
					return int32(11)
				} else {
					return int32(12)
				}
			}()
		}
	}
	return int32(0)
}

// pcre_version - transpiled function from  /root/Documents/pcre/pcre_version.c:83
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2012 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains the external function pcre_version(), which returns a
string that identifies the PCRE version that is in use. */ //
/*************************************************
*          Return version string                 *
*************************************************/ //
/* These macros are the standard way of turning unquoted text into C strings.
They allow macros like PCRE_MAJOR to be defined without quotes, which is
convenient for user programs that want to test its value. */ //
/* A problem turned up with PCRE_PRERELEASE, which is defined empty for
production releases. Originally, it was used naively in this code:

  return XSTRING(PCRE_MAJOR)
         "." XSTRING(PCRE_MINOR)
             XSTRING(PCRE_PRERELEASE)
         " " XSTRING(PCRE_DATE);

However, when PCRE_PRERELEASE is empty, this leads to an attempted expansion of
STRING(). The C standard states: "If (before argument substitution) any
argument consists of no preprocessing tokens, the behavior is undefined." It
turns out the gcc treats this case as a single empty string - which is what we
really want - but Visual C grumbles about the lack of an argument for the
macro. Unfortunately, both are within their rights. To cope with both ways of
handling this, I had resort to some messy hackery that does a test at run time.
I could find no way of detecting that a macro is defined as an empty string at
pre-processor time. This hack uses a standard trick for avoiding calling
the STRING macro with an empty argument when doing the test. */ //
//
func pcre_version() *byte {
	return func() *byte {
		if (map[bool]int32{false: 0, true: 1}[(int32(*((*byte)(func() unsafe.Pointer {
			tempVar := (&[]byte("Z\x00")[0])
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(1))*unsafe.Sizeof(*tempVar))
		}()))) == int32(0))]) != 0 {
			return (&[]byte("8.42 2018-03-20\x00")[0])
		} else {
			return (&[]byte("8.422018-03-20\x00")[0])
		}
	}()
}

// _pcre_xclass - transpiled function from  /root/Documents/pcre/pcre_xclass.c:66
/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2013 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* This module contains an internal function that is used to match an extended
class. It is used by both pcre_exec() and pcre_def_exec(). */ //
/*************************************************
*       Match character against an XCLASS        *
*************************************************/ //
/* This function is called to match a character against an extended class that
might contain values > 255 and/or Unicode properties.

Arguments:
  c           the character
  data        points to the flag byte of the XCLASS data

Returns:      TRUE if character matches, else FALSE
*/ //
/* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */ //
/* Character values < 256 are matched against a bitmap, if one is present. If
not, we still carry on, because there may be ranges that start below 256 in the
additional data. */ //
/* char found */ //
/* First skip the bit map if present. Then match against the list of Unicode
properties or large chars or ranges that end with a large char. We won't ever
encounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */ //
/* macro generates multiple statements */ //
/* macro generates multiple statements */ //
/* macro generates multiple statements */ //
/* XCL_PROP & XCL_NOTPROP */ //
/* Perl space used to exclude VT, but from Perl 5.18 it is included,
   which means that Perl space and POSIX space are now identical. PCRE
   was changed at release 8.34. */ //
/* Perl space */ //
/* POSIX space */ //
/* The following three properties can occur only in an XCLASS, as there
   is no \p or \P coding for them. */ //
/* Graphic character. Implement this as not Z (space or separator) and
   not C (other), except for Cf (format) with a few exceptions. This seems
   to be what Perl does. The exceptional characters are:

   U+061C           Arabic Letter Mark
   U+180E           Mongolian Vowel Separator
   U+2066 - U+2069  Various "isolate"s
*/ //
/* Printable character: same as graphic, with the addition of Zs, i.e.
   not Zl and not Zp, and U+180E. */ //
/* Punctuation: all Unicode punctuation, plus ASCII characters that
   Unicode treats as symbols rather than punctuation, for Perl
   compatibility (these are $+<=>^`|~). */ //
/* This should never occur, but compilers may mutter if there is no
   default. */ //
/* char did not match */ //
//
func _pcre_xclass(c pcre_uint32, data *pcre_uchar, utf BOOL) BOOL {
	var t pcre_uchar
	var negated BOOL = BOOL((map[bool]int32{false: 0, true: 1}[((int32(uint8((*data))) & int32(1)) != int32(0))]))
	_ = BOOL(utf)
	utf = BOOL((int32(1)))
	if c < pcre_uint32((uint32(int32(256)))) {
		if (int32(uint8((*data))) & int32(4)) == int32(0) {
			if (int32(uint8((*data))) & int32(2)) == int32(0) {
				return BOOL(negated)
			}
			return BOOL((map[bool]int32{false: 0, true: 1}[((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
				tempVar := ((*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data)))))))
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
			}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0))]))
		}
		if ((int32(uint8((*data))) & int32(2)) != int32(0)) && ((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
			tempVar := ((*pcre_uint8)(unsafe.Pointer(((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data)))))))
			return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint32((c/pcre_uint32((uint32(int32(8))))))))*unsafe.Sizeof(*tempVar))
		}()))))) & (int32(1) << uint64(uint32((c & pcre_uint32((uint32(int32(7))))))))) != int32(0)) {
			return NotBOOL(BOOL(negated))
		}
	}
	if (int32(uint8((*func() *pcre_uchar {
		defer func() {
			data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
		}()
		return data
	}()))) & int32(2)) != int32(0) {
		data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32((uint32(int32(32))/1)))*unsafe.Sizeof(*data))))
	}
	for int32(uint8((func() pcre_uchar {
		tempVar := *func() *pcre_uchar {
			defer func() {
				data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
			}()
			return data
		}()
		t = tempVar
		return tempVar
	}()))) != int32(0) {
		var x pcre_uint32
		var y pcre_uint32
		if int32(uint8((t))) == int32(1) {
			if int32((BOOL(utf))) != 0 {
				x = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
				if x >= pcre_uint32((uint32(int32(192)))) {
					if (x & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						x = (((x & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
							}()
							return data
						}()))) & int32(63))))))
					} else if (x & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						x = ((((x & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))
					} else if (x & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						x = (((((x & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))
					} else if (x & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						x = ((((((x & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))
					} else {
						x = (((((((x & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(5))*unsafe.Sizeof(*data))))
					}
				}
			} else {
				x = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
			}
			if c == x {
				return NotBOOL(BOOL(negated))
			}
		} else if int32(uint8((t))) == int32(2) {
			if int32((BOOL(utf))) != 0 {
				x = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
				if x >= pcre_uint32((uint32(int32(192)))) {
					if (x & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						x = (((x & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
							}()
							return data
						}()))) & int32(63))))))
					} else if (x & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						x = ((((x & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))
					} else if (x & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						x = (((((x & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))
					} else if (x & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						x = ((((((x & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))
					} else {
						x = (((((((x & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(5))*unsafe.Sizeof(*data))))
					}
				}
				y = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
				if y >= pcre_uint32((uint32(int32(192)))) {
					if (y & pcre_uint32((uint32(int32(32))))) == pcre_uint32((uint32(int32(0)))) {
						y = (((y & pcre_uint32((uint32(int32(31))))) << uint64(int32(6))) | pcre_uint32((uint32((int32(uint8((*func() *pcre_uchar {
							defer func() {
								data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
							}()
							return data
						}()))) & int32(63))))))
					} else if (y & pcre_uint32((uint32(int32(16))))) == pcre_uint32((uint32(int32(0)))) {
						y = ((((y & pcre_uint32((uint32(int32(15))))) << uint64(int32(12))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))
					} else if (y & pcre_uint32((uint32(int32(8))))) == pcre_uint32((uint32(int32(0)))) {
						y = (((((y & pcre_uint32((uint32(int32(7))))) << uint64(int32(18))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))
					} else if (y & pcre_uint32((uint32(int32(4))))) == pcre_uint32((uint32(int32(0)))) {
						y = ((((((y & pcre_uint32((uint32(int32(3))))) << uint64(int32(24))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))
					} else {
						y = (((((((y & pcre_uint32((uint32(int32(1))))) << uint64(int32(30))) | pcre_uint32((uint32(((int32(uint8((*data))) & int32(63)) << uint64(int32(24))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(18))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(12))))))) | pcre_uint32((uint32(((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(3))*unsafe.Sizeof(*data))))))) & int32(63)) << uint64(int32(6))))))) | pcre_uint32((uint32((int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(4))*unsafe.Sizeof(*data))))))) & int32(63))))))
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(5))*unsafe.Sizeof(*data))))
					}
				}
			} else {
				x = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
				y = pcre_uint32((uint32(uint8((*func() *pcre_uchar {
					defer func() {
						data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(1)*unsafe.Sizeof(*data))))
					}()
					return data
				}())))))
			}
			if (c >= x) && (c <= y) {
				return NotBOOL(BOOL(negated))
			}
		} else {
			var prop *ucd_record = ((*ucd_record)(func() unsafe.Pointer {
				tempVar := &_pcre_ucd_records[0]
				return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint16((*((*pcre_uint16)(func() unsafe.Pointer {
					tempVar := &_pcre_ucd_stage2[0]
					return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(((int32(uint8((*((*pcre_uint8)(func() unsafe.Pointer {
						tempVar := &_pcre_ucd_stage1[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)((int32(uint32((pcre_uint32((c)))))/int32(128)))*unsafe.Sizeof(*tempVar))
					}())))))*int32(128))+(int32(uint32((pcre_uint32((c)))))%int32(128))))*unsafe.Sizeof(*tempVar))
				}()))))))*unsafe.Sizeof(*tempVar))
			}()))
			var isprop BOOL = BOOL((map[bool]int32{false: 0, true: 1}[(int32(uint8((t))) == int32(3))]))
			switch int32(uint8((pcre_uchar(*data)))) {
			case int32(0):
				{
					if int32((BOOL(isprop))) != 0 {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(1):
				{
					if (((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lu) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Ll)) || (int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Lt)) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(2):
				{
					if (uint32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) == uint32((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}()))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(3):
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) == int32(uint8((pcre_uint8((*prop).chartype))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(4):
				{
					if (int32(uint8((*((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(1))*unsafe.Sizeof(*data))))))) == int32(uint8((pcre_uint8((*prop).script))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(5):
				{
					if ((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_N))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(6):
				fallthrough
			case int32(7):
				{
					switch pcre_uint32(c) {
					case pcre_uint32('\t'):
						fallthrough
					case pcre_uint32(' '):
						fallthrough
					case pcre_uint32((uint8('\u00a0'))):
						fallthrough
					case pcre_uint32(int32(5760)):
						fallthrough
					case pcre_uint32(int32(6158)):
						fallthrough
					case pcre_uint32(int32(8192)):
						fallthrough
					case pcre_uint32(int32(8193)):
						fallthrough
					case pcre_uint32(int32(8194)):
						fallthrough
					case pcre_uint32(int32(8195)):
						fallthrough
					case pcre_uint32(int32(8196)):
						fallthrough
					case pcre_uint32(int32(8197)):
						fallthrough
					case pcre_uint32(int32(8198)):
						fallthrough
					case pcre_uint32(int32(8199)):
						fallthrough
					case pcre_uint32(int32(8200)):
						fallthrough
					case pcre_uint32(int32(8201)):
						fallthrough
					case pcre_uint32(int32(8202)):
						fallthrough
					case pcre_uint32(int32(8239)):
						fallthrough
					case pcre_uint32(int32(8287)):
						fallthrough
					case pcre_uint32(int32(12288)):
						fallthrough
					case pcre_uint32('\n'):
						fallthrough
					case pcre_uint32('\v'):
						fallthrough
					case pcre_uint32('\f'):
						fallthrough
					case pcre_uint32('\r'):
						fallthrough
					case pcre_uint32((uint8('\u0085'))):
						fallthrough
					case pcre_uint32(int32(8232)):
						fallthrough
					case pcre_uint32(int32(8233)):
						{
							if int32((BOOL(isprop))) != 0 {
								return NotBOOL(BOOL(negated))
							}
						}
					default:
						{
							if (*((*pcre_uint32)(func() unsafe.Pointer {
								tempVar := &_pcre_ucp_gentype[0]
								return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
							}())) == pcre_uint32((uint32(ucp_Z)))) == (int32((isprop)) != 0) {
								return NotBOOL(BOOL(negated))
							}
							break
						}
					}
				}
			case int32(8):
				{
					if (((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_L)))) || (*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_N))))) || (c == pcre_uint32((uint32('_'))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(10):
				{
					if c < pcre_uint32((uint32(int32(160)))) {
						if (((c == pcre_uint32((uint32('$')))) || (c == pcre_uint32((uint32('@'))))) || (c == pcre_uint32((uint32('`'))))) == (int32((isprop)) != 0) {
							return NotBOOL(BOOL(negated))
						}
					} else {
						if ((c < pcre_uint32((uint32(int32(55296))))) || (c > pcre_uint32((uint32(int32(57343)))))) == (int32((isprop)) != 0) {
							return NotBOOL(BOOL(negated))
						}
					}
				}
			case int32(11):
				{
					if ((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) != pcre_uint32((uint32(ucp_Z)))) && ((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) != pcre_uint32((uint32(ucp_C)))) || ((((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Cf) && (c != pcre_uint32((uint32(int32(1564)))))) && (c != pcre_uint32((uint32(int32(6158)))))) && ((c < pcre_uint32((uint32(int32(8294))))) || (c > pcre_uint32((uint32(int32(8297))))))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(12):
				{
					if (((int32(uint8((pcre_uint8((*prop).chartype)))) != ucp_Zl) && (int32(uint8((pcre_uint8((*prop).chartype)))) != ucp_Zp)) && ((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) != pcre_uint32((uint32(ucp_C)))) || (((int32(uint8((pcre_uint8((*prop).chartype)))) == ucp_Cf) && (c != pcre_uint32((uint32(int32(1564)))))) && ((c < pcre_uint32((uint32(int32(8294))))) || (c > pcre_uint32((uint32(int32(8297))))))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			case int32(13):
				{
					if ((*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_P)))) || ((c < pcre_uint32((uint32(int32(128))))) && (*((*pcre_uint32)(func() unsafe.Pointer {
						tempVar := &_pcre_ucp_gentype[0]
						return unsafe.Pointer(uintptr(unsafe.Pointer(tempVar)) + (uintptr)(int32(uint8((pcre_uint8((*prop).chartype)))))*unsafe.Sizeof(*tempVar))
					}())) == pcre_uint32((uint32(ucp_S)))))) == (int32((isprop)) != 0) {
						return NotBOOL(BOOL(negated))
					}
				}
			default:
				{
					return BOOL((int32(0)))
				}
			}
			data = ((*pcre_uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + (uintptr)(int32(2))*unsafe.Sizeof(*data))))
		}
	}
	return BOOL(negated)
}

/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/ //
/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2013 University of Cambridge

  The machine code generator part (this module) was written by Zoltan Herczeg
                      Copyright (c) 2010-2013

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/ //
/* These are dummy functions to avoid linking errors when JIT support is not
being compiled. */ //
//

// pcre_jit_free_unused_memory - transpiled function from  /root/Documents/pcre-8.42/pcre_jit_compile.c:11899
func pcre_jit_free_unused_memory() {
}

func init() {
	stdin = noarch.Stdin
	stdout = noarch.Stdout
	stderr = noarch.Stderr
}

/* End of pcre_get.c */
/* End of pcre_maketables.c */
/* End of pcre_dfa_exec.c */
/* End of pcre_study.c */
/* End of pcre_version.c */
/* End of pcre_compile.c */
/* End of pcre_refcount.c */
/* End of pcre_jit_compile.c */
/* End of pcre_byte_order.c */
/* End of pcre_fullinfo.c */
/* End of pcre_newline.c */
/* End of pcre_valid_utf8.c */
/* End of pcre_exec.c */
/* End of pcre_config.c */
/* End of pcre_ord2utf8.c */
/* End of pcre_xclass.c */
/* End of pcre_jit_compile.c */
